<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>安卓中的jni开发</title>
    <link href="/2021/10/22/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84jni%E5%BC%80%E5%8F%91/"/>
    <url>/2021/10/22/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84jni%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="安卓中使用JNI"><a href="#安卓中使用JNI" class="headerlink" title="安卓中使用JNI"></a>安卓中使用JNI</h2><h3 id="1-jni概念"><a href="#1-jni概念" class="headerlink" title="1.jni概念"></a>1.jni概念</h3><p>JNI 是指 Java 原生接口。它定义了 Android 从受管理代码（使用 Java 或 Kotlin 编程语言编写）编译的字节码与原生代码（使用 C/C++ 编写）互动的方式。</p><p>从 JVM 角度，存在两种类型的代码：“Java”和“native”, native 一般指的是 c/c++，为了使 java 和 native 端能够进行交互，java 设计了 JNI（java native interface）。</p><p><code>JNI</code> 允许<code>java</code>虚拟机内运行的java代码与C++、C++和汇编等其他编程语言编写的应用程序和库进行互操作。</p><p>使用 native 代码的主要场景，比如：</p><ul><li>代码效率：使用 native 代码的性能更高</li><li>跨平台特性：标准Java类库不支持应用程序所需的依赖于平台的特性，或者希望用较低级别的语言（如汇编语言）实现一小部分时间关键型代码。</li></ul><p>native 层使用 <code>JNI</code> 主要可以做到：</p><ul><li>创建、检查和更新Java对象（包括数组和字符串）。</li><li>调用Java方法。</li><li>加载类并获取类信息。</li></ul><p>简单来说就是<code>java/kotlin</code> 开发与<code>c/c++</code>开发之间的桥梁</p><h3 id="2-android-studio中配置ndk"><a href="#2-android-studio中配置ndk" class="headerlink" title="2.android studio中配置ndk"></a>2.<code>android studio</code>中配置<code>ndk</code></h3><p><code>ndk</code>:原生开发套件 (<code>NDK</code>) 是Android Studio提供的一套工具，使您能够在 Android 应用中使用 C 和 C++ 代码。Android Studio 编译原生库的默认构建工具是<code>CMake</code>。</p><h3 id="3-abi"><a href="#3-abi" class="headerlink" title="3.abi"></a>3.<code>abi</code></h3><p><code>abi</code>是应用程序二进制接口（Application Binary Interface）,由于众多安卓手机使用的<code>cpu</code>不同，使得其支持的指令集不同，目前安卓中主要使用<code>armeabi、armeabi-v7a、x86、mips、arm64-v8a、mips64、x86_64：</code></p><p>在使用ndk时，我们可以在build.gradle文件中对其进行配置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">android &#123;     </span><br><span class="line">    ...     </span><br><span class="line">        defaultConfig &#123;                </span><br><span class="line">            ...         </span><br><span class="line">            ndk &#123;            </span><br><span class="line">                    <span class="comment">//设置支持的SO库架构（开发者可以根据需要，选择一个或多个平台的so）            </span></span><br><span class="line">                    abiFilters <span class="string">&quot;armeabi-v7a&quot;</span>, <span class="string">&quot;arm64-v8a&quot;</span>        </span><br><span class="line">                &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-在android-studio中创建"><a href="#4-在android-studio中创建" class="headerlink" title="4.在android studio中创建"></a>4.在android studio中创建</h3><h4 id="1-直接使用模板创建"><a href="#1-直接使用模板创建" class="headerlink" title="1.直接使用模板创建"></a>1.直接使用模板创建</h4><p><img src="/2021/10/22/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84jni%E5%BC%80%E5%8F%91/image-20211022152313549.png" alt="image-20211022152313549"></p><p><img src="/2021/10/22/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84jni%E5%BC%80%E5%8F%91/image-20211022152406911.png" alt="image-20211022152406911"></p><p>可选择c++标准</p><p>文件结构：</p><p><img src="/2021/10/22/%E5%AE%89%E5%8D%93%E4%B8%AD%E7%9A%84jni%E5%BC%80%E5%8F%91/image-20211022152536256.png" alt="image-20211022152536256"></p><p>在activity中使用</p><p>kotlin:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="comment">// Used to load the &#x27;jnibytemplete&#x27; library on application startup.</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;jnibytemplete&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">   System.loadLibrary(<span class="string">&quot;jnibytemplete&quot;</span>);<span class="comment">//对应CMakeLists文件中的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来进行引入</p><p>CMakeLists文件；</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>( <span class="comment"># Specifies the target library.</span></span><br><span class="line">        jnibytemplete</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Links the target library to the log library</span></span><br><span class="line">        <span class="comment"># included in the NDK.</span></span><br><span class="line">        <span class="variable">$&#123;log-lib&#125;</span>)</span><br></pre></td></tr></table></figure><p>如果需要创建新的c++文件，则在创建后，可以在 cmake中添加</p><p>比如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(<span class="string">&quot;native_lib&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>( <span class="comment"># Sets the name of the library.</span></span><br><span class="line">        native_lib</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Sets the library as a shared library.</span></span><br><span class="line">        SHARED</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Provides a relative path to your source file(s).</span></span><br><span class="line">        native_lib.cpp )</span><br><span class="line">        </span><br><span class="line">        ............</span><br><span class="line">        <span class="keyword">target_link_libraries</span>( <span class="comment"># Specifies the target library.</span></span><br><span class="line">                       jnitest</span><br><span class="line">                        native_lib//此处添加<span class="keyword">project</span>名即可</span><br><span class="line">                       <span class="comment"># Links the target library to the log library</span></span><br><span class="line">                       <span class="comment"># included in the NDK.</span></span><br><span class="line">                       <span class="variable">$&#123;log-lib&#125;</span> )</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h4 id="2-已有工程中创建"><a href="#2-已有工程中创建" class="headerlink" title="2.已有工程中创建"></a>2.已有工程中创建</h4><p>在app/src/main文件夹下创建CMakeLists.txt文件和native-lib.cpp（名字随意）</p><p>配置与使用模板创建一致即可</p><p>另外需要在在 app/build.gradle 中指定cmake 编译文件路径</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"> </span><br><span class="line">    .......</span><br><span class="line"> </span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            path <span class="string">&quot;src/main/cpp/CMakeLists.txt&quot;</span></span><br><span class="line">            version <span class="string">&quot;3.10.2&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>安卓开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>jni</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java设计模式《3》-创建型模式</title>
    <link href="/2021/10/18/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8A3%E3%80%8B-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/10/18/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8A3%E3%80%8B-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="java设计模式之创建者模式"><a href="#java设计模式之创建者模式" class="headerlink" title="java设计模式之创建者模式"></a>java设计模式之创建者模式</h2><p>创建者模式主要关注点在于如何创建对象，主要特点是“将对象的创建与使用分离”，目的在于降低系统耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。</p><p>23种设计模式中属于创建者模式的有以下模式：</p><ul><li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li><li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li><li>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li><li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li><li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li></ul><p>其中工厂方法模式属于类创建，其他的属于对象创建</p><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h3><p>单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。</p><p>使得降低频繁创建同一类的对象的内存消耗，以及对资源的单一管理</p><h4 id="单例模式的特点："><a href="#单例模式的特点：" class="headerlink" title="单例模式的特点："></a>单例模式的特点：</h4><ol><li>单例类只有一个实例对象；</li><li>该单例对象必须由单例类自行创建；</li><li>单例类对外提供一个访问该单例的全局访问点。</li></ol><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>单例模式可以保证内存里只有一个实例，减少了内存的开销。</li><li>可以避免对资源的多重占用。</li><li>单例模式设置全局访问点，可以优化和共享资源的访问。</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。</li><li>在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。</li><li>单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</li></ul><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><ul><li>需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC。</li><li>某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</li><li>某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。</li><li>某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li><li>频繁访问数据库或文件的对象。</li><li>对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。</li><li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li></ul><p>在安卓开发中比较常见使用单例有retrofit与数据库</p><h4 id="单例模式的结构："><a href="#单例模式的结构：" class="headerlink" title="单例模式的结构："></a>单例模式的结构：</h4><ul><li>单例类：包含一个实例且能自行创建这个实例的类。</li><li>访问类：使用单例的类。</li></ul><p>简单的例子就是使用单例封装的retrofit与使用它的repository</p><h4 id="单例模式的实现："><a href="#单例模式的实现：" class="headerlink" title="单例模式的实现："></a>单例模式的实现：</h4><h5 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1.饿汉式"></a>1.饿汉式</h5><p>该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。</p><p>这里与Kotlin中的object进行对比：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance=<span class="keyword">new</span> SingletonDemo();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Kotlin实现</span></span><br><span class="line"><span class="keyword">object</span> SingletonDemo</span><br></pre></td></tr></table></figure><p>在这里他们是等效的</p><h5 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2.懒汉式"></a>2.懒汉式</h5><p>特点是类加载时没有生成单例，只有当第一次调用 getlnstance 方法时才去创建这个单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance=<span class="keyword">new</span> SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用kotlin进行懒汉式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: SingletonDemo? = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">get</span>() &#123;</span><br><span class="line">                <span class="keyword">if</span> (field == <span class="literal">null</span>) &#123;</span><br><span class="line">                    field = SingletonDemo()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> field</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>: SingletonDemo&#123;</span><br><span class="line">        <span class="comment">//这里不用getInstance作为为方法名，是因为在伴生对象声明时，内部已有getInstance方法，所以只能取其他名字</span></span><br><span class="line">         <span class="keyword">return</span> instance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-线程安全的懒汉式"><a href="#3-线程安全的懒汉式" class="headerlink" title="3.线程安全的懒汉式"></a>3.线程安全的懒汉式</h5><p>由于使用懒汉式会出现线程安全的问题，所以需要使用同步锁 synchronized</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;<span class="comment">//使用同步锁</span></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance=<span class="keyword">new</span> SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意此处的单例仍然是不能线程共享的，是线程隔离的，可以添加<code>volatile</code>来使得线程可见</p><p>kotlin实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: SingletonDemo? = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">get</span>() &#123;</span><br><span class="line">                <span class="keyword">if</span> (field == <span class="literal">null</span>) &#123;</span><br><span class="line">                    field = SingletonDemo()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> field</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">@Synchronized</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>: SingletonDemo&#123;</span><br><span class="line">            <span class="keyword">return</span> instance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上一个普通懒汉式基础上添加@Synchonized关键字，使得获取单例是同步的</p><h5 id="4-双重校验锁式"><a href="#4-双重校验锁式" class="headerlink" title="4.双重校验锁式"></a>4.双重校验锁式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonDemo instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span></span>&#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> SingletonDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kotlin:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> instance: SingletonDemo <span class="keyword">by</span> lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) &#123;</span><br><span class="line">        SingletonDemo() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> property: <span class="built_in">Int</span>) &#123;<span class="comment">//这里可以根据实际需求发生改变</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> instance: SingletonDemo? = <span class="literal">null</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(property: <span class="type">Int</span>)</span></span> =</span><br><span class="line">                instance ?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">                    instance ?: SingletonDemo(property).also &#123; instance = it &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给double check添加属性，此处的?:表达式表示为左侧不为空返回左侧，否则执行右侧，简单点说就是右侧是默认值的意思</p><h5 id="5-静态内部类式"><a href="#5-静态内部类式" class="headerlink" title="5.静态内部类式"></a>5.静态内部类式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance=<span class="keyword">new</span> SingletonDemo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> static修饰表示静态的，在类加载时JVM会把它放到方法区，被本类以及本类中所有实例所公用。</p><p>所以此时的静态内部类所包裹的instance将会在程序运行过程中保持唯一性，得到的实例也将是唯一的</p><p><a href="https://juejin.cn/post/6844903791863529480">静态内部类与内部类的区别</a></p><h3 id="2-原型模式（克隆模式）"><a href="#2-原型模式（克隆模式）" class="headerlink" title="2.原型模式（克隆模式）"></a>2.原型模式（克隆模式）</h3><p>原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。</p><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul><li>Java自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。</li><li>可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。</li></ul><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>需要为每一个类都配置一个 clone 方法</li><li>clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。</li><li>当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。</li></ul><p>一般来说默认执行的是浅拷贝</p><h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><h5 id="1-结构划分："><a href="#1-结构划分：" class="headerlink" title="1.结构划分："></a>1.结构划分：</h5><p>原型模式包含以下主要角色。</p><ol><li>抽象原型类：规定了具体原型对象必须实现的接口。</li><li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li></ol><h5 id="2-代码实现："><a href="#2-代码实现：" class="headerlink" title="2.代码实现："></a>2.代码实现：</h5><p>原型模式的深拷贝与浅拷贝存在以下区别：</p><ul><li>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</li><li>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li></ul><p>在实际感受上：浅拷贝只是拷贝了源对象的地址，所以源对象的值发生变化时，拷贝对象的值也会发生变化。而深拷贝则是拷贝了源对象的所有值，所以即使源对象的值发生变化时，拷贝对象的值也不会改变。</p><img src="/2021/10/18/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8A3%E3%80%8B-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/166750fcb9394c44tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom: 67%;"><p>在实现深拷贝上我们可以通过在调用构造函数进行深拷贝，形参如果是基本类型和字符串则直接赋值，如果是对象则重新new一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Address address = <span class="keyword">new</span> Address(<span class="string">&quot;杭州&quot;</span>,<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="string">&quot;s&quot;</span>,address);</span><br><span class="line">User copy = <span class="keyword">new</span> User(user.getName(),<span class="keyword">new</span> Address(address.getCity(),address.getCountry()));</span><br><span class="line">user.getAddress().setCity(<span class="string">&quot;ss&quot;</span>);</span><br><span class="line">System.out.println(user.hashCode()==copy.hashCode());</span><br></pre></td></tr></table></figure><p>由于java 本身提供了clone方法，我们之需要重写方法即可实现浅拷贝（不能对对象内的引用变量进行拷贝）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String country;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ........</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Address <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Address) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设User类中包含address对象，若要对user实现深拷贝，则需要对address和user都重写clone方法即层层拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.......</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> User <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        User user = (User) <span class="keyword">super</span>.clone();</span><br><span class="line">        user.setAddress(<span class="keyword">this</span>.address.clone());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但不仅可以通过层层clone方法来实现深拷贝，也可以通过序列化来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableClone</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;  <span class="function">T <span class="title">clone</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        T another = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//在内存中开辟一块缓冲区，将对象序列化成流</span></span><br><span class="line">            ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(bout);</span><br><span class="line">            out.writeObject(t);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到这一块缓冲区，将字节流反序列化成另一个对象</span></span><br><span class="line">            ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray());</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais);</span><br><span class="line">            another = (T) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> another;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h4><ul><li>对象之间相同或相似，即只是个别的几个属性不同的时候。</li><li>创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。</li><li>创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。</li><li>系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。</li></ul><h3 id="3-简单工厂模式"><a href="#3-简单工厂模式" class="headerlink" title="3.简单工厂模式"></a>3.简单工厂模式</h3><ol><li>工厂模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。</li><li>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。</li><li>在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。</li></ol><p>简单工厂模式并不在23种设计模式之中，其违背了“开闭原则”。</p><p>简单工厂模式并不算是一种设计模式，更多的时候是一种编程习惯。</p><h4 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h4><ol><li>工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。</li><li>客户端无需知道所创建具体产品的类名，只需知道参数即可。</li><li>也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。</li></ol><h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。</li><li>使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度</li><li>系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂</li><li>简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ol><h4 id="应用场景：-2"><a href="#应用场景：-2" class="headerlink" title="应用场景："></a>应用场景：</h4><p>单一产品</p><h4 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h4><ul><li>简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li><li>抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。</li><li>具体产品（ConcreteProduct）：是简单工厂模式的创建目标。</li></ul><p><img src="/2021/10/18/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8A3%E3%80%8B-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/166bb547bd52ad9dtplv-t2oaga2asx-watermark.awebp" alt="简单工厂"></p><h4 id="实现：-1"><a href="#实现：-1" class="headerlink" title="实现："></a>实现：</h4><p>假设生产一批汽车：有红色和黑色</p><p>我们可以定义接口<code>Car</code>,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现Car的接口为<code>RedCar</code>和<code>BlackCar</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedCar</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this car is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span><span class="params">(String color)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (color)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Red&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RedCar();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Black&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> BlackCar();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span>  RuntimeException(<span class="string">&quot;供应商并不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用工厂方法来得到对象</p><h3 id="4-工厂模式"><a href="#4-工厂模式" class="headerlink" title="4.工厂模式"></a>4.工厂模式</h3><p>“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p><h4 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h4><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</li><li>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。</li><li>典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</li></ul><h4 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>类的个数容易过多，增加复杂度</li><li>增加了系统的抽象性和理解难度</li><li>抽象产品只能生产一种产品，此弊端可使用<a href="http://c.biancheng.net/view/1351.html">抽象工厂模式</a>解决。</li></ul><h4 id="应用场景：-3"><a href="#应用场景：-3" class="headerlink" title="应用场景："></a>应用场景：</h4><p>客户只知道创建产品的工厂名，而不知道具体的产品名，不关心具体的工厂（与简单工厂·模式不同点），细节实现由具体工厂处理</p><h4 id="结构：-1"><a href="#结构：-1" class="headerlink" title="结构："></a>结构：</h4><ol><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ol><p>即在简单工厂模式上增加了一层抽象工厂</p><p><img src="/2021/10/18/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8A3%E3%80%8B-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/3-1Q114135A2M3.gif" alt="工厂方法模式的结构图"></p><h4 id="实现：-2"><a href="#实现：-2" class="headerlink" title="实现："></a>实现：</h4><p>以图片加载器的设计来说</p><p><img src="/2021/10/18/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8A3%E3%80%8B-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20211024172734442.png" alt="image-20211024172734442"></p><p>建立一下类结构</p><p>1.定义抽象产品：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.定义具体实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpgReader</span> <span class="keyword">implements</span> <span class="title">Reader</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;jpg reader&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.定义抽象工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReaderFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Reader <span class="title">getReader</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4.定义具体工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpgReaderFactory</span> <span class="keyword">implements</span> <span class="title">ReaderFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reader <span class="title">getReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JpgReader();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java设计模式《2》</title>
    <link href="/2021/10/15/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8A2%E3%80%8B/"/>
    <url>/2021/10/15/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8A2%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式《2》"><a href="#Java设计模式《2》" class="headerlink" title="Java设计模式《2》"></a>Java设计模式《2》</h2><h3 id="软件设计七大原则"><a href="#软件设计七大原则" class="headerlink" title="软件设计七大原则"></a>软件设计七大原则</h3><h4 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1.开闭原则"></a>1.开闭原则</h4><p>开闭原则（Open Closed Principle，OCP）由勃兰特·梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented Software Construction）中提出：软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification）</p><h5 id="1-开闭原则的作用"><a href="#1-开闭原则的作用" class="headerlink" title="1.开闭原则的作用"></a>1.开闭原则的作用</h5><ol><li><p>对软件测试的影响</p><p>如果软件遵守开闭原则的话，软件测试只需要对扩展内容进行测试，而无需对全部功能进行测试</p></li><li><p>提高代码的可复用性</p><p>粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。（这个粒度要根据实际情况来看，比如一个类中，一般不可能只有一个方法）</p></li><li><p>可以提高软件的可维护性</p><p>遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护</p></li></ol><h5 id="2-开闭原则的实现"><a href="#2-开闭原则的实现" class="headerlink" title="2.开闭原则的实现"></a>2.开闭原则的实现</h5><p>通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</p><p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p><p>一般来说使用接口是比较好的选择</p><h4 id="2-里氏替换原则"><a href="#2-里氏替换原则" class="headerlink" title="2.里氏替换原则"></a>2.里氏替换原则</h4><p>里氏替换原则（Liskov Substitution Principle，LSP）由麻省理工学院计算机科学实验室的里斯科夫（Liskov）女士在 1987 年的“面向对象技术的高峰会议”（OOPSLA）上发表的一篇文章《数据抽象和层次》（Data Abstraction and Hierarchy）里提出来的，她提出：继承必须确保超类（父类）所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）。</p><p>里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p><p>阐述了什么时候应该使用继承，什么时候不应该使用继承</p><p>其作用为：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法（很多时候没有做到这一点</li><li>子类中可以增加自己特有的方法</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松</li><li>当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等</li></ul><h5 id="1-里氏替换原则的作用"><a href="#1-里氏替换原则的作用" class="headerlink" title="1.里氏替换原则的作用"></a>1.里氏替换原则的作用</h5><ol><li>里氏替换原则是实现开闭原则的重要方式之一。</li><li>它克服了继承中重写父类造成的可复用性变差的缺点。</li><li>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li><li>加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。</li></ol><h5 id="2-里氏替换原则的实现"><a href="#2-里氏替换原则的实现" class="headerlink" title="2.里氏替换原则的实现"></a>2.里氏替换原则的实现</h5><p>子类可以扩展父类的功能，但不能改变父类原有的功能。即子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>这点在许多的面向对象语言中private定义的变量或方法就是不允许子类改变的</p><p>常见的例子是“几维鸟不是鸟”</p><p>鸟类一般都会飞，但是几维鸟不会非，那么几维鸟到底是不是鸟呢？</p><img src="http://c.biancheng.net/uploads/allimg/181113/3-1Q11311094H32.gif" alt="“几维鸟不是鸟”实例的类图"><p>这时我们就需要重新考虑一下几维鸟该继承谁了，比如继承动物</p><h4 id="3-依赖倒置原则"><a href="#3-依赖倒置原则" class="headerlink" title="3.依赖倒置原则"></a>3.依赖倒置原则</h4><p>依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：要<strong>面向接口编程</strong>，不要面向实现编程。</p><h5 id="1-依赖倒置原则的作用"><a href="#1-依赖倒置原则的作用" class="headerlink" title="1.依赖倒置原则的作用"></a>1.依赖倒置原则的作用</h5><ul><li>依赖倒置原则可以降低类间的耦合性。</li><li>依赖倒置原则可以提高系统的稳定性。</li><li>依赖倒置原则可以减少并行开发引起的风险。</li><li>依赖倒置原则可以提高代码的可读性和可维护性。</li></ul><h5 id="2-依赖倒置原则的实现"><a href="#2-依赖倒置原则的实现" class="headerlink" title="2.依赖倒置原则的实现"></a>2.依赖倒置原则的实现</h5><p>依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。</p><ol><li>每个类尽量提供接口或抽象类，或者两者都具备。</li><li>变量的声明类型尽量是接口或者是抽象类。</li><li>任何类都不应该从具体类派生。</li><li>使用继承时尽量遵循里氏替换原则。</li></ol><p>比较常见的例子是买东西，假如我们要买一个苹果，A商店可以购买，B商店也可以购买，如果我们在定义方法时直接传入的是A是话，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buyApple</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">    a.shell();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如某天A商店关门了，那么方法需要改变，但是如果是采用面向接口编程的话，我们则不需要考虑A是否关门，而只关心谁拥有这个功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        buyApple(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buyApple</span><span class="params">(Shop shop)</span></span>&#123;</span><br><span class="line">        shop.shell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shop</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Shop</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A can shell this &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span>  <span class="title">Shop</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B can shell this&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 B传入依然可以购买到苹果</p><h4 id="4-单一职责原则"><a href="#4-单一职责原则" class="headerlink" title="4.单一职责原则"></a>4.单一职责原则</h4><p>单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则，由罗伯特·C.马丁（Robert C. Martin）于《敏捷软件开发：原则、模式和实践》一书中提出的。这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分（There should never be more than one reason for a class to change）。</p><p>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：</p><ol><li>一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；</li><li>当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。</li></ol><p>个人理解就是：对类进行解耦合</p><h5 id="1-单一职责原则的作用"><a href="#1-单一职责原则的作用" class="headerlink" title="1.单一职责原则的作用"></a>1.单一职责原则的作用</h5><p>单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。</p><ul><li>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。（实际开发中很难遇到，一般一个类都有许多功能</li><li>提高类的可读性。复杂性降低，自然其可读性会提高。</li><li>提高系统的可维护性。可读性提高，那自然更容易维护了。</li><li>变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响</li></ul><h5 id="2-单一指责原则的实现"><a href="#2-单一指责原则的实现" class="headerlink" title="2.单一指责原则的实现"></a>2.单一指责原则的实现</h5><p>单一职责原则的实现需要设计者发现类的职责并将其划分，对设计者分析能力有一定要求，同时，不同人对职责划分也有不同的看法，所以很难把握</p><p>但是举个简单的例子，假如在大学生平时生活中，班级上有不同的班委，他们负责的功能也并不相同，这样，根据他们的职责进行划分，并且他们的职责重叠部分也尽可能的少，这样，我们能很快的找到谁该干什么。这就是个人对单一职责的理解</p><h4 id="5-接口隔离原则"><a href="#5-接口隔离原则" class="headerlink" title="5.接口隔离原则"></a>5.接口隔离原则</h4><p>接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。</p><p>客户端不应该被迫依赖于它不使用的方法（Clients should not be forced to depend on methods they do not use）。该原则还有另外一个定义：一个类对另一个类的依赖应该建立在最小的接口上（The dependency of one class to another one should depend on the smallest possible interface）。</p><p>要为各个类建立它们需要的专用接口</p><p>我的理解：接口专一化加强，将接口解耦</p><h5 id="1-接口隔离原则的作用："><a href="#1-接口隔离原则的作用：" class="headerlink" title="1.接口隔离原则的作用："></a>1.接口隔离原则的作用：</h5><ul><li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li><li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li><li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><h5 id="2-接口隔离原则的实现："><a href="#2-接口隔离原则的实现：" class="headerlink" title="2.接口隔离原则的实现："></a>2.接口隔离原则的实现：</h5><ul><li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li><li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li><li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><p>例如，一个学生拥有许多能力，比如，学习，打电动，吃饭睡觉等生活能力</p><p>我们可以考虑设置三个接口，分别为学习，打电动，生活</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student();</span><br><span class="line">        s.eat();</span><br><span class="line">        s.playGame();</span><br><span class="line">        s.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Study</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PlayGame</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LifeAbility</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Study</span>,<span class="title">LifeAbility</span>,<span class="title">PlayGame</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am study&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am playGame&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am sleep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与单一职责原则不同：</p><p>单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</p><h4 id="6-迪米特法则"><a href="#6-迪米特法则" class="headerlink" title="6.迪米特法则"></a>6.迪米特法则</h4><p>迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)</p><p>定义为：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><h5 id="1-迪米特法则的作用"><a href="#1-迪米特法则的作用" class="headerlink" title="1.迪米特法则的作用"></a>1.迪米特法则的作用</h5><ol><li>降低了类之间的耦合度，提高了模块的相对独立性。</li><li>由于亲合度降低，从而提高了类的可复用率和系统的扩展性。</li></ol><p>个人理解：安卓中的mvp架构就是基于迪米特法则，在view与model之间使用了中介来进行相互调用，从而避免了view和model直接调用，目的是确保了高内聚和低耦合，但是同时导致了接口过多，略显繁琐</p><h5 id="2-迪米特法则的实现方法"><a href="#2-迪米特法则的实现方法" class="headerlink" title="2.迪米特法则的实现方法"></a>2.迪米特法则的实现方法</h5><ol><li>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</li><li>在类的结构设计上，尽量降低类成员的访问权限。</li><li>在类的设计上，优先考虑将一个类设置成不变类。</li><li>在对其他类的引用上，将引用其他对象的次数降到最低。</li><li>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</li><li>谨慎使用序列化（Serializable）功能。（类或接口两端未同步更新，引发序列化失败，，项目管理易疏忽）</li></ol><p>序列化：</p><ol><li>一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。</li><li>将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。</li></ol><p>对象的二进制</p><p>典型例子是明星，粉丝，公司之间的关系，明星不可能直接与粉丝接触，也不好直接与公司接触，所以此时需要工具人经纪人的出现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Star s = <span class="keyword">new</span> Star();</span><br><span class="line">        s.setName(<span class="string">&quot;S&quot;</span>);</span><br><span class="line">        Fans f = <span class="keyword">new</span> Fans();</span><br><span class="line">        f.setName(<span class="string">&quot;SFan&quot;</span>);</span><br><span class="line">        Company c= <span class="keyword">new</span> Company();</span><br><span class="line">        c.setName(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        Agent a = <span class="keyword">new</span> Agent();</span><br><span class="line">        a.setMyCompany(c);</span><br><span class="line">        a.setMyStar(s);</span><br><span class="line">        a.setMyFans(f);</span><br><span class="line">        a.meetWithCompany();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Agent</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Star myStar;</span><br><span class="line">    <span class="keyword">private</span> Fans myFans;</span><br><span class="line">    <span class="keyword">private</span> Company myCompany;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Star <span class="title">getMyStar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myStar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyStar</span><span class="params">(Star myStar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myStar = myStar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fans <span class="title">getMyFans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myFans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyFans</span><span class="params">(Fans myFans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myFans = myFans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Company <span class="title">getMyCompany</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myCompany;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyCompany</span><span class="params">(Company myCompany)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myCompany = myCompany;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetWithFans</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(myStar.getName()+<span class="string">&quot;is meeting with&quot;</span> +myFans.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetWithCompany</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(myStar.getName()+<span class="string">&quot;is meeting with &quot;</span>+myFans.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Star</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fans</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-合成复用原则"><a href="#7-合成复用原则" class="headerlink" title="7.合成复用原则"></a>7.合成复用原则</h4><p>合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p><p>如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</p><p>个人理解：由于继承很多时候存在改变父类方法即重写情况，这一点是违背里氏替换原则（开闭原则的实现 ）的，组合很大程度上能避免这个情况，就是把原本通过继承得到的类，改为在新类中维持一个原本的类，通过新类调用原本类的方法，并且此时扩展性也得到了提高，即可以组合多个类来增强类的功能</p><h5 id="1-合成复用原则的作用："><a href="#1-合成复用原则的作用：" class="headerlink" title="1.合成复用原则的作用："></a>1.合成复用原则的作用：</h5><h6 id="1-继承复用："><a href="#1-继承复用：" class="headerlink" title="1.继承复用："></a>1.继承复用：</h6><p>​        继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化</li></ol><h6 id="2-组合复用："><a href="#2-组合复用：" class="headerlink" title="2.组合复用："></a>2.组合复用：</h6><p>​    将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能</p><ol><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ol><h5 id="2-合成复用原则的实现："><a href="#2-合成复用原则的实现：" class="headerlink" title="2.合成复用原则的实现："></a>2.合成复用原则的实现：</h5><p>由于合成复用原则提倡以组合来代替继承，在安卓上的体现可能在，最新的compose技术，以组合的方式代替原本的继承view体系，即实现同一个复杂控件，在view体系中button继承textview,textview又继承view，这样的继承关系过于复杂。而在 compose中，我们只需要对view进行组合即可完成同样的布局。</p><p>在 java代码上，例如汽车分类</p><p>汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。图 1 所示是用继承：关系实现的汽车分类的类图。</p><p><img src="/2021/10/15/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8A2%E3%80%8B/3-1Q113160133151.gif" alt="用继承关系实现的汽车分类的类图"></p><p>而采用组合关系的话：</p><p><img src="/2021/10/15/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8A2%E3%80%8B/3-1Q11316034X57.gif" alt="用组合关系实现的汽车分类的类图"></p><p>很明显，减少了继承层数，如果出现问题，也能更容易发现错误，在扩展性上，只需要在添加新的功能类即可</p><h4 id="对七种原则的简单理解"><a href="#对七种原则的简单理解" class="headerlink" title="对七种原则的简单理解"></a>对七种原则的简单理解</h4><ul><li>开闭原则强调扩展开放，修改避免</li><li>里氏替换原则强调类继承时尽可能不要修改父类</li><li>依赖倒置原则强调面向接口编程而不是面向实现编程，上层不依赖下层，下层依赖上层，我们应该优先接口化，在去实现接口。</li><li>单一职责原则强调一个类的功能应该单一化，不是你该干的事就不应该出现在类中，换句话说就是各施其职</li><li>接口隔离原则强调接口的细化，一个接口不应该过于庞大</li><li>迪米特原则强调依赖之间的隔离，减少不相干事物的直接链接，在需要时通过中介来进行链接，降低耦合度</li><li>合成复用原则强调组合代替继承</li></ul><p>访问加限制，函数要节俭，依赖不允许，动态加接口，父类要抽象，扩展不更改。</p><p>根本目的为了降低对象之间的耦合，增加程序的可复用性、可扩展性和可维护性。</p>]]></content>
    
    
    <categories>
      
      <category>java设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jvav设计模式</title>
    <link href="/2021/10/15/jvav%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/10/15/jvav%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式《1》"><a href="#Java设计模式《1》" class="headerlink" title="Java设计模式《1》"></a>Java设计模式《1》</h2><p>设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。</p><p>使用设计模式具有以下优点。</p><ul><li>可以提高程序员的思维能力、编程能力和设计能力。</li><li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强</li></ul><p>设计模式不是为了用而用，而是在适当的情况下使用</p><h3 id="23种设计模式简单分类"><a href="#23种设计模式简单分类" class="headerlink" title="23种设计模式简单分类"></a>23种设计模式简单分类</h3><h4 id="1-根据目的来进行划分，可分为三种模式，创建型模式，结构型模式，行为型模式"><a href="#1-根据目的来进行划分，可分为三种模式，创建型模式，结构型模式，行为型模式" class="headerlink" title="1.根据目的来进行划分，可分为三种模式，创建型模式，结构型模式，行为型模式"></a>1.根据目的来进行划分，可分为三种模式，创建型模式，结构型模式，行为型模式</h4><ol><li>创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</li><li>结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</li><li>行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</li></ol><h4 id="2-根据作用范围来分，可分为类模式和对象模式"><a href="#2-根据作用范围来分，可分为类模式和对象模式" class="headerlink" title="2.根据作用范围来分，可分为类模式和对象模式"></a>2.根据作用范围来分，可分为类模式和对象模式</h4><ol><li>类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。</li><li>对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。</li></ol><h3 id="UML下的类关系"><a href="#UML下的类关系" class="headerlink" title="UML下的类关系"></a>UML下的类关系</h3><h5 id="1-类"><a href="#1-类" class="headerlink" title="1.类"></a>1.类</h5><p>类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性</p><h5 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h5><p>接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作</p><h4 id="1-依赖关系"><a href="#1-依赖关系" class="headerlink" title="1.依赖关系"></a>1.依赖关系</h4><p>依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p><p>比如，在安卓开发中，activity依赖与viewmodel来调用viewmodel中的方法</p><h4 id="2-关联关系"><a href="#2-关联关系" class="headerlink" title="2.关联关系"></a>2.关联关系</h4><p>关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。</p><p>在代码中通常将一个类的对象作为另一个类的成员变量来实现关联关系，比如c++中的友元函数，在c++中类中可以定义一个friend变量（其他类，来使得其他类可以访问此类</p><h4 id="3-聚合关系"><a href="#3-聚合关系" class="headerlink" title="3. 聚合关系"></a>3. 聚合关系</h4><p>聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。</p><p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p><h4 id="4-组合关系"><a href="#4-组合关系" class="headerlink" title="4.组合关系"></a>4.组合关系</h4><p>组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。</p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p><p>在安卓目前的compose中，视图构建使用compose函数就是通过组合来代替继承（传统 view体系，导致类继承越来越大</p><h4 id="5-泛化关系"><a href="#5-泛化关系" class="headerlink" title="5.泛化关系"></a>5.泛化关系</h4><p>泛化（Generalization）关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。</p><p>例如，苹果是水果的子类，苹果就是水果的泛化</p><h4 id="6-实现关系"><a href="#6-实现关系" class="headerlink" title="6.实现关系"></a>6.实现关系</h4><p>实现（Realization）关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p><p>例如，交通工具接口，车辆实现了此接口，车辆就是交通工具接口的实现类、</p><h4 id="类关系记忆技巧"><a href="#类关系记忆技巧" class="headerlink" title="类关系记忆技巧"></a><a href="http://c.biancheng.net/view/8375.html">类关系记忆技巧</a></h4><h3 id="优秀设计的特征"><a href="#优秀设计的特征" class="headerlink" title="优秀设计的特征"></a>优秀设计的特征</h3><ol><li>1.代码复用</li><li>2.扩展性</li></ol>]]></content>
    
    
    <categories>
      
      <category>java设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rust中高语法</title>
    <link href="/2021/10/15/rust%E4%B8%AD%E9%AB%98%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/10/15/rust%E4%B8%AD%E9%AB%98%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Rust-语法学习"><a href="#Rust-语法学习" class="headerlink" title="Rust 语法学习"></a>Rust 语法学习</h2><h3 id="所有权与生命周期"><a href="#所有权与生命周期" class="headerlink" title="所有权与生命周期"></a>所有权与生命周期</h3><p>Rust 在垃圾回收上的做法不同于其他语言，比如java等的gc机制，c/cpp的程序员手动管理，rust走出了第三条路，以所有权和生命周期机制来处理垃圾。</p><p>在思考rust为什么要考虑这种方式时，个人对此有一点认为是，垃圾回收例如jvm的话，在回收垃圾时需要stop the world</p><p>,这使得采用gc机制的性能会稍逊一筹，但是 c和cpp的手动管理，如果是粗心的程序员，那可能会导致一些严重的后果，（但是rust的所有权，生命周期也不太好学）</p><p>来自官方文档上的例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">as_str</span></span>(data: &amp;<span class="built_in">u32</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="comment">// 计算字符串</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哎呀！我们返回了一个只在函数内部存在的东西的引用</span></span><br><span class="line">    <span class="comment">// 悬垂指针！释放后引用！指针别名！</span></span><br><span class="line">    <span class="comment">// （当然这段代码在Rust中不能编译）</span></span><br><span class="line">    &amp;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Rust 的所有权系统使得Rust 知道 <code>&amp;s</code> 生效的作用域，所以可以避免出现逃逸</p><p>有两种引用的类型：</p><ul><li>共享指针：<code>&amp;</code></li><li>可变指针：<code>&amp;mut</code></li></ul><p>它们遵守以下的规则：</p><ul><li>引用的生命周期不能超过被引用内容</li><li>可变引用不能存在别名 (alias)</li></ul>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rust基础语法</title>
    <link href="/2021/10/13/rust%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/10/13/rust%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="RUST基础语法"><a href="#RUST基础语法" class="headerlink" title="RUST基础语法"></a>RUST基础语法</h2><h3 id="一，从Hello-World-进入"><a href="#一，从Hello-World-进入" class="headerlink" title="一，从Hello World 进入"></a>一，从Hello World 进入</h3><p>首先，我们看一下在python中的函数是如何定义的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br></pre></td></tr></table></figure><p>在kotlin中如何定义</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在rust中，我们的hello world（主函数 则是这样的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，rust 使用 <em>fn</em> 来标记函数，类似于kotlin 的 fun 和 python 的 def ,其次rust 依然保留了 <em>;</em> 来进行语句分割</p><p>而这里使用的 “println!” 也不是普通的函数，而是 <em>宏</em></p><h3 id="二-，基础数据类型"><a href="#二-，基础数据类型" class="headerlink" title="二 ，基础数据类型"></a>二 ，基础数据类型</h3><p>在 Rust 中，每一个值都属于某一个 数据类型（data type），这告诉 Rust 它被指定为何种数据，以便明确数据处理方式。我们将看到两类数据类型子集：标量（scalar）和复合（compound）。</p><h4 id="Rust-中的整型"><a href="#Rust-中的整型" class="headerlink" title="Rust 中的整型"></a>Rust 中的整型</h4><table><thead><tr><th><strong>长度</strong></th><th><strong>有符号</strong></th><th><strong>无符号</strong></th></tr></thead><tbody><tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr><tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr><tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr><tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr><tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr></tbody></table><h4 id="Rust-中的浮点数"><a href="#Rust-中的浮点数" class="headerlink" title="Rust 中的浮点数"></a>Rust 中的浮点数</h4><p>Rust 中浮点数有两种类型 分别为 <code>f32</code> 与 <code>f64</code> ,在速度上，两者并无区别，然而 <strong>f64</strong> 的精度更高</p><h4 id="Rust-中的-布尔型"><a href="#Rust-中的-布尔型" class="headerlink" title="Rust 中的 布尔型"></a>Rust 中的 布尔型</h4><p>rust 中的布尔型为 <code>bool</code> 其两个值分别为 <code>true</code> 和 <code>false</code> </p><h4 id="Rust-中的字符类型"><a href="#Rust-中的字符类型" class="headerlink" title="Rust 中的字符类型"></a>Rust 中的字符类型</h4><p>rust 中使用  <code>&#39; &#39;</code> 来表示一个字符，其类型为  <code>char</code> ,当然不止于普通字符，rust 甚至可以表示表情</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> heart_eyed_cat = &#x27;😻&#x27;;</span><br></pre></td></tr></table></figure><h4 id="Rust-中的复合类型"><a href="#Rust-中的复合类型" class="headerlink" title="Rust 中的复合类型"></a>Rust 中的复合类型</h4><p><strong>复合类型</strong>（<em>Compound types</em>）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p><h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h5><p>元组是一个将多个其他类型的值组合进一个复合类型的主要方式。</p><p>我们使用包含在圆括号中的逗号分隔的值列表来创建一个元组。元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。这个例子中使用了可选的类型注解：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>rust 同时也拥有其他高级语言解构的特性</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;</span><br></pre></td></tr></table></figure><p>其也可以使用  <code>.</code> 来进行访问</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> five_hundred = x.<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> six_point_four = x.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> one = x.<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>与元组不同，数组中的每个元素的类型必须相同。Rust 中的数组与一些其他语言中的数组不同，因为 Rust 中的数组是固定长度的：一旦声明，它们的长度不能增长或缩小。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> a: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其使用 <code>[]</code> 来进行访问</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> first = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> second = a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果访问下标超出，rust 则会采用类似java的方式，抛出一个 <em>panic</em></p><h3 id="三-变量与可变性"><a href="#三-变量与可变性" class="headerlink" title="三,  变量与可变性"></a>三,  变量与可变性</h3><p>rust 使用 let 来进行变量的声明，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其默认是不可变的，因此，你无法对此变量进行能改变其值的操作，比如 +-*/等，</p><p>但可以利用rust 的重影特性</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它将隐藏掉第一次a 的值，即现在a  为2</p><p>如果我们一定要对值进行改变的话，可以在声明变量时进行这样的操作</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a =<span class="number">1</span>;</span><br><span class="line">    a = a+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明常量</p><p>常量（constants）。类似于不可变变量，常量是绑定到一个名称的不允许改变的值，不过常量与变量还是有一些区别。</p><p>首先，不允许对常量使用 mut。常量不光默认不能变，它总是不能变。</p><p>声明常量使用 const 关键字而不是 let，并且 必须 注明值的类型。在下一部分，「数据类型」 中会介绍类型和类型注解，现在无需关心这些细节，记住总是标注类型即可。</p><p>常量可以在任何作用域中声明，包括全局作用域，这在一个值需要被很多部分的代码用到时很有用。</p><p>最后一个区别是，常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其他只能在运行时计算出的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_POINTS: <span class="built_in">u32</span> = <span class="number">100_000</span>;</span><br></pre></td></tr></table></figure><h3 id="四，控制流程"><a href="#四，控制流程" class="headerlink" title="四，控制流程"></a>四，控制流程</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p><code>if</code> 表达式允许根据条件执行不同的代码分支。你提供一个条件并表示 「如果条件满足，运行这段代码；如果条件不满足，不运行这段代码。」</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was true&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的条件 <strong>必须</strong> 是 <code>bool</code> 值 ,其避免了 c语言中不为0就是真的情况</p><h5 id="使用-else-if-处理多重条件"><a href="#使用-else-if-处理多重条件" class="headerlink" title="使用 else if 处理多重条件"></a>使用 <code>else if</code> 处理多重条件</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number % <span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 4&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 3&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 2&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;number is not divisible by 4, 3, or 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在-let-语句中使用-if"><a href="#在-let-语句中使用-if" class="headerlink" title="在 let 语句中使用 if"></a>在 <code>let</code> 语句中使用 <code>if</code></h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> condition = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="keyword">if</span> condition &#123;</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">6</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of number is: &#123;&#125;&quot;</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if</code> 是一个表达式,其具有返回值，因此可以作为右值</p><p>注意，表达式的两个部分类型需要相同，不然会导致异常</p><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>多次执行同一段代码是很常用的，Rust 为此提供了多种 <strong>循环</strong>（<em>loops</em>）。一个循环执行循环体中的代码直到结尾并紧接着回到开头继续执行</p><p>Rust 有三种循环：<code>loop</code>、<code>while</code> 和 <code>for</code></p><h5 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h5><p>loop 作为rust 的三循环之一，其特性为永不停止，通俗来说就是一个 while(true)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;again!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loop ~ loop ~ </p><p>其也可以通过 break 来进行返回值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(result, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会被停止的循环返回</p><h5 id="while"><a href="#while" class="headerlink" title="while"></a>while</h5><p>经典程序设计语言必备</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> number = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line"></span><br><span class="line">        number = number - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它将在 while 与 {} 之间的表达式为真的时候执行</p><h5 id="for"><a href="#for" class="headerlink" title="for"></a>for</h5><p>此处的for循环使用的是类似python的迭代器模式，它将对一个拥有迭代器特性(trait,类似于jvav的 interface）的变量进行迭代</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> a.iter() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="使用for-来倒计时"><a href="#使用for-来倒计时" class="headerlink" title="使用for 来倒计时"></a>使用for 来倒计时</h6><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).rev() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>numpy多维数组运算</title>
    <link href="/2021/10/04/numpy%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BF%90%E7%AE%97/"/>
    <url>/2021/10/04/numpy%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h3 id="numpy创建矩阵及简单操作"><a href="#numpy创建矩阵及简单操作" class="headerlink" title="numpy创建矩阵及简单操作"></a>numpy创建矩阵及简单操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">A = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A)<span class="comment">#打印A</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.ndim(A))<span class="comment">#打印数组的维度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.shape)<span class="comment">#打印A的形状,其返回值是一个元组</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;对于多维数组而言&quot;&quot;&quot;</span></span><br><span class="line">B = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line"><span class="built_in">print</span>(B.shape)</span><br></pre></td></tr></table></figure><p>对此的输出结果是</p><p><img src="/2021/10/04/numpy%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BF%90%E7%AE%97/image-20211004201108415.png" alt="image-20211004201108415"></p><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">B = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.dot(A,B))<span class="comment">#矩阵相乘，满足线性代数运算</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rust输入的几种方式</title>
    <link href="/2021/10/03/rust%E8%BE%93%E5%85%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/10/03/rust%E8%BE%93%E5%85%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Rust输入数字"><a href="#Rust输入数字" class="headerlink" title="Rust输入数字"></a>Rust输入数字</h1><h2 id="一行输入一个数据"><a href="#一行输入一个数据" class="headerlink" title="一行输入一个数据"></a>一行输入一个数据</h2><p>首先我们需要先导入</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br></pre></td></tr></table></figure><p>然后声明一个String类型的变量</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> input = <span class="built_in">String</span>::new();</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io::stdin().read_line(&amp;<span class="keyword">mut</span> input)</span><br><span class="line">           .expect(<span class="string">&quot;Failed to read line&quot;</span>);</span><br></pre></td></tr></table></figure><p>最后对类型进行处理一下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input= input.trim().parse::&lt;<span class="built_in">i32</span>&gt;().unwrap();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="一行输入多个数据"><a href="#一行输入多个数据" class="headerlink" title="一行输入多个数据"></a>一行输入多个数据</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> input=<span class="built_in">String</span>::new();</span><br><span class="line">        io::stdin().read_line(&amp;<span class="keyword">mut</span> input).unwrap();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> s = input.split_whitespace();</span><br><span class="line">        <span class="keyword">let</span> a: <span class="built_in">i32</span> = s.next().unwrap().parse().unwrap();</span><br><span class="line">        <span class="keyword">let</span> b: <span class="built_in">i32</span> = s.next().unwrap().parse().unwrap();</span><br><span class="line">        <span class="keyword">let</span> c: <span class="built_in">i32</span> = s.next().unwrap().parse().unwrap();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jvm</title>
    <link href="/2021/10/03/jvm/"/>
    <url>/2021/10/03/jvm/</url>
    
    <content type="html"><![CDATA[<h1 id="浅入理解Java虚拟机-雾"><a href="#浅入理解Java虚拟机-雾" class="headerlink" title="浅入理解Java虚拟机(雾"></a>浅入理解Java虚拟机(雾</h1><h2 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a>什么是JVM？</h2><p>JVM 全称为Java Virtual  Machine ,JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p><h2 id="JVM带来的好处"><a href="#JVM带来的好处" class="headerlink" title="JVM带来的好处"></a>JVM带来的好处</h2><ul><li><p>一次编写，到处运行(“Write once, run anywhere”)</p></li><li><p>自动内存管理</p></li><li><p>数组下标越界检查</p></li></ul><h2 id="常见的JVM"><a href="#常见的JVM" class="headerlink" title="常见的JVM"></a>常见的JVM</h2><img src="/2021/10/03/jvm/20200914100723848.png" style="zoom:50%;"><p>现在应该大多数的hotspot</p><h2 id="JVM-JRE-JDK的区别"><a href="#JVM-JRE-JDK的区别" class="headerlink" title="JVM JRE JDK的区别"></a>JVM JRE JDK的区别</h2><img src="/2021/10/03/jvm/525d84b7d526290a7c88900636ed1033.png" style="zoom:50%;"><h2 id="Java代码是如何被执行的"><a href="#Java代码是如何被执行的" class="headerlink" title="Java代码是如何被执行的"></a>Java代码是如何被执行的</h2><p><img src="/2021/10/03/jvm/image-20210806170716879.png" alt="image-20210806170716879"></p><p><strong>一 编写java源程序</strong></p><p><strong>二、当java源程序编码结束后，就需要编译器编译。</strong></p><p>快进到javac编译为class</p><p>快进到看字节流</p><p><img src="/2021/10/03/jvm/image-20210805083235867.png"></p><p>如果这里用cat直接看是乱码，但是在idea里面看的话，他会进行一些编写，然后成这样</p><p><img src="/2021/10/03/jvm/image-20210805083418893.png"></p><p><code>cafe babe</code> 被称为“魔数”，是 JVM 识别 .class 文件的标志。文件格式的定制者可以自由选择魔数值（只要没用过），比如说 .png 文件的魔数是 <code>8950 4e47</code>。</p><h2 id="JVM-的结构"><a href="#JVM-的结构" class="headerlink" title="JVM 的结构"></a>JVM 的结构</h2><img src="/2021/10/03/jvm/8d1de13006ae9e0dd40d5e1db98a81c81603447597022.png" style="zoom: 50%;"><p>由此图可以得知：</p><p>JVM的结构分为以下内容：类加载器（ClassLoader）、执行引擎、内存区（运行时数据区）、本地方法接口。</p><p>其中内存区包括：虚拟机栈，本地方法栈，方法区，堆，程序计数器</p><h3 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h3><p>Program Counter Register</p><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。（概念模型中：字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令）</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li><strong>线程私有</strong>：</li></ul><p>多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器</strong>，各条线程之间计数器互不影响，独立存储。</p><ul><li><strong>状态</strong>：</li></ul><p>①执行java方法，计数器记录虚拟机字节码指令的地址；②执行<strong>native方法，计数器为空（undefined）</strong></p><p>因为native方法是java通过JNI直接调用本地C/C++库，可以近似的认为native方法相当于C/C++暴露给java的一个接口，java通过调用这个接口从而调用到C/C++方法。由于该方法是通过C/C++而不是java进行实现。那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。</p><img src="https://images2018.cnblogs.com/blog/1266638/201807/1266638-20180710225811662-425101318.png" alt="img" style="zoom:67%;"><ul><li><strong>占用内存小，唯一不会OutOfMemoryError的区域</strong></li></ul><p>因为其本质上是寄存器来着</p><p><strong>接下来 简单演示一下如何查看字节码</strong></p><p>可以在 idea中安装插件jclasslib来进行查看</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>VM Stack</p><p>Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><ul><li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li><li>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存</li><li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></li></ul><p>典中典之常见虚拟机栈讲解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            method2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = a + b;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我打算进行演示</p><h4 id="常见虚拟机栈问题"><a href="#常见虚拟机栈问题" class="headerlink" title="常见虚拟机栈问题"></a>常见虚拟机栈问题</h4><p>垃圾回收是否涉及栈内存？</p><ul><li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li></ul><p>栈内存的分配越大越好吗？</p><ul><li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li></ul><p>设置参数方法：-Xss size 通常只有几百K</p><p>决定了函数调用的深度<br>每个线程都有独立的栈空间</p><p>局部变量、参数 分配在栈上</p><p>此处进入android studio调整vm 参数的地方</p><p>ps:idea64.exe.vmoptions针对的是 IDEA 环境，对通过 IDEA 运行的 <a href="https://www.jianshu.com/p/3c330074082b">Java 项目</a>不起作用。IDEA 本身就是一个 Java 应用，所以也必须运行于 JVM 之上。此处的idea64.exe.vmoptions文件就是用来配置 64 位的 IDEA 所使用的 JVM 参数。是 IDEA 运行时用的配置，并不是项目运行的配置</p><img src="/2021/10/03/jvm/image-20210802160632576.png" style="zoom:67%;"><p>运行单个项目时可以这样</p><img src="/2021/10/03/jvm/image-20210806161449743.png" style="zoom:67%;"><p>内存溢出:</p><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p><p>发生原因：</p><ul><li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li><li>每个栈帧<strong>所占用过大</strong></li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈（Native Method Stacks）与 Java 虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的 Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java Heap</p><p>对于Java应用程序来说，Java堆是虚拟机所管理的内存的最大的一块。是被所有线程共享的一块内存区域（因为对象都是在堆里面创建的，而所有的线程都可以拿到对象的引用，所以在多线程并发过程中，对于一些对象，我们得加锁），这里稍微提一下并发和并行（下面几种垃圾回收器得用到）</p><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p><p>堆里面包含了以下内容</p><img src="https://img-blog.csdnimg.cn/20191208160358777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;"><p>在垃圾回收哪里讲讲</p><h4 id="并发-concurrency-："><a href="#并发-concurrency-：" class="headerlink" title="并发(concurrency)："></a>并发(concurrency)：</h4><p>指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p><p><img src="https://upload-images.jianshu.io/upload_images/7557373-da64ffd6d1effaac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/295/format/webp" alt="img"></p><p>简单点来说对与cpu处理并发任务就是宏观是并联的，微观是串联的</p><p>涉及时间片那些我就不说了（主要是忘记了</p><h4 id="并行-parallel-："><a href="#并行-parallel-：" class="headerlink" title="并行(parallel)："></a>并行(parallel)：</h4><p>指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</p><p><img src="https://upload-images.jianshu.io/upload_images/7557373-72912ea8e89c4007.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/313/format/webp" alt="img"></p><h4 id="出现在堆的常见异常："><a href="#出现在堆的常见异常：" class="headerlink" title="出现在堆的常见异常："></a>出现在堆的常见异常：</h4><p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p><img src="https://img-blog.csdnimg.cn/20200627192624320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5OTY1ODAw,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 67%;"><p>典中典之内存不够了</p><img src="/2021/10/03/jvm/image-20210804131002232.png" style="zoom:67%;"><h4 id="堆内存诊断工具"><a href="#堆内存诊断工具" class="headerlink" title="堆内存诊断工具:"></a>堆内存诊断工具:</h4><h5 id="jps"><a href="#jps" class="headerlink" title="jps"></a><strong>jps</strong></h5><p><img src="/2021/10/03/jvm/image-20210804102154659.png"></p><p>查看jvav运行的进程号</p><img src="/2021/10/03/jvm/image-20210804102300807.png" style="zoom:50%;"><p><strong>-q</strong> 只显示pid，不显示class名称,jar文件名和传递给main方法的参数</p><p><strong>-m</strong> 输出传递给main方法的参数，在嵌入式jvm上可能是null</p><p><strong>-l</strong> 输出应用程序main class的完整package名或者应用程序的jar文件完整路径名</p><p><strong>-v</strong> 输出传递给JVM的参数</p><p><strong>-V</strong> 隐藏输出传递给JVM的参数</p><h5 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a><strong>jmap</strong></h5><img src="/2021/10/03/jvm/image-20210804103419141.png" style="zoom:50%;"><p>   MinHeapFreeRatio     </p><ul><li><p>空闲堆空间的最小百分比，计算公式为：HeapFreeRatio =(CurrentFreeHeapSize/CurrentTotalHeapSize) * 100，值的区间为0到100，默认值为 40。如果HeapFreeRatio &lt; MinHeapFreeRatio，则需要进行堆扩容，扩容的时机应该在每次垃圾回收之后。</p><p> MaxHeapFreeRatio       </p></li><li><p>空闲堆空间的最大百分比，计算公式为：HeapFreeRatio =(CurrentFreeHeapSize/CurrentTotalHeapSize) * 100，值的区间为0到100，默认值为 70。如果HeapFreeRatio &gt; MaxHeapFreeRatio，则需要进行堆缩容，缩容的时机应该在每次垃圾回收之后。</p></li></ul><ol><li><p>   MaxHeapSize      JVM 堆空间允许的最大值。</p></li><li><p>   NewSize                  JVM 新生代堆空间的默认值。</p></li><li><p>   MaxNewSize              JVM 新生代堆空间允许的最大值。</p></li><li><p>   OldSize                  JVM 老年代堆空间的默认值。</p></li><li><p>   NewRatio                 新生代（2个Survivor区和Eden区 ）与老年代（不包括永久区）的堆空间比值</p></li><li><p>   SurvivorRatio            两个Survivor区和Eden区的堆空间比值为 他，表示 S0 ： S1 ：Eden = 1：1：？。</p></li><li><p>   MetaspaceSize           JVM 元空间的默认值。 </p></li><li><p>  MaxMetaspaceSize   JVM 元空间允许的最大值         </p></li><li><p>Compressed Class space 压缩类空间大小，Maximum size of class area in Metaspace when compressed class pointers are used（挺复杂的，而且大小不能超过32G，但是hotpot限制在了3g内，）</p></li><li><p>G1HeapRegionSize         在使用 G1 垃圾回收算法时，JVM 会将 Heap 空间分隔为若干个 Region，该参数用来指定每个 Region 空间的大小。</p></li></ol><p>Capacity = Regions * RegionSize 大小</p><p>这里先说一下这个命令遇到的一些坑</p><p>网上很多时候说使用jmap -heap pid来进行查看内存使用情况，但是这个命令对于jdk8之后的版本，不能再使用jmap -heap pid的命令了。<br>使用旧的命令会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: -heap option used</span><br><span class="line">Cannot connect to core dump or remote debug server. Use jhsdb jmap instead</span><br></pre></td></tr></table></figure><p>现场展示一下查看内存的步骤</p><p>jmap用法参考</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jmap [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    &lt;none&gt;               to print same info as Solaris pmap</span><br><span class="line">    -heap                to print java heap summary</span><br><span class="line">    -histo[:live]        to print histogram of java object heap; if the &quot;live&quot;</span><br><span class="line">                         suboption is specified, only count live objects</span><br><span class="line">    -permstat            to print permanent generation statistics</span><br><span class="line">    -finalizerinfo       to print information on objects awaiting finalization</span><br><span class="line">    -dump:&lt;dump-options&gt; to dump java heap in hprof binary format</span><br><span class="line">                         dump-options:</span><br><span class="line">                           live         dump only live objects; if not specified,</span><br><span class="line">                                        all objects in the heap are dumped.</span><br><span class="line">                           format=b     binary format</span><br><span class="line">                           file=&lt;file&gt;  dump heap to &lt;file&gt;</span><br><span class="line">                         Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</span><br><span class="line">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo</span><br><span class="line">                         to force a heap dump or histogram when &lt;pid&gt; does not</span><br><span class="line">                         respond. The &quot;live&quot; suboption is not supported</span><br><span class="line">                         in this mode.</span><br><span class="line">    -h | -help           to print this help message</span><br><span class="line">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br></pre></td></tr></table></figure><p>此外需要注意一下如果一台设备上有多个jdk需要指定一下具体路径下的jvm工具（当然创建项目时使用环境中的jdk就不用</p><p>（怒 这个导致我查了好久的博客，网上讲这个错误的还比较稀少</p><h5 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a><strong>jconsole</strong></h5><p>理论上直接使用jconsole就能进入，但是可能会出一些bug</p><p>比如，我遇到的</p><img src="/2021/10/03/jvm/image-20210804114409842.png" style="zoom:50%;"><p>但是有的进程又可以链接，</p><img src="/2021/10/03/jvm/image-20210804114918627.png" style="zoom:50%;"><p>这个还可以进行远程链接</p><p>此处将进行一些常见操作将进行演示</p><h5 id="jvirsalvm"><a href="#jvirsalvm" class="headerlink" title="jvirsalvm"></a><strong>jvirsalvm</strong></h5><p>这个不太会，jump了</p><p><a href="https://www.cnblogs.com/baihuitestsoftware/articles/6405580.html">更多详情</a></p><h4 id="堆的一些参数配置"><a href="#堆的一些参数配置" class="headerlink" title="堆的一些参数配置"></a>堆的一些参数配置</h4><p>-XX:NewRatio:  设置Yong 和 Old的比例，比默认值为2，则Old Generation是 Yong Generation的2倍，即Yong Generation占据内存的1/3<br>-XX:NewSize : 设置Yong Generation的初始值大小<br>-XX:MaxNewSize：设置Yong Generation的最大值大小<br>-XX:SurviorRatio : 设置Eden和一个Suivior的比例，默认值为8，即Eden是To(S2)的比例是8，（From和To是一样大的），此时Eden占据Yong Generation的8/10<br>-XX:InitialTenuringThreshol : 设置晋升到老年代的对象年龄的最小值，默认为7<br>-XX:MaxTenuringThreshold : 设置晋升到老年代的对象年龄的最大值</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>结构：</p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png" alt="img" style="zoom:67%;"><p>由此图可以看见，在jvm 1.6和1.8有很大区别，首先是方法·区由jvm中转移到了本地内存中，StringTable也由常量池中转移到了堆里面，永久代变为了元空间（有一些报错也变了，但是鉴于我们现在使用的都是1.8以后的版本了，所以这里只会提到1.8的版本</p><p>copy一下元空间</p><h4 id="metaspace的组成"><a href="#metaspace的组成" class="headerlink" title="metaspace的组成"></a>metaspace的组成</h4><p>metaspace其实由两大部分组成</p><ul><li>Klass Metaspace</li><li>NoKlass Metaspace</li></ul><p>Klass Metaspace就是用来存klass的，klass是我们熟知的class文件在jvm里的运行时数据结构，不过有点要提的是我们看到的类似A.class其实是存在heap里的，是java.lang.Class的一个对象实例。这块内存是紧接着Heap的，和我们之前的perm一样，这块内存大小可通过<code>-XX:CompressedClassSpaceSize</code>参数来控制，这个参数前面提到了默认是1G，但是这块内存也可以没有，假如没有开启压缩指针就不会有这块内存，这种情况下klass都会存在NoKlass Metaspace里，另外如果我们把-Xmx设置大于32G的话，其实也是没有这块内存的，因为会这么大内存会关闭压缩指针开关。还有就是这块内存最多只会存在一块。</p><p>NoKlass Metaspace专门来存klass相关的其他的内容，比如method，constantPool等，这块内存是由多块内存组合起来的，所以可以认为是不连续的内存块组成的。这块内存是必须的，虽然叫做NoKlass Metaspace，但是也其实可以存klass的内容，上面已经提到了对应场景。</p><p>Klass Metaspace和NoKlass Mestaspace都是所有classloader共享的，所以类加载器们要分配内存，但是每个类加载器都有一个SpaceManager，来管理属于这个类加载的内存小块。如果Klass Metaspace用完了，那就会OOM了，不过一般情况下不会，NoKlass Mestaspace是由一块块内存慢慢组合起来的，在没有达到限制条件的情况下，会不断加长这条链，让它可以持续工作。</p><p>UseCompressedOops用来关闭类压缩</p><p>64bit的JVM出现后，OOPS的尺寸也变成了64bit，比之前的大了一倍。这会引入性能损耗——占的内存double了，并且同尺寸的CPU Cache要少存一倍的OOPS。</p><p>OOPS是指“ordinary object pointers“，就是原始指针。Java Runtime可以用这个指针直接访问指针对应的内存，做相应的操作（比如发起GC时做copy and sweep）。</p><p>从JDK6_u23开始UseCompressedOops被默认打开了。因此既能享受64bit带来的好处，又避免了64bit带来的性能损耗。当然，如果你有机会使用超过32G的堆内存，记得把这个选项关了。</p><h5 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h5><ul><li>1.8以前会导致<strong>永久代</strong>内存溢出</li><li>1.8以后会导致<strong>元空间</strong>内存溢出</li></ul><h2 id="垃圾回收-amp-amp-性能优化基础"><a href="#垃圾回收-amp-amp-性能优化基础" class="headerlink" title="垃圾回收&amp;&amp;性能优化基础"></a>垃圾回收&amp;&amp;性能优化基础</h2><h3 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收"></a>1、如何判断对象可以回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>在对象中添加一个引用计数器，每当有一个地方<br>引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可<br>能再被使用的。</p><p>引用计数算法（Reference Counting）虽然占用了一些额外的内存空间来进行计数，但<br>它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法</p><p>单纯的引用计数<br>就很难解决对象之间相互循环引用的问题。</p><p>来自深入理解Jvm虚拟机的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 假设在这行发生GC，objA和objB是否能被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testGC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看看如何设置打印日志</p><p>此处得花一点时间</p><p>看看效果</p><p><img src="/2021/10/03/jvm/image-20210804143908786.png"></p><p>此处的12M-&gt;2M意味着虚拟机并没有因为这两<br>个对象互相引用就放弃回收它们，这也从侧面说明了Java虚拟机并不是通过引用计数算法来判断对象<br>是否存活的。</p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>-XX:+PrintGC</td><td>输出简单GC日志</td></tr><tr><td>-XX:+PrintGCDetails</td><td>输出详细GC日志，并且虚拟机退出前打印堆栈使用信息</td></tr><tr><td>-XX:+PrintHeapAtGC</td><td>在每次GC前后都打印堆栈信息</td></tr><tr><td>-XX:+PrintGCTimeStamps</td><td>输出GC的时间戳（以基准时间的形式）,JVM启动后的时间偏移量。</td></tr><tr><td>-XX:+PrintGCDateStamps</td><td>输出GC的时间戳（以日期的形式，如2020-04-02T10:09:01.045+0800）</td></tr><tr><td>-Xloggc:./gc.log    日志文件的输出路径</td><td>日志文件的输出路径</td></tr><tr><td>-XX:SurvivorRatio=8</td><td>定义了年轻代中Eden区与一个Survivor区的空间比例是8:1</td></tr><tr><td>-Xmx</td><td>设定程序运行期间最大可占用的内存大小</td></tr><tr><td>-Xms</td><td>设定程序启动时占用内存大小，大一点一般启动更快</td></tr><tr><td>-Xmn</td><td>设置年轻代占用内存大小</td></tr><tr><td>-XX:MaxTenuringThreshold=N</td><td>对象年龄达到N后，下一次GC将进入老年代，可以为0</td></tr></tbody></table><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>come from 深入理解Java虚拟机</p><p>当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是<br>通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路就是通过<br>一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过<br>程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，<br>或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p><img src="/2021/10/03/jvm/image-20210804144414534.png" style="zoom:67%;"><p><strong>可以作为GC Root的对象</strong></p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul><h3 id="2-五种引用"><a href="#2-五种引用" class="headerlink" title="2.五种引用"></a>2.五种引用</h3><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png" alt="img" style="zoom:67%;"><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p><ul><li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p><ul><li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p><p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p><ul><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li></ul><h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul><li>软引用和弱引用<strong>可以配合</strong>引用队列<ul><li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li></ul></li><li>虚引用和终结器引用<strong>必须配合</strong>引用队列<ul><li>虚引用和终结器引用在使用时会关联一个引用队列</li></ul></li></ul><h3 id="3-垃圾回收算法"><a href="#3-垃圾回收算法" class="headerlink" title="3.垃圾回收算法"></a>3.垃圾回收算法</h3><p><strong>标记-清除（Mark-Sweep）</strong><br>GC分为两个阶段，标记和清除。首先标记所有可回收的对象，在标记完成后统一回收所有被标记的对象。同时会产生不连续的内存碎片。碎片过多会导致以后程序运行时需要分配较大对象时，无法找到足够的连续内存，而不得已再次触发GC。</p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png" alt="img" style="zoom:67%;"><ul><li><strong>复制（Copy）</strong><br>将内存按容量划分为两块，每次只使用其中一块。当这一块内存用完了，就将存活的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。这样使得每次都是对半个内存区回收，也不用考虑内存碎片问题，简单高效。缺点需要两倍的内存空间。<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png" alt="img" style="zoom:67%;"></li></ul><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png" alt="img" style="zoom:67%;"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png" alt="img" style="zoom:67%;"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png" alt="img" style="zoom:67%;"><ul><li><strong>标记-整理（Mark-Compact）</strong><br>也分为两个阶段，首先标记可回收的对象，再将存活的对象都向一端移动，然后清理掉边界以外的内存。此方法避免标记-清除算法的碎片问题，同时也避免了复制算法的空间问题。<br>一般年轻代中执行GC后，会有少量的对象存活，就会选用复制算法，只要付出少量的存活对象复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外过多内存空间分配，就需要使用标记-清理或者标记-整理算法来进行回收。</li></ul><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png" alt="img" style="zoom:67%;"><h3 id="4-分代回收"><a href="#4-分代回收" class="headerlink" title="4.分代回收"></a>4.分代回收</h3><p>将堆内存分为两个部分，一部分名为新生代，一部分名为老年代</p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png" alt="img" style="zoom:67%;"><p>其中新生代分为了伊甸园，幸存区from，幸存区to。</p><p>首先，new出来的对象在伊甸园进行创建</p><p>当伊甸园的内存不足是，就会进行垃圾回收，此时叫做minor GC,</p><ul><li>Minor GC会将伊甸园和幸存区FROM存活对象复制到幸存区TO中，使得其寿命加一(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)，在交换两个幸存区</li></ul><p>不管怎样，都会保证名为To的幸存区是空的，Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p><ul><li>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</li><li>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></li><li>再次创建对象，若新生代的伊甸园又满了，则会再次触发 Minor GC（会触发 stop the world， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，还会回收幸存区中的垃圾，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象寿命加1</li></ul><h4 id="有关新生代的JVM参数"><a href="#有关新生代的JVM参数" class="headerlink" title="有关新生代的JVM参数"></a><strong>有关新生代的JVM参数</strong></h4><p>1)-XX:NewSize和-XX:MaxNewSize</p><p>用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。</p><p>2)-XX:SurvivorRatio</p><p>用于设置Eden和其中一个Survivor的比值，这个值也比较重要。</p><p>3)-XX:+PrintTenuringDistribution</p><p>这个参数用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。</p><p>4).-XX:InitialTenuringThreshol和-XX:MaxTenuringThreshold</p><p>用于设置晋升到老年代的对象年龄的最小值和最大值，每个对象在坚持过一次Minor GC之后，年龄就加1。</p><p>康康jstart输出</p><p><img src="/2021/10/03/jvm/image-20210805074443338.png"></p><p>其中各参数代表</p><ul><li>S0，S1，两个survivor区域，可以看到它们的使用率为0</li><li>E，代表eden，这是年轻代用于分配新的对象的区域。</li><li>O，代表老年代，这是我们今天要重点讲的内容。</li><li>M，代表metaspace，这块内容以后再讲（也有可能永远不再讲了，看情况）</li><li>CCS，压缩使用比例。可以先不管这个。这个和使用压缩指针有关系。可以使用-XX:-UseCompressedOops关掉压缩的功能，这一项就不再打印了。</li><li>YGC，年轻代回收的次数。</li><li>YGCT，年轻代回收所使用的时间。由于年轻代的回收使用copy GC。会让所有Java线程都停顿下来，所以这一项就是指用于年轻代回收的时间。</li><li>FGC，这一项就比较复杂了。在不同的GC组合中代表不同的意义，后面会详细讲到。</li><li>FGCT，与上面的FGC一定样的，字面意思是full gc time，但在不同的GC选项下，意义有所不同。</li><li>GCT，一般来说，等于YGCT与FGCT之和。</li></ul><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><ul><li><p><strong>串行收集器（Serial）</strong><br>比较老的收集器，单线程。收集时，必须暂停应用的工作线程，直到收集结束。</p></li><li><p><strong>并行收集器（Parallel）</strong><br>多条垃圾收集线程并行工作，在多核CPU下效率更高，应用线程仍然处于等待状态。</p></li><li><p>CMS收集器（Concurrent Mark Sweep）</p><p>CMS收集器是缩短暂停应用时间为目标而设计的，是基于标记-清除算法实现，整个过程分为4个步骤，包括：</p><ul><li>初始标记（Initial Mark）</li><li>并发标记（Concurrent Mark）</li><li>重新标记（Remark）</li><li>并发清除（Concurrent Sweep）</li></ul><p>单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</p></li></ul><p>​        <strong>JDK1.8默认使用</strong>的垃圾回收器</p><ul><li>G1</li></ul><p>​           Garbage First</p><p>​            JDK 9以后默认使用，而且替代了CMS 收集器</p><p>​      G1的特点</p><ul><li>G1不再坚持固定大小以及固定数量的<br>分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的<br>Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的<br>旧对象都能获取很好的收集效果</li></ul><img src="https://tse1-mm.cn.bing.net/th/id/R-C.d6e8f8b74e546354d6cc594269f88487?rik=BezOq%2fgcDZHlWw&riu=http%3a%2f%2fupload-images.jianshu.io%2fupload_images%2f2184951-256a9ccb6e51be85.png&ehk=6aQFuTMvcG2m353MYMeVw4gN4PZ0p1xl%2bkzX5pUOPEk%3d&risl=&pid=ImgRaw&r=0" alt="查看源图像" style="zoom: 50%;"><p>G1：分为了四个执行步骤：</p><img src="/2021/10/03/jvm/image.2BEI70.png" style="zoom: 67%;"><ul><li>初始标记，</li><li>并发标记，</li><li>最终标记，</li><li>筛选回收</li></ul><p>初始标记，标记一下GC Roots能直接关联到的对象。并发标记从GC Root开始标记存活对象，这个阶段耗时比较长，但也可以与应用线程并发执行。而最终标记也是为了修正在并发标记期间因用户程序继续运作而导致标记产生变化的那一部分标记记录。最后在筛选回收阶段对各个Region回收价值和成本进行排序，根据用户所期望的GC暂停时间来执行回收。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-XX:+UseSerialGC</td><td align="left">串行收集器</td></tr><tr><td align="left">-XX:+UseParallelGC</td><td align="left">并行收集器</td></tr><tr><td align="left">-XX:+UseParallelGCThreads=8</td><td align="left">并行收集器线程数，同时有多少个线程进行垃圾回收，一般与CPU数量相等</td></tr><tr><td align="left">-XX:+UseParallelOldGC</td><td align="left">指定老年代为并行收集</td></tr><tr><td align="left">-XX:+UseConcMarkSweepGC</td><td align="left">CMS收集器（并发收集器）</td></tr><tr><td align="left">-XX:+UseCMSCompactAtFullCollection</td><td align="left">开启内存空间压缩和整理，防止过多内存碎片</td></tr><tr><td align="left">-XX:CMSFullGCsBeforeCompaction=0</td><td align="left">表示多少次Full GC后开始压缩和整理，0表示每次Full GC后立即执行压缩和整理</td></tr><tr><td align="left">-XX:CMSInitiatingOccupancyFraction=80%</td><td align="left">表示老年代内存空间使用80%时开始执行CMS收集，防止过多的Full GC</td></tr><tr><td align="left">-XX:+UseG1GC</td><td align="left">G1收集器</td></tr><tr><td align="left">-XX:MaxTenuringThreshold=0</td><td align="left">在年轻代经过几次GC后还存活，就进入老年代，0表示直接进入老年代</td></tr></tbody></table><ul><li>选择高效的GC算法，可有效减少停止应用线程时间。</li><li>频繁Full GC会增加暂停时间和CPU使用率，可以加大老年代空间大小降低Full GC，但会增加回收时间，根据业务适当取舍。</li></ul><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>类从被加载到虚拟机内存到被卸载，整个完整的生命周期包括：类加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证，准备，解析三个部分统称为连接。接下来我们可以详细了解下类加载的各个过程。</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3279460766e7484dbee19e086739d0f0~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.awebp" alt="img" style="zoom:33%;"><p>这里还是快进到看《深入理解Java虚拟机》把</p><p>虽然classloader的加载过程有复杂的5步，但事实上除了加载之外的四步，其它都是由JVM虚拟机控制的，我们除了适应它的规范进行开发外，能够干预的空间并不多。而加载则是我们控制classloader实现特殊目的最重要的手段了。</p><p>双亲委托机制</p><p>这个东西和事件分发有点相反，事件分发是先往下推，在往上推，而类加载机制是先往上推，没人推了，在执行</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e6b8ee8c76847ed85f25d2624c35985~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.awebp" alt="img" style="zoom: 33%;"><p>双亲委派模型能够保证同一个类最终会被特定的类加载器加载。</p><p>例如类java.lang.Object,它存放在rt.jart之中.无论哪一个类加载器都要加载这个类.最终都是双亲委派模型最顶端的Bootstrap类加载器去加载.因此Object类在程序的各种类加载器环境中都是同一个类.相反.如果没有使用双亲委派模型.由各个类加载器自行去加载的话.如果用户编写了一个称为“java.lang.Object”的类.并存放在程序的ClassPath中.那系统中将会出现多个不同的Object类.java类型体系中最基础的行为也就无法保证.应用程序也将会一片混乱.</p><p>类加载器：</p><ul><li><p>启动类加载器(Bootstrap Classloader)负责将<JAVA_HOME>/lib目录下并且被虚拟机识别的类库加载到虚拟机内存中。我们常用基础库，例如java.util.**，java.io.**，java.lang.**等等都是由根加载器加载。</JAVA_HOME></p><p>由C++写的,由JVM启动</p></li><li><p>扩展类加载器(Extention Classloader)负责加载JVM扩展类，比如swing系列、内置的js引擎、xml解析器等，这些类库以javax开头，它们的jar包位于<JAVA_HOME>/lib/ext目录中。</JAVA_HOME></p></li><li><p>应用程序加载器(Application Classloader)也叫系统类加载器，它负责加载用户路径(ClassPath)上所指定的类库。我们自己编写的代码以及使用的第三方的jar包都是由它来加载的。</p></li><li><p>自定义加载器(Custom Classloader)通常是我们为了某些特殊目的实现的自定义加载器，</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kotlin</title>
    <link href="/2021/10/03/kotlin/"/>
    <url>/2021/10/03/kotlin/</url>
    
    <content type="html"><![CDATA[<h1 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h1><h2 id="kotlin是什么？"><a href="#kotlin是什么？" class="headerlink" title="kotlin是什么？"></a>kotlin是什么？</h2><p>Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift（确实长的很像），由 JetBrains 设计开发并开源。</p><p>Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。</p><p>在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。</p><h2 id="Kotlin好处都有啥？"><a href="#Kotlin好处都有啥？" class="headerlink" title="Kotlin好处都有啥？"></a>Kotlin好处都有啥？</h2><p>作为现代语言，kotlin具有高效的特点，具有严格的“防空思想”，也是一门能让人甜到齁的语言，有接管java的意图，借助安卓走向全平台，spring走向后端，ksl用来操作gradle,基于jvm也使它具有很好的跨平台性，并且拥有很多其他语言的优越地方，比如协程等</p><h2 id="Kotlin的一些基础语法"><a href="#Kotlin的一些基础语法" class="headerlink" title="Kotlin的一些基础语法"></a>Kotlin的一些基础语法</h2><h3 id="基本数据类型及简单操作"><a href="#基本数据类型及简单操作" class="headerlink" title="基本数据类型及简单操作"></a>基本数据类型及简单操作</h3><table><thead><tr><th>类型</th><th>位宽度</th></tr></thead><tbody><tr><td>Double</td><td>64</td></tr><tr><td>Float</td><td>32</td></tr><tr><td>Long</td><td>64</td></tr><tr><td>Int</td><td>32</td></tr><tr><td>Short</td><td>16</td></tr><tr><td>Byte</td><td>8</td></tr></tbody></table><h4 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h4><p>eg:</p><table><thead><tr><th>十进制：123</th></tr></thead><tbody><tr><td>长整型以大写的 L 结尾：123L</td></tr><tr><td>16 进制以 0x 开头：0x0F</td></tr><tr><td>2 进制以 0b 开头：0b00001011</td></tr><tr><td>注意：8进制不支持</td></tr><tr><td>Doubles 默认写法: 123.5, 123.5e10</td></tr><tr><td>Floats 使用 f 或者 F 后缀：123.5f</td></tr></tbody></table><h4 id="通用类型转化"><a href="#通用类型转化" class="headerlink" title="通用类型转化"></a>通用类型转化</h4><table><thead><tr><th>toByte(): Byte</th></tr></thead><tbody><tr><td>toShort(): Short</td></tr><tr><td>toInt(): Int</td></tr><tr><td>toLong(): Long</td></tr><tr><td>toFloat(): Float</td></tr><tr><td>toDouble(): Double</td></tr><tr><td>toChar(): Char</td></tr></tbody></table><h4 id="位操作符（这个感觉用的少"><a href="#位操作符（这个感觉用的少" class="headerlink" title="位操作符（这个感觉用的少"></a>位操作符（这个感觉用的少</h4><table><thead><tr><th>shl(bits) – 左移位 (Java’s &lt;&lt;)</th></tr></thead><tbody><tr><td>shr(bits) – 右移位 (Java’s &gt;&gt;)</td></tr><tr><td>ushr(bits) – 无符号右移位 (Java’s &gt;&gt;&gt;)</td></tr><tr><td>and(bits) – 与</td></tr><tr><td>or(bits) – 或</td></tr><tr><td>xor(bits) – 异或</td></tr><tr><td>inv() – 反向</td></tr></tbody></table><h4 id="字符串，布尔，字符，数组"><a href="#字符串，布尔，字符，数组" class="headerlink" title="字符串，布尔，字符，数组"></a>字符串，布尔，字符，数组</h4><p>字符不可当作数字操作，</p><p>布尔操作与java相同（||,!,&amp;&amp;)，</p><p>数组通过内置的Array类实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> b = Array(<span class="number">3</span>, &#123; i -&gt; (i * <span class="number">2</span>) &#125;)</span><br><span class="line"><span class="comment">//有点python列表表达式的感觉</span></span><br></pre></td></tr></table></figure><p>字符串可以通过trimMargin()来去掉多余空白</p><p>可以通过”$”来将变量整进字符串中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> s = <span class="string">&quot;1 = <span class="variable">$a</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="包の导入"><a href="#包の导入" class="headerlink" title="包の导入"></a>包の导入</h2><h5 id="kotlin使用import-来导入包，导入方式与python相似"><a href="#kotlin使用import-来导入包，导入方式与python相似" class="headerlink" title="kotlin使用import 来导入包，导入方式与python相似"></a>kotlin使用import 来导入包，导入方式与python相似</h5><p>eg:</p><table><thead><tr><th>import org.example.Message                                                       // 现在 Message 可以不用限定符访问</th></tr></thead><tbody><tr><td>import org.example.* // “org.example”中的一切都可访问</td></tr><tr><td>import org.example.Message // Message 可访问<br>import org.test.Message as testMessage                                             // testMessage 代表“org.test.Message”</td></tr></tbody></table><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a>if 表达式</h3><p>在kotlin中 if表达式有返回值，因此与传统语言相比，带来了不少便捷</p><p>比如在java中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max ;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> d = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">if</span> (b&gt;d) &#123;</span><br><span class="line">    max  = b;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    max = d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在kotlin中，我们可以这样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span>(a&gt;b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><p>并且代码块的最后一个语句将作为返回值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    print(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="when表达式"><a href="#when表达式" class="headerlink" title="when表达式"></a>when表达式</h3><p>kotlin取消掉了switch case语法结构，使用了when来实现了相应功能</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; print(<span class="string">&quot;x == 1&quot;</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; print(<span class="string">&quot;x == 2&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123; <span class="comment">// 注意这个块</span></span><br><span class="line">        print(<span class="string">&quot;x is neither 1 nor 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且，可对多个目标进行匹配，如:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span> -&gt; print(<span class="string">&quot;x == 0 or x == 1&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">&quot;otherwise&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>when语句将对 “()” 里面的内容进行匹配，此内容作为主语，在代码块中可对此进行匹配操作(不限制与常量)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> -&gt; print(<span class="string">&quot;x is in the range&quot;</span>)</span><br><span class="line">    <span class="keyword">is</span> String -&gt; print(<span class="string">&quot;x is String&quot;</span>)<span class="comment">//类型匹配</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">&quot;none of the above&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当when未加主语时，可类似用做if else 语句</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">    x.isOdd() -&gt; print(<span class="string">&quot;x is odd&quot;</span>)</span><br><span class="line">    y.isEven() -&gt; print(<span class="string">&quot;y is even&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">&quot;x+y is odd.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>kotlin中for循环可以对任何提供迭代器（iterator）的对象进行遍历，例如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection) print(item)</span><br></pre></td></tr></table></figure><p>循环体同样也适用于代码块</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(item :<span class="built_in">Int</span> <span class="keyword">in</span> collection)&#123;</span><br><span class="line">    <span class="keyword">val</span> temp = <span class="number">1</span></span><br><span class="line">    print(item+temp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对数字区间的迭代</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从1到3</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">6</span> downTo <span class="number">0</span> step <span class="number">2</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从6到0以2为步长</span></span><br></pre></td></tr></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>kotlin的while循环与c等类似拥有while与do while</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    x--</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------</span></span><br><span class="line"><span class="keyword">var</span> x =<span class="number">10</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  x--</span><br><span class="line">&#125; <span class="keyword">while</span> (x !=<span class="number">0</span>) </span><br></pre></td></tr></table></figure><p>break与continue仍然适用</p><h3 id="返回与跳转"><a href="#返回与跳转" class="headerlink" title="返回与跳转"></a>返回与跳转</h3><h4 id="结构化跳转表达式及标签"><a href="#结构化跳转表达式及标签" class="headerlink" title="结构化跳转表达式及标签"></a>结构化跳转表达式及标签</h4><p>kotlin有三种结构化跳转表达式：</p><table><thead><tr><th>return。默认从最直接包围它的函数或者匿名函数返回。</th></tr></thead><tbody><tr><td>break。终止最直接包围它的循环</td></tr><tr><td>continue。继续下一次最直接包围它的循环。</td></tr></tbody></table><p>此外，这三种表达式都可以使用标签来进行标记，标签格式为<em>abc@</em></p><p>eg:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">loop@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i+j==<span class="number">100</span>&amp;&amp;<span class="number">2</span>*i+3j==<span class="number">100</span>)&#123;</span><br><span class="line">             <span class="keyword">break</span><span class="symbol">@loop</span></span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>标签限制的 break 跳转到刚好位于该标签指定的循环后面的执行点。 <em>continue</em> 继续标签指定的循环的下一次迭代。</strong></p><h4 id="标签的常用操作"><a href="#标签的常用操作" class="headerlink" title="标签的常用操作"></a>标签的常用操作</h4><p>由于kotlin函数可以嵌套，因此我们在处理一些跳转时，比如从匿名函数中退出</p><p>假如是这样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">3</span>) <span class="keyword">return</span><span class="comment">// 非局部直接返回到 foo() 的调用者</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;end of all&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于return 将退出函数，因此它将会退出整个函数</p><p>所以我们可以使用匿名函数来解决这个问题</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach(<span class="function"><span class="title">fun</span><span class="params">(it: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">3</span>) <span class="keyword">return</span><span class="comment">// 局部返回到匿名函数的调用者，即 forEach 循环</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;)</span><br><span class="line">    print(<span class="string">&quot;end of all&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但也可以使用标签来处理</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach <span class="symbol">lit@</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@lit</span> <span class="comment">// 局部返回到该 lambda 表达式的调用者，即 forEach 循环</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;end of all&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标签也可以返回值到指定位置</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span><span class="symbol">@a</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>他将返回1到”@a”</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类的基本"><a href="#类的基本" class="headerlink" title="类的基本"></a>类的基本</h3><p>kotlin使用class来声明类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>()&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若无实体还可以这样写</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br></pre></td></tr></table></figure><p>kotlin的类构造器分为主构造器和多个次构造器</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span></span>(name:String)&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若无需为添加注释或修饰符，可以省略</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>(name:String)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主构造函数不能包含任何的代码，初始化工作可以放在init的代码块中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>(name:String)&#123;</span><br><span class="line">    <span class="keyword">var</span> nameUpper :String =<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        nameUpper = name.uppercase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明或初始化属性还可以这么写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name:String)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类也可以声明前缀有constructor的次构造函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nameUpper :String =<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">constructor</span>(name:String)&#123;</span><br><span class="line">        nameUpper=name.uppercase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init代码块部分会成主构造函数的一部分，将在次构造函数前执行</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Constructors</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Init block&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(i: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;Constructor&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未声明构造函数时，他将隐式的生成且可见性是public因此我们可以把他private掉</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GirlFriend</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>()&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主构造函数可以设置默认值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>(<span class="keyword">val</span> specices :String =<span class="string">&quot;human being&quot;</span>)</span><br></pre></td></tr></table></figure><p>kotlin中无<code>new</code>关键字</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>kotlin的所有类拥有一个共同的超类Any </p><p><code>Any</code> 有三个方法：<code>equals()</code>、 <code>hashCode()</code> 与 <code>toString()</code>。因此，为所有 Kotlin 类都定义了这些方法。</p><p>默认情况下kotlin的类是<code>final</code>的，因此不可被继承，若要使他能被继承，则需要添加<code>open</code>关键字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(name:String)</span><br></pre></td></tr></table></figure><p>若需要继承此类，则可这样表达</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> </span>(name:String):Person(name)</span><br></pre></td></tr></table></figure><p>对于继承后的属性，以下面的这个例子来说</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>(name:String)&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> nameUpper :String =<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> age:<span class="built_in">Int</span>=<span class="number">1</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        nameUpper = name.uppercase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:<span class="type">Person&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> nameUpper :String =<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> age:<span class="built_in">Int</span>=<span class="number">2</span></span><br><span class="line">    <span class="keyword">constructor</span>(name:String):<span class="keyword">super</span>(name)&#123;</span><br><span class="line">        nameUpper=name.uppercase()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//次构造函数可以写多个继承不同属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于父类需要被覆盖属性，需要声明为<code>open</code>,然后在子类中添加<code>override</code>来进行标记，若此子类的属性不希望被覆盖掉，则可以添加<code>final</code>关键字，例如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">var</span> age:<span class="built_in">Int</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>方法也是同样的</p><p>若我们希望子类调用父类的方法，则可以使用<code>super</code>关键字来进行调用，</p><p>[^使用super<T>来调用具体的属性或方法]: </T></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;this fruit is being ate&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Orange</span></span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;this orange is being ate&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lemon</span>: <span class="type">Fruit</span>,<span class="type">Orange</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;Fruit&gt;.eat()</span><br><span class="line">        <span class="keyword">super</span>&lt;Orange&gt;.eat()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="伴生对象companion-object"><a href="#伴生对象companion-object" class="headerlink" title="伴生对象companion object"></a>伴生对象companion object</h3><p><code>companion object</code> 修饰为伴生对象,伴生对象在类中只能存在一个，类似于java中的静态方法 Java 中使用类访问静态成员，静态方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = <span class="string">&quot;DemoManager&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.e(TAG,<span class="string">&quot;此时 companion objec t表示 伴生对象&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此<code>companion object</code>中调用不到外部成员变量（静态方法无法调用非静态成员变量）</p><h3 id="Kotlin中的各种类"><a href="#Kotlin中的各种类" class="headerlink" title="Kotlin中的各种类"></a>Kotlin中的各种类</h3><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类使用<code>abstract</code>来标记抽象类</p><p>类以及其中的某些成员可以声明为 <em>abstract</em>。 抽象成员在本类中可以不用实现</p><p>使用抽象类来覆盖一个非抽象的开放成员</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> : <span class="type">Polygon</span></span>() &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h4><p>kotlin使用<code>data</code>来标记数据类，在java16(最新的jvav16中使用了<code>record</code>关键字来实现了此功能)前，我们实现数据类功能可能需要这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而使用kotlin数据类，可以这样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name :String, <span class="keyword">var</span> age :<span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><h5 id="数据类自带解构方法——componentN"><a href="#数据类自带解构方法——componentN" class="headerlink" title="数据类自带解构方法——componentN()"></a>数据类自带解构方法——componentN()</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (name,age) = p  <span class="comment">//解构p</span></span><br><span class="line">println(<span class="string">&quot;<span class="variable">$name</span> <span class="variable">$age</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="数据类的copy函数"><a href="#数据类的copy函数" class="headerlink" title="数据类的copy函数"></a>数据类的copy函数</h5><p>数据类使用copy函数来对数据类进行复制，并且可对其属性进行修改</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> jack = User(name = <span class="string">&quot;Jack&quot;</span>, age = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> olderJack = jack.copy(age = <span class="number">2</span>)</span><br><span class="line">    println(jack)</span><br><span class="line">    println(olderJack)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h4><p>kotlin中可以使用object来声明单例类</p><p>java中可以这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSington</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleSington INSTANCE;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">SimpleSington</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      INSTANCE = (SimpleSington)<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> SimpleSington();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>在kotlin中可以这么写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> SimpleSington &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>kotlin中使用<code>enum</code>关键字来标记一个枚举类</p><p>枚举类最基本的用法是实现一个类型安全的枚举。</p><p>枚举常量用逗号分隔,每个枚举常量都是一个对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">    RED,BLACK,BLUE,GREEN,WHITE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类可以进行初始化，默认值从0开始，需要指定值，则可以对其使用构造函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>(value:<span class="built_in">Int</span>)&#123;</span><br><span class="line">    ovel(<span class="number">100</span>),</span><br><span class="line">    rectangle(<span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h4><p>kotlin中使用sealed来标记一个密封类</p><p>密封类用来表示受限的类继承结构：当一个值为有限几种的类型, 而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合 也是受限的，但每个枚举常量只存在一个实例，而密封类 的一个子类可以有可包含状态的多个实例。</p><p>声明一个密封类，使用 <strong>sealed</strong> 修饰类，密封类可以有子类，但是所有子类都必须在与密封类自身相同的文件中声明。（在 Kotlin 1.1 之前， 该规则更加严格：子类必须嵌套在密封类声明的内部）。</p><p>密封类的常用操作：</p><p>配合when来使用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Const</span></span>(<span class="keyword">val</span> number: <span class="built_in">Double</span>) : Expr()</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>(<span class="keyword">val</span> e1: Expr, <span class="keyword">val</span> e2: Expr) : Expr()</span><br><span class="line"><span class="keyword">object</span> NotANumber : Expr()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(expr: <span class="type">Expr</span>)</span></span>: <span class="built_in">Double</span> = <span class="keyword">when</span> (expr) &#123;</span><br><span class="line">    <span class="keyword">is</span> Const -&gt; expr.number</span><br><span class="line">    <span class="keyword">is</span> Sum -&gt; eval(expr.e1) + eval(expr.e2)</span><br><span class="line">    NotANumber -&gt; <span class="built_in">Double</span>.NaN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更像是一种枚举类的扩展</p><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>kotlin中委托分为了属性委托和类委托两种</p><h4 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h4><p>属性委托指的是一个类的某个属性值不是在类中直接进行定义，而是将其托付给一个代理类，从而实现对该类的属性统一管理。</p><p>属性委托语法格式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> &lt;属性名&gt;: &lt;类型&gt; <span class="keyword">by</span> &lt;表达式&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>var/val：属性类型(可变/只读)</th></tr></thead><tbody><tr><td>属性名：属性名称</td></tr><tr><td>类型：属性的数据类型</td></tr><tr><td>表达式：委托代理类</td></tr></tbody></table><p>by 关键字之后的表达式就是委托, 属性的 get() 方法(以及set() 方法)将被委托给这个对象的 getValue() 和 setValue() 方法。属性委托不必实现任何接口, 但必须提供 getValue() 函数(对于 var属性,还需要 setValue() 函数)。</p><p>eg:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.reflect.KProperty</span><br><span class="line"><span class="comment">// 定义包含属性委托的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p: String <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$thisRef</span>, 这里委托了 <span class="subst">$&#123;property.name&#125;</span> 属性&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$thisRef</span> 的 <span class="subst">$&#123;property.name&#125;</span> 属性赋值为 <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> e = Example()</span><br><span class="line">    println(e.p)     <span class="comment">// 访问该属性，调用 getValue() 函数</span></span><br><span class="line"></span><br><span class="line">    e.p = <span class="string">&quot;Runoob&quot;</span>   <span class="comment">// 调用 setValue() 函数</span></span><br><span class="line">    println(e.p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h4><p>类的委托即一个类中定义的方法实际是调用另一个类的对象的方法来实现的。</p><p>以下实例中派生类 Derived 继承了接口 Base 所有方法，并且委托一个传入的 Base 类的对象来执行这些方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Base</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现此接口的被委托的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseImpl</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>) : Base &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123; print(x) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过关键字 by 建立委托类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(b: Base) : Base <span class="keyword">by</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> b = BaseImpl(<span class="number">10</span>)</span><br><span class="line">    Derived(b).print() <span class="comment">// 输出 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在某些场景下，假设我们需要在某个类对某个接口的一些方法进行重写，通过类委托来减少强制我们需要重写的方法</p><p>比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMap</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> realMap: HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;) : MutableMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt; <span class="keyword">by</span> realMap &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> lastKey = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(key: <span class="type">Int</span>, value: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">        lastKey = key</span><br><span class="line">        <span class="keyword">return</span> realMap.put(key,value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">recover</span><span class="params">()</span></span> &#123;</span><br><span class="line">        realMap.remove(lastKey)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过将MutableMap委托给realMap使得realMap获得其所有方法，因此只需对我们所关心的方法进行重写</p><p><a href="%5B(28%E6%9D%A1%E6%B6%88%E6%81%AF">更多内容查看</a> “by” the way ——借ViewModel创建方式探索Kotlin的委托机制_Omnipotent’s Blog-CSDN博客](<a href="https://blog.csdn.net/weixin_43687181/article/details/115712877?spm=1001.2014.3001.5501">https://blog.csdn.net/weixin_43687181/article/details/115712877?spm=1001.2014.3001.5501</a>))</p><p>关于委托还有不少东西要说，鉴于篇幅，更多参考<a href="https://www.kotlincn.net/docs/reference/delegated-properties.html">官方文档</a></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型，即-“参数化类型”，将类型参数化，可以用在类，接口，方法上。"><a href="#泛型，即-“参数化类型”，将类型参数化，可以用在类，接口，方法上。" class="headerlink" title="泛型，即 “参数化类型”，将类型参数化，可以用在类，接口，方法上。"></a>泛型，即 “参数化类型”，将类型参数化，可以用在类，接口，方法上。</h3><p>与 Java 一样，Kotlin 也提供泛型，为类型安全提供保证，消除类型强转的烦恼。</p><p>声明一个泛型类:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="type">T</span>&gt;</span>(t: T) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建类的实例时我们需要指定类型参数:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> box: Box&lt;<span class="built_in">Int</span>&gt; = Box&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">val</span> box = Box(<span class="number">1</span>) <span class="comment">// 编译器会进行类型推断，1 类型 Int，所以编译器知道我们说的是 Box&lt;Int&gt;。</span></span><br></pre></td></tr></table></figure><h3 id="泛型约束："><a href="#泛型约束：" class="headerlink" title="泛型约束："></a>泛型约束：</h3><p>我们可以使用泛型约束来设定一个给定参数允许使用的类型。</p><p>Kotlin 中使用 : 对泛型的类型上限进行约束。</p><p>最常见的约束是上界(upper bound)：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="title">sort</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Comparable 的子类型可以替代 T。 例如:</span></span><br><span class="line">sort(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// OK。Int 是 Comparable&lt;Int&gt; 的子类型</span></span><br><span class="line">sort(listOf(HashMap&lt;<span class="built_in">Int</span>, String&gt;())) <span class="comment">// 错误：HashMap&lt;Int, String&gt; 不是 Comparable&lt;HashMap&lt;Int, String&gt;&gt; 的子类型</span></span><br></pre></td></tr></table></figure><p>对于多个上界约束条件，可以用 where 子句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyWhenGreater</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;, threshold: <span class="type">T</span>)</span></span>: List&lt;String&gt;</span><br><span class="line">    <span class="keyword">where</span> T : CharSequence,</span><br><span class="line">          T : Comparable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> list.filter &#123; it &gt; threshold &#125;.map &#123; it.toString() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rust也是用的这玩意修饰的</p><h3 id="型变"><a href="#型变" class="headerlink" title="型变"></a>型变</h3><p>Kotlin 中没有通配符类型，它有两个其他的东西：声明处型变（declaration-site variance）与类型投影（type projections）</p><h4 id="声明处型变"><a href="#声明处型变" class="headerlink" title="声明处型变"></a>声明处型变</h4><p>声明处的类型变异使用协变注解修饰符：in、out，消费者 in, 生产者 out。</p><p>使用 out 使得一个类型参数协变，协变类型参数只能用作输出，可以作为返回值类型但是无法作为入参的类型：</p><p>in 使得一个类型参数逆变，逆变类型参数只能用作输入，可以作为入参的类型但是无法作为返回值的类型：</p><h3 id="星号投射"><a href="#星号投射" class="headerlink" title="星号投射"></a>星号投射</h3><p><a href="https://www.kotlincn.net/docs/reference/generics.html">看看官方的</a></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的基础操作"><a href="#函数的基础操作" class="headerlink" title="函数的基础操作"></a>函数的基础操作</h3><p>kotlin中使用<code>fun</code>来声明函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">double</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数可以具有默认参数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    b: <span class="type">Array</span>&lt;<span class="type">Byte</span>&gt;, </span></span></span><br><span class="line"><span class="params"><span class="function">    off: <span class="type">Int</span> = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    len: <span class="type">Int</span> = b.size,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123; <span class="comment">/*……*/</span> &#125;</span><br></pre></td></tr></table></figure><p>覆盖方法总是使用与基类型方法相同的默认参数值。 当覆盖一个带有默认参数值的方法时，必须从签名中省略默认参数值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(i: <span class="type">Int</span> = <span class="number">10</span>)</span></span> &#123; <span class="comment">/*……*/</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> : <span class="type">A</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(i: <span class="type">Int</span>)</span></span> &#123; <span class="comment">/*……*/</span> &#125;  <span class="comment">// 不能有默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个默认参数在一个无默认值的参数之前，那么该默认值只能通过使用<a href="https://www.kotlincn.net/docs/reference/functions.html#%E5%85%B7%E5%90%8D%E5%8F%82%E6%95%B0">具名参数</a>调用该函数来使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    bar: <span class="type">Int</span> = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    baz: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123; <span class="comment">/*……*/</span> &#125;</span><br><span class="line"></span><br><span class="line">foo(baz = <span class="number">1</span>) <span class="comment">// 使用默认值 bar = 0</span></span><br></pre></td></tr></table></figure><p>如果在默认参数之后的最后一个参数是 lambda 表达式，那么它既可以作为具名参数在括号内传入，也可以在括号外传入：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    bar: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    baz: <span class="type">Int</span> = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    qux: () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123; <span class="comment">/*……*/</span> &#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>) &#123; println(<span class="string">&quot;hello&quot;</span>) &#125;     <span class="comment">// 使用默认值 baz = 1</span></span><br><span class="line">foo(qux = &#123; println(<span class="string">&quot;hello&quot;</span>) &#125;) <span class="comment">// 使用两个默认值 bar = 0 与 baz = 1</span></span><br><span class="line">foo &#123; println(<span class="string">&quot;hello&quot;</span>) &#125;        <span class="comment">// 使用两个默认值 bar = 0 与 baz = 1</span></span><br></pre></td></tr></table></figure><h3 id="Kotlin中不同的函数"><a href="#Kotlin中不同的函数" class="headerlink" title="Kotlin中不同的函数"></a>Kotlin中不同的函数</h3><h4 id="使用suspend标记的协程挂起函数：协程部分讲"><a href="#使用suspend标记的协程挂起函数：协程部分讲" class="headerlink" title="使用suspend标记的协程挂起函数：协程部分讲"></a>使用<code>suspend</code>标记的协程挂起函数：协程部分讲</h4><h4 id="使用infix标记的中缀表示法（忽略该调用的点与圆括号）："><a href="#使用infix标记的中缀表示法（忽略该调用的点与圆括号）：" class="headerlink" title="使用infix标记的中缀表示法（忽略该调用的点与圆括号）："></a>使用<code>infix</code>标记的中缀表示法（忽略该调用的点与圆括号）：</h4><p>条件要求：</p><table><thead><tr><th>它们必须是成员函数或扩展函数；</th></tr></thead><tbody><tr><td>它们必须只有一个参数；</td></tr><tr><td>其参数不得接受可变数量的参数且不能有默认值</td></tr></tbody></table><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">shl</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123; …… &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用中缀表示法调用该函数</span></span><br><span class="line"><span class="number">1</span> shl <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于这样</span></span><br><span class="line"><span class="number">1.</span>shl(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>感觉用的不是很多</p><h4 id="使用tailrec标记的尾递归函数："><a href="#使用tailrec标记的尾递归函数：" class="headerlink" title="使用tailrec标记的尾递归函数："></a>使用<code>tailrec</code>标记的尾递归函数：</h4><p>Kotlin 支持一种称为<a href="https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8">尾递归</a>的函数式编程风格。 这允许一些通常用循环写的算法改用递归函数来写，而无堆栈溢出的风险。 当一个函数用 <code>tailrec</code> 修饰符标记并满足所需的形式时，编译器会优化该递归，留下一个快速而高效的基于循环的版本：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> eps = <span class="number">1E-10</span> <span class="comment">// &quot;good enough&quot;, could be 10^-15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">findFixPoint</span><span class="params">(x: <span class="type">Double</span> = <span class="number">1.0</span>)</span></span>: <span class="built_in">Double</span></span><br><span class="line">        = <span class="keyword">if</span> (Math.abs(x - Math.cos(x)) &lt; eps) x <span class="keyword">else</span> findFixPoint(Math.cos(x))</span><br></pre></td></tr></table></figure><p>要符合 <code>tailrec</code> 修饰符的条件的话，函数必须将其自身调用作为它执行的最后一个操作。在递归调用后有更多代码时，不能使用尾递归，并且不能用在 try/catch/finally 块中。目前在 Kotlin for JVM 与 Kotlin/Native 中支持尾递归。</p><h4 id="泛型函数："><a href="#泛型函数：" class="headerlink" title="泛型函数："></a>泛型函数：</h4><p>kotlin中泛型函数的声明与 Java 相同，类型参数要放在函数名的前面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">boxIn</span><span class="params">(value: <span class="type">T</span>)</span></span> = Box(value)</span><br></pre></td></tr></table></figure><h4 id="单表达函数："><a href="#单表达函数：" class="headerlink" title="单表达函数："></a>单表达函数：</h4><p>当函数返回单个表达式时，可以省略花括号并且在 <strong>=</strong> 符号之后指定代码体即可</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">double</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = x * <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">double</span><span class="params">(x:<span class="type">Int</span>)</span></span>=x*<span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="可变数量的参数（Varargs）"><a href="#可变数量的参数（Varargs）" class="headerlink" title="可变数量的参数（Varargs）:"></a>可变数量的参数（Varargs）:</h4><p>函数的参数（通常是最后一个）可以用 <code>vararg</code> 修饰符标记(类似与python中的*)：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">asList</span><span class="params">(<span class="keyword">vararg</span> ts: <span class="type">T</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = ArrayList&lt;T&gt;()</span><br><span class="line">    <span class="keyword">for</span> (t <span class="keyword">in</span> ts) <span class="comment">// ts is an Array</span></span><br><span class="line">        result.add(t)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> list = asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">//------如果要传递数组也是可以的</span></span><br><span class="line"><span class="keyword">val</span> a  = arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> list = asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,*a)</span><br><span class="line"><span class="comment">//在数组前面加&quot;*&quot;</span></span><br></pre></td></tr></table></figure><h4 id="局部函数："><a href="#局部函数：" class="headerlink" title="局部函数："></a>局部函数：</h4><p>Kotlin 支持局部函数，即一个函数在另一个函数内部(确实很多高级语言都支持）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//官方给的dfs示例</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(graph: <span class="type">Graph</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> visited = HashSet&lt;Vertex&gt;()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(current: <span class="type">Vertex</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.add(current)) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> (v <span class="keyword">in</span> current.neighbors)</span><br><span class="line">            dfs(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(graph.vertices[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且这个是闭包的（支持局部函数的语言应该都通用）可以参考网络上大部分关于js的闭包</p><p>外部无法直接调用内部函数</p><h4 id="成员函数："><a href="#成员函数：" class="headerlink" title="成员函数："></a>成员函数：</h4><p>就是定义在类里面的函数（不就是方法吗</p><h4 id="内联函数："><a href="#内联函数：" class="headerlink" title="内联函数："></a>内联函数：</h4><p>被inline标记的函数就是内联函数,其原理就是:在编译时期,把调用这个函数的地方用这个函数的方法体进行替换</p><p>举个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">method</span><span class="params">( body: () -&gt; <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> body()</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对此方法在main中调用由kotlin字节码转java得到的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TetsKt</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      method((Function0)<span class="keyword">null</span>.INSTANCE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>加了inline标记后是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TetsKt</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> var0 = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">int</span> var1 = <span class="keyword">false</span>;</span><br><span class="line">         String var4 = <span class="string">&quot;我是body的方法体&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         ;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可见inline使得函数整体被移动了过来</p><p>在编译时期就会把下面的内容替换到调用该方法的地方,这样就会减少方法压栈,出栈,进而减少资源消耗;</p><p>noline和crossline标记<a href="https://www.jianshu.com/p/4f29c9724b33">更多参考</a></p><h4 id="高阶函数："><a href="#高阶函数：" class="headerlink" title="高阶函数："></a>高阶函数：</h4><p>在<code>Kotlin</code>中，高阶函数即指：将函数用作一个函数的参数或者返回值的函数</p><p>可能类似于数学中的高次？</p><p>个人理解是在函数中传递一个函数（通常是lambda表达式）</p><p>例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">val</span> sum=&#123;</span><br><span class="line">        d:<span class="built_in">Int</span>,e:<span class="built_in">Int</span>-&gt;d+e</span><br><span class="line">    &#125;</span><br><span class="line">    println(add(a,b,sum))</span><br><span class="line">    <span class="comment">//传递一个lambda表达式</span></span><br><span class="line">    println(add(a,b)&#123;</span><br><span class="line">        a,b-&gt;a+b</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//由于lambda表达式是最后一个，所以可以直接&#123;&#125;</span></span><br><span class="line">    println(add(a,b,::sumOf))</span><br><span class="line">    <span class="comment">//：：创建函数类型对象的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sumOf</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>=a+b</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>,sum:(<span class="type">a</span>:<span class="type">Int</span>,<span class="type">b</span>:<span class="type">Int</span>)-&gt;<span class="type">Int</span>)</span></span>=sum(a,b)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://rengwuxian.com/kotlin-lambda/">康康扔物线咋说的</a></p><h4 id="匿名函数："><a href="#匿名函数：" class="headerlink" title="匿名函数："></a>匿名函数：</h4><p>匿名函数顾名思义就是没有名字的函数，那这种没有名字的函数我们怎么调用呢？答案是无法直接调用。匿名函数可以赋值给一个变量，或者当作实参直接传递给一个函数类型的形参。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fun</span><span class="params">(appleBean: <span class="type">AppleBean</span>)</span></span>: <span class="built_in">Boolean</span> = appleBean.weight &gt; <span class="number">6</span></span><br></pre></td></tr></table></figure><p>就是没有名字（</p><p>此外，匿名函数还可以赋值给变量</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> filterWeightFunPredicate =</span><br><span class="line">            <span class="function"><span class="title">fun</span><span class="params">(appleBean: <span class="type">AppleBean</span>)</span></span>: <span class="built_in">Boolean</span> = appleBean.weight</span><br></pre></td></tr></table></figure><p>差不多和lambda表达式用法一样</p><h4 id="作用域函数："><a href="#作用域函数：" class="headerlink" title="作用域函数："></a>作用域函数：</h4><p>Kotlin 的作用域函数有五种：<code>let</code>、<code>run</code>、<code>with</code>、<code>apply</code> 以及 <code>also</code>。</p><p>这些函数基本上做了同样的事情：在一个对象上执行一个代码块。</p><p>典型用法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> adam = Person(<span class="string">&quot;Adam&quot;</span>).apply &#123; </span><br><span class="line">    age = <span class="number">20</span></span><br><span class="line">    city = <span class="string">&quot;London&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">println(adam)</span><br><span class="line"><span class="comment">//------不使用apply的话</span></span><br><span class="line"><span class="keyword">val</span> adam = Person(<span class="string">&quot;Adam&quot;</span>)</span><br><span class="line">adam.age = <span class="number">20</span></span><br><span class="line">adam.city = <span class="string">&quot;London&quot;</span></span><br><span class="line">println(adam)</span><br></pre></td></tr></table></figure><p>这几种第一行代码第三版的讲的很清楚，这里只是简单提及一下</p><p><a href="https://www.kotlincn.net/docs/reference/scope-functions.html">也可以看看这个</a></p><h4 id="扩展函数："><a href="#扩展函数：" class="headerlink" title="扩展函数："></a>扩展函数：</h4><p>Kotlin的扩展函数可以让你作为一个类成员进行调用的函数，但是是定义在这个类的外部。这样可以很方便的扩展一个已经存在的类，为它添加额外的方法。</p><p>例子：</p><p>假如我们需要为String类型添加一个返回这个字符串最后一个字符的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastChar</span><span class="params">()</span></span>: <span class="built_in">Char</span> = <span class="keyword">this</span>.<span class="keyword">get</span>(<span class="keyword">this</span>.length - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Kotlin&quot;</span>.lastChar())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展函数用于安卓中，可以对String类进行扩展使得我们打toast更方便一点</p><p>也可以对view进行扩展，比如添加一个动画函数等</p><p><a href="https://www.jianshu.com/p/7291c9a1ec1e">更多内容</a></p><h3 id="lambda表达式及函数式接口"><a href="#lambda表达式及函数式接口" class="headerlink" title="lambda表达式及函数式接口"></a>lambda表达式及函数式接口</h3><h4 id="函数式（SAM）接口"><a href="#函数式（SAM）接口" class="headerlink" title="函数式（SAM）接口"></a>函数式（SAM）接口</h4><p>只有一个抽象方法的接口称为<em>函数式接口</em>或 <em>SAM（单一抽象方法）</em>接口。函数式接口可以有多个非抽象成员，但只能有一个抽象成员。</p><p>可以用 <code>fun</code> 修饰符在 Kotlin 中声明一个函数式接口。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> KRunnable &#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SAM转化"><a href="#SAM转化" class="headerlink" title="SAM转化"></a>SAM转化</h4><p>例如，假定存在函数式接口</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> IntPredicate &#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">accept</span><span class="params">(i: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用 SAM 转换，那么你需要像这样编写代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个类的实例</span></span><br><span class="line"><span class="keyword">val</span> isEven = <span class="keyword">object</span> : IntPredicate &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">accept</span><span class="params">(i: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用lambda转换后</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isEven = IntPredicate &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure><p>lambda匿名内部类实锤确信</p><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p>上文提及不少，此处不再提了，更多本文高阶函数部分</p><h2 id="Kotlin的空安全"><a href="#Kotlin的空安全" class="headerlink" title="Kotlin的空安全"></a>Kotlin的空安全</h2><h3 id><a href="#" class="headerlink" title="?"></a>?</h3><p>kotlin在默认情况下，我们创建的所有变量都是不允许为空的，必须给其指定一个值，如果给它赋值为 null，就会报错。如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str: String = <span class="literal">null</span><span class="comment">//出错，默认情况下不能为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name:String =<span class="string">&quot;tandeneck&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">assignNull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        name = <span class="literal">null</span> <span class="comment">//出错，不能赋值为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然要想他为空加个”?”就可以了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str:String ?=<span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title="?."></a>?.</h3><p>当我们要对一个对象调用方法时，需要对其进行判空处理，就可以这样干</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textView?.textSize = <span class="number">20f</span></span><br></pre></td></tr></table></figure><p>这个写法同样会对变量做一次非空确认之后再调用方法</p><h3 id="-2"><a href="#-2" class="headerlink" title="!!"></a>!!</h3><p>这个叫做非空断言，差不多意思是我肯定他是非空的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textView!!.textSize = <span class="number">20f</span></span><br></pre></td></tr></table></figure><h3 id="-3"><a href="#-3" class="headerlink" title="?:"></a>?:</h3><p>Elvis 操作符能够大大简化 if-else 表达式，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> length1: <span class="built_in">Int</span> = <span class="keyword">if</span> (b != <span class="literal">null</span>) b.length <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> length2: <span class="built_in">Int</span> = b?.length ?: <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="as"><a href="#as" class="headerlink" title="as?"></a>as?</h3><p>Kotlin 可以使用 as 关键字来进行类型转换，如果对象不是目标类型，那么类型转换可能会导致 ClassCastException。这时我们选择 as? ,如果尝试转换不成功则会返回 null：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">&quot;string&quot;</span></span><br><span class="line">    <span class="keyword">val</span> num: <span class="built_in">Int</span>? = str <span class="keyword">as</span>? <span class="built_in">Int</span></span><br><span class="line">    println(num)</span><br><span class="line">    <span class="comment">//输出 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="let"><a href="#let" class="headerlink" title="?.let{}"></a>?.let{}</h3><p>let函数除了可用于在同一个作用域下操作变量外还可以用作做判null操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;&quot;</span></span><br><span class="line">    str?.let &#123; println(it)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不是绝对的空指针安全"><a href="#不是绝对的空指针安全" class="headerlink" title="不是绝对的空指针安全"></a>不是绝对的空指针安全</h3><p>Kotlin中并不是绝对的空指针安全，最常见的就是在Kotlin去调Java代码，比如下面这个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static String getMsg() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kotlin</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(Test.getMsg().length)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>会引发空指针</p><p>可通过加”?”来解决这个问题</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test.getMsg()?.length</span><br></pre></td></tr></table></figure><p>涉及的一些原理可以看看这个-&gt;<a href="https://juejin.cn/post/6844904048987127822">更多查看</a></p><h2 id="集合和数组"><a href="#集合和数组" class="headerlink" title="集合和数组"></a>集合和数组</h2><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><p>数组在上文中简单的提及到了创建，和其他语言相同可以通过下标来进行访问，数组包含一下几种类型及创建方法</p><table><thead><tr><th>intArrayOf()整型</th></tr></thead><tbody><tr><td>longArrayOf()长整型</td></tr><tr><td>floatArrayOf()单精度</td></tr><tr><td>doubleArrayOf()双精度</td></tr><tr><td>booleanArrayOf()布尔型</td></tr></tbody></table><p>创建默认值为null的数组</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayOfNulls&lt;<span class="built_in">Int</span>&gt;(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>创建空数组</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emptyArray&lt;<span class="built_in">Int</span>&gt;()</span><br></pre></td></tr></table></figure><p>三维数组（</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arrB = Array(<span class="number">3</span>)&#123;Array(<span class="number">3</span>)&#123;IntArray(<span class="number">3</span>)&#125;&#125;</span><br></pre></td></tr></table></figure><p>可以通过下标或者set()函数来修改值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intArr[index] = <span class="number">0</span> <span class="comment">//与java一样，可以这样修改数据</span></span><br><span class="line">intArr.<span class="keyword">set</span>(index,<span class="number">1</span>) <span class="comment">//kotlin可以通过set函数进行修改数据</span></span><br></pre></td></tr></table></figure><h3 id="集合："><a href="#集合：" class="headerlink" title="集合："></a>集合：</h3><p>Kotlin的集合分类：</p><ul><li>可变集合类（Mutable）</li><li>不可变集合类（Immutable）。</li></ul><p>集合类存放的都是对象的引用，而非对象本身，我们通常说的集合中的对象指的是集合中对象的引用。集合类型主要有List(列表)，Set(集)，Map(映射)。</p><h4 id="Set："><a href="#Set：" class="headerlink" title="Set："></a>Set：</h4><table><thead><tr><th>特性：无序不重复，大小固定，元素类型不可变</th></tr></thead><tbody><tr><td>定义：Set&lt;泛型&gt;或setOf(元素1，元素2，…，元素n)</td></tr><tr><td>主要方法：交、差、并、补</td></tr></tbody></table><p>创建并输出集合内容</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> languages = setOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;Python&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (language <span class="keyword">in</span> languages) &#123;</span><br><span class="line">    println(language)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用foreach来遍历</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">languages.forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure><h4 id="Map"><a href="#Map" class="headerlink" title="Map:"></a>Map:</h4><p>只读Map。<br>可变的MutableMap(MutableMap、HashMap、LinkedHashMap)。</p><p>创建map并输出:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> map = mapOf(<span class="string">&quot;hello&quot;</span> to <span class="string">&quot;world&quot;</span>,<span class="string">&quot;1&quot;</span> to <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    println(map)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list:"></a>list:</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listOf&lt;T&gt;()<span class="comment">//创建固定元素个数的list</span></span><br><span class="line">mutableListOf&lt;T&gt;()<span class="comment">//创建可读可修改的集合</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.forEachIndexed &#123; index, value -&gt;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$index</span> <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//使用这种遍历带下标的</span></span><br><span class="line"><span class="comment">//也可以使用foreach</span></span><br></pre></td></tr></table></figure><p>增删查改更多<a href="http://www.kotlincn.net/docs/reference/collections-overview.html">参考官方文档</a></p><h2 id="协程与flow"><a href="#协程与flow" class="headerlink" title="协程与flow"></a>协程与flow</h2>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kotlin语言基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习入门《2》神经网络</title>
    <link href="/2021/10/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A2%E3%80%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/10/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A2%E3%80%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="神经网络与感知机"><a href="#神经网络与感知机" class="headerlink" title="神经网络与感知机"></a>神经网络与感知机</h3><p>神经网络与感知机有很多的共同点，但是也存在着一些差异</p><ol><li>感知机虽然拥有即使是复杂函数也有表示他的可能性，理论支撑来着数字电路三门组合能表达出复杂的电路逻辑</li><li>但是，感知机设置权值的工作需要由人工来确定。</li><li>神经网络的一个特点就是，他可以通过自动地从数据中学习到合适的权重参数</li></ol><h3 id="神经网络示意图："><a href="#神经网络示意图：" class="headerlink" title="神经网络示意图："></a>神经网络示意图：</h3><p><img src="/2021/10/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A2%E3%80%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/8uynp06sti.png"></p><p>最左边称为输入层，中间称为中间层（有时也被称为隐藏层【隐藏层的神经元肉眼无法看见】），最右边称为输出层</p><ol><li>有的书描述会将其称为3层网络，理由是构成网络的层数</li><li>有的书会将其描述为2层网络，理由是拥有权重的层数（输入层，输出层，中间层数量-1）</li></ol><h3 id="激活函数登场"><a href="#激活函数登场" class="headerlink" title="激活函数登场"></a>激活函数登场</h3><p>在感知机的y = x函数基础上进行了使用激活函数h来进行简化表示这种分情况的动作，</p><p><img src="/2021/10/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A2%E3%80%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/v2-56822c1d68fc828df3f7a498ebbb4d8b_720w.jpg"></p><p>激活函数如同抽象化的生物学上的神经元之间传输使用的某种生化信号（涉及轴突树突之间信号的传递），这里表达的就是如同我们常识所知道的那样，当化学量达到一定浓度时，神经元之间信号传递才有效，所以这里的激活函数就起到了控制这种化学传递的一个阀</p><img src="/2021/10/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A2%E3%80%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/640.png" style="zoom:67%;"><h3 id="常用的激活函数"><a href="#常用的激活函数" class="headerlink" title="常用的激活函数"></a>常用的激活函数</h3><h4 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h4><p>Sigmoid函数是一个在<a href="https://baike.baidu.com/item/%E7%94%9F%E7%89%A9%E5%AD%A6/1358">生物学</a>中常见的<a href="https://baike.baidu.com/item/S%E5%9E%8B%E5%87%BD%E6%95%B0/19178062">S型函数</a>，也称为<a href="https://baike.baidu.com/item/S%E5%9E%8B%E7%94%9F%E9%95%BF%E6%9B%B2%E7%BA%BF/5581189">S型生长曲线</a>。 [1] 在信息科学中，由于其单增以及反函数单增等性质，Sigmoid函数常被用作<a href="https://baike.baidu.com/item/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/16600562">神经网络</a>的<a href="https://baike.baidu.com/item/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/2520792">激活函数</a>，将变量映射到0,1之间。</p><p><img src="/2021/10/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A2%E3%80%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/1285295-20180727154358729-854643533.png"></p><p><img src="/2021/10/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A2%E3%80%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/d009b3de9c82d158dfb4e7218a0a19d8bc3e426f.jpg"></p><p>使用python 描述：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br></pre></td></tr></table></figure><h4 id="阶跃函数"><a href="#阶跃函数" class="headerlink" title="阶跃函数"></a>阶跃函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step_function</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.array(x &gt; <span class="number">0</span>, dtype=np.<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure><p>图片绘制：</p><img src="/2021/10/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A2%E3%80%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20211003110403947.png" alt="image-20211003110403947" style="zoom:67%;"><p>两者都是非线性函数</p><p>神经网络的激活函数必须是非线性函数，否则加深神经网络的层数将失去意义</p><h4 id="ReLU函数"><a href="#ReLU函数" class="headerlink" title="ReLU函数"></a>ReLU函数</h4><p>其在输入大于0的时候直接输出该值，在输入小于等于0时，输出0</p><p>使用python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> np.maximum(<span class="number">0</span>, x)</span><br></pre></td></tr></table></figure><h3 id="神经网络的内积"><a href="#神经网络的内积" class="headerlink" title="神经网络的内积"></a>神经网络的内积</h3><p>使用numpy矩阵来实现神经网络</p><img src="/2021/10/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A2%E3%80%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20181219152354924.png" style="zoom: 33%;"><table><thead><tr><th>X</th><th>W</th><th>Y</th></tr></thead><tbody><tr><td>2</td><td>2x3</td><td>3</td></tr></tbody></table><p>其中W为权重</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X = np.array([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">W = np.array([[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">Y = np.dot(X,W)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Y)</span><br></pre></td></tr></table></figure><p><img src="/2021/10/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A2%E3%80%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20211004203927701.png" alt="image-20211004203927701"></p><h3 id="三层神经网络的实现"><a href="#三层神经网络的实现" class="headerlink" title="三层神经网络的实现"></a>三层神经网络的实现</h3>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++求斐波拉西数列</title>
    <link href="/2021/10/02/c++%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/10/02/c++%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="使用c-模板元编程求斐波拉西数列"><a href="#使用c-模板元编程求斐波拉西数列" class="headerlink" title="使用c++模板元编程求斐波拉西数列"></a>使用c++模板元编程求斐波拉西数列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> num&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fib</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>result=fib&lt;num<span class="number">-1</span>&gt;::result+fib&lt;num<span class="number">-2</span>&gt;::result&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fib</span>&lt;</span><span class="number">0</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>result=<span class="number">1</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fib</span>&lt;</span><span class="number">1</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span>&#123;</span> result=<span class="number">1</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用constexpr-关键字求"><a href="#使用constexpr-关键字求" class="headerlink" title="使用constexpr 关键字求"></a>使用constexpr 关键字求</h3><p>constexpr  允许编程者保证函数或对象的构造函数是编译时常量</p><p>在此处时都是允许在编译期对其进行求值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">factorial_Cpp11</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">1</span> : n * <span class="built_in">factorial_Cpp11</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++14</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">factorial_Cpp14</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        result *= i;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求素数</title>
    <link href="/2021/10/02/%E6%B1%82%E7%B4%A0%E6%95%B0/"/>
    <url>/2021/10/02/%E6%B1%82%E7%B4%A0%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="求素数："><a href="#求素数：" class="headerlink" title="求素数："></a>求素数：</h2><h3 id="朴素算法求素数："><a href="#朴素算法求素数：" class="headerlink" title="朴素算法求素数："></a>朴素算法求素数：</h3><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="comment">//c++使用cmath c使用math.h</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> i,sqr = <span class="built_in">sqrt</span>((<span class="keyword">double</span>)n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=sqr; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( (n%i) == <span class="number">0</span> )</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>; i &lt; <span class="number">200</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isPrime</span>(i))</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="埃式筛选法及求素数的基本原理："><a href="#埃式筛选法及求素数的基本原理：" class="headerlink" title="埃式筛选法及求素数的基本原理："></a>埃式筛选法及求素数的基本原理：</h3><p>筛法求素数的基本思想是：把从2到N的一组<a href="https://baike.baidu.com/item/%E6%AD%A3%E6%95%B4%E6%95%B0">正整数</a>从小到大按顺序排列。从中依次删除2的倍数、3的倍数、5的倍数，直到根号N的倍数为止，剩余的即为2~N之间的所有素数</p><h4 id="使用c-来描述这一操作："><a href="#使用c-来描述这一操作：" class="headerlink" title="使用c++来描述这一操作："></a>使用c++来描述这一操作：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> range 2000</span></span><br><span class="line"><span class="keyword">bool</span> IsPrime[range + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPrime</span><span class="params">(<span class="keyword">bool</span> IsPrime[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= range; ++i)</span><br><span class="line">        IsPrime[i] = <span class="literal">true</span>;</span><br><span class="line">    IsPrime[<span class="number">0</span>] = IsPrime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= range; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IsPrime[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">2</span> * i; j &lt;= range; j += i)</span><br><span class="line">                IsPrime[j]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为<em>O</em>(<em>N<strong>l</strong>o<strong>g</strong>l<strong>o</strong>g**N</em>)</p><h3 id="欧式素数筛及其原理："><a href="#欧式素数筛及其原理：" class="headerlink" title="欧式素数筛及其原理："></a>欧式素数筛及其原理：</h3><p>在埃式基础上增加操作：每一个被筛掉的数都必须是被它的最小质因子筛掉，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>)<span class="comment">//确保是最小质因数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPrime_ou</span><span class="params">(<span class="keyword">bool</span> isPrime[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prime[range];</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= range; ++i)</span><br><span class="line">        IsPrime[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= range; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i]) prime[h++] = i;</span><br><span class="line">        <span class="keyword">for</span> (j  = <span class="number">0</span>; j &lt; h &amp;&amp; i*prime[j]&lt;=range; ++j) &#123;</span><br><span class="line">            isPrime[i*prime[j]] =<span class="literal">false</span>; <span class="comment">//筛去i的倍数</span></span><br><span class="line">            <span class="keyword">if</span> (i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//保证每个合数被他的最小质因数筛去（去重</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>求素数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习入门《1》感知机</title>
    <link href="/2021/10/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A1%E3%80%8B%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <url>/2021/10/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A1%E3%80%8B%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="感知机是什么？"><a href="#感知机是什么？" class="headerlink" title="感知机是什么？"></a>感知机是什么？</h2><p>感知机(Perceptron)在1957年由Rosenblatt提出，是神经网络和支持向量机的基础。</p><p>感知机是一种二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别，+1代表正类，-1代表负类。感知机属于判别模型，它的目标是要将输入实例通过分离超平面将正负二类分离。</p><p>简单来说就是接受多个信号来输出一个信号</p><p><img src="/2021/10/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A1%E3%80%8B%E6%84%9F%E7%9F%A5%E6%9C%BA/20160920193516651.jpg"></p><h3 id="以下内容为单层感知机的部分："><a href="#以下内容为单层感知机的部分：" class="headerlink" title="以下内容为单层感知机的部分："></a>以下内容为单层感知机的部分：</h3><p>（因为单层感知机的局限性，他只支持 与门，或门，与非门,原因是它只能由一条直线分开，曲线是无法用感知机表示的</p><p>由直线分割的为线性空间，曲线分割的为非线性空间</p><h3 id="简单逻辑电路"><a href="#简单逻辑电路" class="headerlink" title="简单逻辑电路"></a>简单逻辑电路</h3><h4 id="与门"><a href="#与门" class="headerlink" title="与门"></a>与门</h4><p>与门如果用我们常用的c来描述的话应该是指的 &amp;&amp;</p><p>对应的真值表为</p><table><thead><tr><th>A</th><th>B</th><th>Y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>下文中仍然以 0为假，1为真</p><h5 id="使用感知机实现与门："><a href="#使用感知机实现与门：" class="headerlink" title="使用感知机实现与门："></a>使用感知机实现与门：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AND</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    x = np.array([a, b])</span><br><span class="line">    w = np.array([<span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line">    b = -<span class="number">0.7</span></span><br><span class="line">    tmp = np.<span class="built_in">sum</span>(w * x) + b</span><br><span class="line">    <span class="keyword">if</span> tmp &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>其中b 为偏置，是调整神经元被激活的容易程度（输出信号为1的程度）</p><h4 id="与非门"><a href="#与非门" class="headerlink" title="与非门"></a>与非门</h4><p>简单来说就是与门的反面</p><p>对应的真值表为：</p><table><thead><tr><th>A</th><th>B</th><th>Y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><h5 id="使用感知机实现与非门："><a href="#使用感知机实现与非门：" class="headerlink" title="使用感知机实现与非门："></a>使用感知机实现与非门：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NAND</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    x = np.array([a, b])</span><br><span class="line">    w = np.array([-<span class="number">0.5</span>, -<span class="number">0.5</span>])</span><br><span class="line">    b = <span class="number">0.7</span></span><br><span class="line">    tmp = np.<span class="built_in">sum</span>(w * x) + b</span><br><span class="line">    <span class="keyword">if</span> tmp &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="或门"><a href="#或门" class="headerlink" title="或门"></a>或门</h4><p>或门用通常的c描述就是 ||操作</p><p>对应的真值表：</p><table><thead><tr><th>A</th><th>B</th><th>Y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><h5 id="使用感知机实现或门："><a href="#使用感知机实现或门：" class="headerlink" title="使用感知机实现或门："></a>使用感知机实现或门：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OR</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    x = np.array([a, b])</span><br><span class="line">    w = np.array([<span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line">    b = -<span class="number">0.2</span></span><br><span class="line">    tmp = np.<span class="built_in">sum</span>(w * x) + b</span><br><span class="line">    <span class="keyword">if</span> tmp &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="以下为多层感知机内容："><a href="#以下为多层感知机内容：" class="headerlink" title="以下为多层感知机内容："></a>以下为多层感知机内容：</h3><h4 id="异或门："><a href="#异或门：" class="headerlink" title="异或门："></a>异或门：</h4><p>又称逻辑异或电路，仅当a或b中的一方为1时，才会输出1（“异或”为拒绝其他的意思）</p><p>其真值表为：</p><table><thead><tr><th>A</th><th>B</th><th>Y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>可以通过组合与门，与非门，或门来实现异或门</p><p><img src="/2021/10/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A1%E3%80%8B%E6%84%9F%E7%9F%A5%E6%9C%BA/12472907-e997d8f579f7c831.webp"></p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th><th>Y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">XOR</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    s1 = NAND(a, b)</span><br><span class="line">    s2 = OR(a, b)</span><br><span class="line">    y = AND(s1, s2)</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感知机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp简单特性学习笔记</title>
    <link href="/2021/10/01/cpp%E7%AE%80%E5%8D%95%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/10/01/cpp%E7%AE%80%E5%8D%95%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>标签测试</p>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
