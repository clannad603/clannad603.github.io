<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>numpy多维数组运算</title>
    <link href="/2021/10/04/numpy%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BF%90%E7%AE%97/"/>
    <url>/2021/10/04/numpy%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rust输入的几种方式</title>
    <link href="/2021/10/03/rust%E8%BE%93%E5%85%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/10/03/rust%E8%BE%93%E5%85%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Rust输入数字"><a href="#Rust输入数字" class="headerlink" title="Rust输入数字"></a>Rust输入数字</h1><h2 id="一行输入一个数据"><a href="#一行输入一个数据" class="headerlink" title="一行输入一个数据"></a>一行输入一个数据</h2><p>首先我们需要先导入</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io;<br></code></pre></td></tr></table></figure><p>然后声明一个String类型的变量</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> input = <span class="hljs-built_in">String</span>::new();<br></code></pre></td></tr></table></figure><p>然后</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">io::stdin().read_line(&amp;<span class="hljs-keyword">mut</span> input)<br>           .expect(<span class="hljs-string">&quot;Failed to read line&quot;</span>);<br></code></pre></td></tr></table></figure><p>最后对类型进行处理一下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> input= input.trim().parse::&lt;<span class="hljs-built_in">i32</span>&gt;().unwrap();<br><br></code></pre></td></tr></table></figure><h2 id="一行输入多个数据"><a href="#一行输入多个数据" class="headerlink" title="一行输入多个数据"></a>一行输入多个数据</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> input=<span class="hljs-built_in">String</span>::new();<br>        io::stdin().read_line(&amp;<span class="hljs-keyword">mut</span> input).unwrap();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = input.split_whitespace();<br>        <span class="hljs-keyword">let</span> a: <span class="hljs-built_in">i32</span> = s.next().unwrap().parse().unwrap();<br>        <span class="hljs-keyword">let</span> b: <span class="hljs-built_in">i32</span> = s.next().unwrap().parse().unwrap();<br>        <span class="hljs-keyword">let</span> c: <span class="hljs-built_in">i32</span> = s.next().unwrap().parse().unwrap();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jvm</title>
    <link href="/2021/10/03/jvm/"/>
    <url>/2021/10/03/jvm/</url>
    
    <content type="html"><![CDATA[<h1 id="浅入理解Java虚拟机-雾"><a href="#浅入理解Java虚拟机-雾" class="headerlink" title="浅入理解Java虚拟机(雾"></a>浅入理解Java虚拟机(雾</h1><h2 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a>什么是JVM？</h2><p>JVM 全称为Java Virtual  Machine ,JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p><h2 id="JVM带来的好处"><a href="#JVM带来的好处" class="headerlink" title="JVM带来的好处"></a>JVM带来的好处</h2><ul><li><p>一次编写，到处运行(“Write once, run anywhere”)</p></li><li><p>自动内存管理</p></li><li><p>数组下标越界检查</p></li></ul><h2 id="常见的JVM"><a href="#常见的JVM" class="headerlink" title="常见的JVM"></a>常见的JVM</h2><img src="/2021/10/03/jvm/20200914100723848.png" style="zoom:50%;"><p>现在应该大多数的hotspot</p><h2 id="JVM-JRE-JDK的区别"><a href="#JVM-JRE-JDK的区别" class="headerlink" title="JVM JRE JDK的区别"></a>JVM JRE JDK的区别</h2><img src="/2021/10/03/jvm/525d84b7d526290a7c88900636ed1033.png" style="zoom:50%;"><h2 id="Java代码是如何被执行的"><a href="#Java代码是如何被执行的" class="headerlink" title="Java代码是如何被执行的"></a>Java代码是如何被执行的</h2><p><img src="/2021/10/03/jvm/image-20210806170716879.png" alt="image-20210806170716879"></p><p><strong>一 编写java源程序</strong></p><p><strong>二、当java源程序编码结束后，就需要编译器编译。</strong></p><p>快进到javac编译为class</p><p>快进到看字节流</p><p><img src="/2021/10/03/jvm/image-20210805083235867.png"></p><p>如果这里用cat直接看是乱码，但是在idea里面看的话，他会进行一些编写，然后成这样</p><p><img src="/2021/10/03/jvm/image-20210805083418893.png"></p><p><code>cafe babe</code> 被称为“魔数”，是 JVM 识别 .class 文件的标志。文件格式的定制者可以自由选择魔数值（只要没用过），比如说 .png 文件的魔数是 <code>8950 4e47</code>。</p><h2 id="JVM-的结构"><a href="#JVM-的结构" class="headerlink" title="JVM 的结构"></a>JVM 的结构</h2><img src="/2021/10/03/jvm/8d1de13006ae9e0dd40d5e1db98a81c81603447597022.png" style="zoom: 50%;"><p>由此图可以得知：</p><p>JVM的结构分为以下内容：类加载器（ClassLoader）、执行引擎、内存区（运行时数据区）、本地方法接口。</p><p>其中内存区包括：虚拟机栈，本地方法栈，方法区，堆，程序计数器</p><h3 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h3><p>Program Counter Register</p><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。（概念模型中：字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令）</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li><strong>线程私有</strong>：</li></ul><p>多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器</strong>，各条线程之间计数器互不影响，独立存储。</p><ul><li><strong>状态</strong>：</li></ul><p>①执行java方法，计数器记录虚拟机字节码指令的地址；②执行<strong>native方法，计数器为空（undefined）</strong></p><p>因为native方法是java通过JNI直接调用本地C/C++库，可以近似的认为native方法相当于C/C++暴露给java的一个接口，java通过调用这个接口从而调用到C/C++方法。由于该方法是通过C/C++而不是java进行实现。那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。</p><img src="https://images2018.cnblogs.com/blog/1266638/201807/1266638-20180710225811662-425101318.png" alt="img" style="zoom:67%;"><ul><li><strong>占用内存小，唯一不会OutOfMemoryError的区域</strong></li></ul><p>因为其本质上是寄存器来着</p><p><strong>接下来 简单演示一下如何查看字节码</strong></p><p>可以在 idea中安装插件jclasslib来进行查看</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>VM Stack</p><p>Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><ul><li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li><li>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存</li><li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></li></ul><p>典中典之常见虚拟机栈讲解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDemo</span> </span>&#123;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>            method1();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>            method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> c = a + b;<br>            <span class="hljs-keyword">return</span> c;<br>        &#125;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里我打算进行演示</p><h4 id="常见虚拟机栈问题"><a href="#常见虚拟机栈问题" class="headerlink" title="常见虚拟机栈问题"></a>常见虚拟机栈问题</h4><p>垃圾回收是否涉及栈内存？</p><ul><li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li></ul><p>栈内存的分配越大越好吗？</p><ul><li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li></ul><p>设置参数方法：-Xss size 通常只有几百K</p><p>决定了函数调用的深度<br>每个线程都有独立的栈空间</p><p>局部变量、参数 分配在栈上</p><p>此处进入android studio调整vm 参数的地方</p><p>ps:idea64.exe.vmoptions针对的是 IDEA 环境，对通过 IDEA 运行的 <a href="https://www.jianshu.com/p/3c330074082b">Java 项目</a>不起作用。IDEA 本身就是一个 Java 应用，所以也必须运行于 JVM 之上。此处的idea64.exe.vmoptions文件就是用来配置 64 位的 IDEA 所使用的 JVM 参数。是 IDEA 运行时用的配置，并不是项目运行的配置</p><img src="/2021/10/03/jvm/image-20210802160632576.png" style="zoom:67%;"><p>运行单个项目时可以这样</p><img src="/2021/10/03/jvm/image-20210806161449743.png" style="zoom:67%;"><p>内存溢出:</p><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p><p>发生原因：</p><ul><li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li><li>每个栈帧<strong>所占用过大</strong></li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈（Native Method Stacks）与 Java 虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的 Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java Heap</p><p>对于Java应用程序来说，Java堆是虚拟机所管理的内存的最大的一块。是被所有线程共享的一块内存区域（因为对象都是在堆里面创建的，而所有的线程都可以拿到对象的引用，所以在多线程并发过程中，对于一些对象，我们得加锁），这里稍微提一下并发和并行（下面几种垃圾回收器得用到）</p><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p><p>堆里面包含了以下内容</p><img src="https://img-blog.csdnimg.cn/20191208160358777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;"><p>在垃圾回收哪里讲讲</p><h4 id="并发-concurrency-："><a href="#并发-concurrency-：" class="headerlink" title="并发(concurrency)："></a>并发(concurrency)：</h4><p>指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p><p><img src="https://upload-images.jianshu.io/upload_images/7557373-da64ffd6d1effaac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/295/format/webp" alt="img"></p><p>简单点来说对与cpu处理并发任务就是宏观是并联的，微观是串联的</p><p>涉及时间片那些我就不说了（主要是忘记了</p><h4 id="并行-parallel-："><a href="#并行-parallel-：" class="headerlink" title="并行(parallel)："></a>并行(parallel)：</h4><p>指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</p><p><img src="https://upload-images.jianshu.io/upload_images/7557373-72912ea8e89c4007.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/313/format/webp" alt="img"></p><h4 id="出现在堆的常见异常："><a href="#出现在堆的常见异常：" class="headerlink" title="出现在堆的常见异常："></a>出现在堆的常见异常：</h4><p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p><img src="https://img-blog.csdnimg.cn/20200627192624320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5OTY1ODAw,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 67%;"><p>典中典之内存不够了</p><img src="/2021/10/03/jvm/image-20210804131002232.png" style="zoom:67%;"><h4 id="堆内存诊断工具"><a href="#堆内存诊断工具" class="headerlink" title="堆内存诊断工具:"></a>堆内存诊断工具:</h4><h5 id="jps"><a href="#jps" class="headerlink" title="jps"></a><strong>jps</strong></h5><p><img src="/2021/10/03/jvm/image-20210804102154659.png"></p><p>查看jvav运行的进程号</p><img src="/2021/10/03/jvm/image-20210804102300807.png" style="zoom:50%;"><p><strong>-q</strong> 只显示pid，不显示class名称,jar文件名和传递给main方法的参数</p><p><strong>-m</strong> 输出传递给main方法的参数，在嵌入式jvm上可能是null</p><p><strong>-l</strong> 输出应用程序main class的完整package名或者应用程序的jar文件完整路径名</p><p><strong>-v</strong> 输出传递给JVM的参数</p><p><strong>-V</strong> 隐藏输出传递给JVM的参数</p><h5 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a><strong>jmap</strong></h5><img src="/2021/10/03/jvm/image-20210804103419141.png" style="zoom:50%;"><p>   MinHeapFreeRatio     </p><ul><li><p>空闲堆空间的最小百分比，计算公式为：HeapFreeRatio =(CurrentFreeHeapSize/CurrentTotalHeapSize) * 100，值的区间为0到100，默认值为 40。如果HeapFreeRatio &lt; MinHeapFreeRatio，则需要进行堆扩容，扩容的时机应该在每次垃圾回收之后。</p><p> MaxHeapFreeRatio       </p></li><li><p>空闲堆空间的最大百分比，计算公式为：HeapFreeRatio =(CurrentFreeHeapSize/CurrentTotalHeapSize) * 100，值的区间为0到100，默认值为 70。如果HeapFreeRatio &gt; MaxHeapFreeRatio，则需要进行堆缩容，缩容的时机应该在每次垃圾回收之后。</p></li></ul><ol><li><p>   MaxHeapSize      JVM 堆空间允许的最大值。</p></li><li><p>   NewSize                  JVM 新生代堆空间的默认值。</p></li><li><p>   MaxNewSize              JVM 新生代堆空间允许的最大值。</p></li><li><p>   OldSize                  JVM 老年代堆空间的默认值。</p></li><li><p>   NewRatio                 新生代（2个Survivor区和Eden区 ）与老年代（不包括永久区）的堆空间比值</p></li><li><p>   SurvivorRatio            两个Survivor区和Eden区的堆空间比值为 他，表示 S0 ： S1 ：Eden = 1：1：？。</p></li><li><p>   MetaspaceSize           JVM 元空间的默认值。 </p></li><li><p>  MaxMetaspaceSize   JVM 元空间允许的最大值         </p></li><li><p>Compressed Class space 压缩类空间大小，Maximum size of class area in Metaspace when compressed class pointers are used（挺复杂的，而且大小不能超过32G，但是hotpot限制在了3g内，）</p></li><li><p>G1HeapRegionSize         在使用 G1 垃圾回收算法时，JVM 会将 Heap 空间分隔为若干个 Region，该参数用来指定每个 Region 空间的大小。</p></li></ol><p>Capacity = Regions * RegionSize 大小</p><p>这里先说一下这个命令遇到的一些坑</p><p>网上很多时候说使用jmap -heap pid来进行查看内存使用情况，但是这个命令对于jdk8之后的版本，不能再使用jmap -heap pid的命令了。<br>使用旧的命令会报错</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">Error: </span>-heap option used<br>Cannot connect to core dump or remote debug server. Use jhsdb jmap instead<br></code></pre></td></tr></table></figure><p>现场展示一下查看内存的步骤</p><p>jmap用法参考</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Usage:<br>    jmap [option] &lt;pid&gt;<br>        (<span class="hljs-keyword">to</span> connect <span class="hljs-keyword">to</span> running process)<br>    jmap [option] &lt;executable &lt;core&gt;<br>        (<span class="hljs-keyword">to</span> connect <span class="hljs-keyword">to</span> a core file)<br>    jmap [option] [server_id@]&lt;remote<span class="hljs-built_in"> server IP </span><span class="hljs-keyword">or</span> hostname&gt;<br>        (<span class="hljs-keyword">to</span> connect <span class="hljs-keyword">to</span> remote <span class="hljs-builtin-name">debug</span> server)<br><br>where &lt;option&gt; is one of:<br>    &lt;none&gt;               <span class="hljs-keyword">to</span> <span class="hljs-builtin-name">print</span> same <span class="hljs-builtin-name">info</span> as Solaris pmap<br>    -heap                <span class="hljs-keyword">to</span> <span class="hljs-builtin-name">print</span> java heap summary<br>    -histo[:live]        <span class="hljs-keyword">to</span> <span class="hljs-builtin-name">print</span> histogram of java object heap; <span class="hljs-keyword">if</span> the <span class="hljs-string">&quot;live&quot;</span><br>                         suboption is specified, only count live objects<br>    -permstat            <span class="hljs-keyword">to</span> <span class="hljs-builtin-name">print</span> permanent generation statistics<br>    -finalizerinfo       <span class="hljs-keyword">to</span> <span class="hljs-builtin-name">print</span> information on objects awaiting finalization<br>    -dump:&lt;dump-options&gt; <span class="hljs-keyword">to</span> dump java heap <span class="hljs-keyword">in</span> hprof binary format<br>                         dump-options:<br>                           live         dump only live objects; <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> specified,<br>                                        all objects <span class="hljs-keyword">in</span> the heap are dumped.<br>                           <span class="hljs-attribute">format</span>=b     binary format<br>                           <span class="hljs-attribute">file</span>=&lt;file&gt;  dump heap <span class="hljs-keyword">to</span> &lt;file&gt;<br>                         Example: jmap -dump:live,<span class="hljs-attribute">format</span>=b,file=heap.bin &lt;pid&gt;<br>    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; <span class="hljs-keyword">or</span> -histo<br>                         <span class="hljs-keyword">to</span> force a heap dump <span class="hljs-keyword">or</span> histogram when &lt;pid&gt; does <span class="hljs-keyword">not</span><br>                         respond. The <span class="hljs-string">&quot;live&quot;</span> suboption is <span class="hljs-keyword">not</span> supported<br>                         <span class="hljs-keyword">in</span> this mode.<br>    -h | -help           <span class="hljs-keyword">to</span> <span class="hljs-builtin-name">print</span> this help message<br>    -J&lt;flag&gt;             <span class="hljs-keyword">to</span> pass &lt;flag&gt; directly <span class="hljs-keyword">to</span> the runtime system<br></code></pre></td></tr></table></figure><p>此外需要注意一下如果一台设备上有多个jdk需要指定一下具体路径下的jvm工具（当然创建项目时使用环境中的jdk就不用</p><p>（怒 这个导致我查了好久的博客，网上讲这个错误的还比较稀少</p><h5 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a><strong>jconsole</strong></h5><p>理论上直接使用jconsole就能进入，但是可能会出一些bug</p><p>比如，我遇到的</p><img src="/2021/10/03/jvm/image-20210804114409842.png" style="zoom:50%;"><p>但是有的进程又可以链接，</p><img src="/2021/10/03/jvm/image-20210804114918627.png" style="zoom:50%;"><p>这个还可以进行远程链接</p><p>此处将进行一些常见操作将进行演示</p><h5 id="jvirsalvm"><a href="#jvirsalvm" class="headerlink" title="jvirsalvm"></a><strong>jvirsalvm</strong></h5><p>这个不太会，jump了</p><p><a href="https://www.cnblogs.com/baihuitestsoftware/articles/6405580.html">更多详情</a></p><h4 id="堆的一些参数配置"><a href="#堆的一些参数配置" class="headerlink" title="堆的一些参数配置"></a>堆的一些参数配置</h4><p>-XX:NewRatio:  设置Yong 和 Old的比例，比默认值为2，则Old Generation是 Yong Generation的2倍，即Yong Generation占据内存的1/3<br>-XX:NewSize : 设置Yong Generation的初始值大小<br>-XX:MaxNewSize：设置Yong Generation的最大值大小<br>-XX:SurviorRatio : 设置Eden和一个Suivior的比例，默认值为8，即Eden是To(S2)的比例是8，（From和To是一样大的），此时Eden占据Yong Generation的8/10<br>-XX:InitialTenuringThreshol : 设置晋升到老年代的对象年龄的最小值，默认为7<br>-XX:MaxTenuringThreshold : 设置晋升到老年代的对象年龄的最大值</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>结构：</p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png" alt="img" style="zoom:67%;"><p>由此图可以看见，在jvm 1.6和1.8有很大区别，首先是方法·区由jvm中转移到了本地内存中，StringTable也由常量池中转移到了堆里面，永久代变为了元空间（有一些报错也变了，但是鉴于我们现在使用的都是1.8以后的版本了，所以这里只会提到1.8的版本</p><p>copy一下元空间</p><h4 id="metaspace的组成"><a href="#metaspace的组成" class="headerlink" title="metaspace的组成"></a>metaspace的组成</h4><p>metaspace其实由两大部分组成</p><ul><li>Klass Metaspace</li><li>NoKlass Metaspace</li></ul><p>Klass Metaspace就是用来存klass的，klass是我们熟知的class文件在jvm里的运行时数据结构，不过有点要提的是我们看到的类似A.class其实是存在heap里的，是java.lang.Class的一个对象实例。这块内存是紧接着Heap的，和我们之前的perm一样，这块内存大小可通过<code>-XX:CompressedClassSpaceSize</code>参数来控制，这个参数前面提到了默认是1G，但是这块内存也可以没有，假如没有开启压缩指针就不会有这块内存，这种情况下klass都会存在NoKlass Metaspace里，另外如果我们把-Xmx设置大于32G的话，其实也是没有这块内存的，因为会这么大内存会关闭压缩指针开关。还有就是这块内存最多只会存在一块。</p><p>NoKlass Metaspace专门来存klass相关的其他的内容，比如method，constantPool等，这块内存是由多块内存组合起来的，所以可以认为是不连续的内存块组成的。这块内存是必须的，虽然叫做NoKlass Metaspace，但是也其实可以存klass的内容，上面已经提到了对应场景。</p><p>Klass Metaspace和NoKlass Mestaspace都是所有classloader共享的，所以类加载器们要分配内存，但是每个类加载器都有一个SpaceManager，来管理属于这个类加载的内存小块。如果Klass Metaspace用完了，那就会OOM了，不过一般情况下不会，NoKlass Mestaspace是由一块块内存慢慢组合起来的，在没有达到限制条件的情况下，会不断加长这条链，让它可以持续工作。</p><p>UseCompressedOops用来关闭类压缩</p><p>64bit的JVM出现后，OOPS的尺寸也变成了64bit，比之前的大了一倍。这会引入性能损耗——占的内存double了，并且同尺寸的CPU Cache要少存一倍的OOPS。</p><p>OOPS是指“ordinary object pointers“，就是原始指针。Java Runtime可以用这个指针直接访问指针对应的内存，做相应的操作（比如发起GC时做copy and sweep）。</p><p>从JDK6_u23开始UseCompressedOops被默认打开了。因此既能享受64bit带来的好处，又避免了64bit带来的性能损耗。当然，如果你有机会使用超过32G的堆内存，记得把这个选项关了。</p><h5 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h5><ul><li>1.8以前会导致<strong>永久代</strong>内存溢出</li><li>1.8以后会导致<strong>元空间</strong>内存溢出</li></ul><h2 id="垃圾回收-amp-amp-性能优化基础"><a href="#垃圾回收-amp-amp-性能优化基础" class="headerlink" title="垃圾回收&amp;&amp;性能优化基础"></a>垃圾回收&amp;&amp;性能优化基础</h2><h3 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收"></a>1、如何判断对象可以回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>在对象中添加一个引用计数器，每当有一个地方<br>引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可<br>能再被使用的。</p><p>引用计数算法（Reference Counting）虽然占用了一些额外的内存空间来进行计数，但<br>它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法</p><p>单纯的引用计数<br>就很难解决对象之间相互循环引用的问题。</p><p>来自深入理解Jvm虚拟机的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReferenceCountingGC</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Object instance = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] bigSize = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> * _1MB];<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGC</span><span class="hljs-params">()</span> </span>&#123;<br>        ReferenceCountingGC objA = <span class="hljs-keyword">new</span> ReferenceCountingGC();<br>        ReferenceCountingGC objB = <span class="hljs-keyword">new</span> ReferenceCountingGC();<br>        objA.instance = objB;<br>        objB.instance = objA;<br>        objA = <span class="hljs-keyword">null</span>;<br>        objB = <span class="hljs-keyword">null</span>;<br><span class="hljs-comment">// 假设在这行发生GC，objA和objB是否能被回收？</span><br>        System.gc();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        testGC();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先来看看如何设置打印日志</p><p>此处得花一点时间</p><p>看看效果</p><p><img src="/2021/10/03/jvm/image-20210804143908786.png"></p><p>此处的12M-&gt;2M意味着虚拟机并没有因为这两<br>个对象互相引用就放弃回收它们，这也从侧面说明了Java虚拟机并不是通过引用计数算法来判断对象<br>是否存活的。</p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>-XX:+PrintGC</td><td>输出简单GC日志</td></tr><tr><td>-XX:+PrintGCDetails</td><td>输出详细GC日志，并且虚拟机退出前打印堆栈使用信息</td></tr><tr><td>-XX:+PrintHeapAtGC</td><td>在每次GC前后都打印堆栈信息</td></tr><tr><td>-XX:+PrintGCTimeStamps</td><td>输出GC的时间戳（以基准时间的形式）,JVM启动后的时间偏移量。</td></tr><tr><td>-XX:+PrintGCDateStamps</td><td>输出GC的时间戳（以日期的形式，如2020-04-02T10:09:01.045+0800）</td></tr><tr><td>-Xloggc:./gc.log    日志文件的输出路径</td><td>日志文件的输出路径</td></tr><tr><td>-XX:SurvivorRatio=8</td><td>定义了年轻代中Eden区与一个Survivor区的空间比例是8:1</td></tr><tr><td>-Xmx</td><td>设定程序运行期间最大可占用的内存大小</td></tr><tr><td>-Xms</td><td>设定程序启动时占用内存大小，大一点一般启动更快</td></tr><tr><td>-Xmn</td><td>设置年轻代占用内存大小</td></tr><tr><td>-XX:MaxTenuringThreshold=N</td><td>对象年龄达到N后，下一次GC将进入老年代，可以为0</td></tr></tbody></table><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>come from 深入理解Java虚拟机</p><p>当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是<br>通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路就是通过<br>一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过<br>程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，<br>或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p><img src="/2021/10/03/jvm/image-20210804144414534.png" style="zoom:67%;"><p><strong>可以作为GC Root的对象</strong></p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul><h3 id="2-五种引用"><a href="#2-五种引用" class="headerlink" title="2.五种引用"></a>2.五种引用</h3><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png" alt="img" style="zoom:67%;"><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p><ul><li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p><ul><li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p><p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p><ul><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li></ul><h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul><li>软引用和弱引用<strong>可以配合</strong>引用队列<ul><li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li></ul></li><li>虚引用和终结器引用<strong>必须配合</strong>引用队列<ul><li>虚引用和终结器引用在使用时会关联一个引用队列</li></ul></li></ul><h3 id="3-垃圾回收算法"><a href="#3-垃圾回收算法" class="headerlink" title="3.垃圾回收算法"></a>3.垃圾回收算法</h3><p><strong>标记-清除（Mark-Sweep）</strong><br>GC分为两个阶段，标记和清除。首先标记所有可回收的对象，在标记完成后统一回收所有被标记的对象。同时会产生不连续的内存碎片。碎片过多会导致以后程序运行时需要分配较大对象时，无法找到足够的连续内存，而不得已再次触发GC。</p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png" alt="img" style="zoom:67%;"><ul><li><strong>复制（Copy）</strong><br>将内存按容量划分为两块，每次只使用其中一块。当这一块内存用完了，就将存活的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。这样使得每次都是对半个内存区回收，也不用考虑内存碎片问题，简单高效。缺点需要两倍的内存空间。<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png" alt="img" style="zoom:67%;"></li></ul><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png" alt="img" style="zoom:67%;"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png" alt="img" style="zoom:67%;"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png" alt="img" style="zoom:67%;"><ul><li><strong>标记-整理（Mark-Compact）</strong><br>也分为两个阶段，首先标记可回收的对象，再将存活的对象都向一端移动，然后清理掉边界以外的内存。此方法避免标记-清除算法的碎片问题，同时也避免了复制算法的空间问题。<br>一般年轻代中执行GC后，会有少量的对象存活，就会选用复制算法，只要付出少量的存活对象复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外过多内存空间分配，就需要使用标记-清理或者标记-整理算法来进行回收。</li></ul><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png" alt="img" style="zoom:67%;"><h3 id="4-分代回收"><a href="#4-分代回收" class="headerlink" title="4.分代回收"></a>4.分代回收</h3><p>将堆内存分为两个部分，一部分名为新生代，一部分名为老年代</p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png" alt="img" style="zoom:67%;"><p>其中新生代分为了伊甸园，幸存区from，幸存区to。</p><p>首先，new出来的对象在伊甸园进行创建</p><p>当伊甸园的内存不足是，就会进行垃圾回收，此时叫做minor GC,</p><ul><li>Minor GC会将伊甸园和幸存区FROM存活对象复制到幸存区TO中，使得其寿命加一(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)，在交换两个幸存区</li></ul><p>不管怎样，都会保证名为To的幸存区是空的，Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p><ul><li>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</li><li>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></li><li>再次创建对象，若新生代的伊甸园又满了，则会再次触发 Minor GC（会触发 stop the world， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，还会回收幸存区中的垃圾，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象寿命加1</li></ul><h4 id="有关新生代的JVM参数"><a href="#有关新生代的JVM参数" class="headerlink" title="有关新生代的JVM参数"></a><strong>有关新生代的JVM参数</strong></h4><p>1)-XX:NewSize和-XX:MaxNewSize</p><p>用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。</p><p>2)-XX:SurvivorRatio</p><p>用于设置Eden和其中一个Survivor的比值，这个值也比较重要。</p><p>3)-XX:+PrintTenuringDistribution</p><p>这个参数用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。</p><p>4).-XX:InitialTenuringThreshol和-XX:MaxTenuringThreshold</p><p>用于设置晋升到老年代的对象年龄的最小值和最大值，每个对象在坚持过一次Minor GC之后，年龄就加1。</p><p>康康jstart输出</p><p><img src="/2021/10/03/jvm/image-20210805074443338.png"></p><p>其中各参数代表</p><ul><li>S0，S1，两个survivor区域，可以看到它们的使用率为0</li><li>E，代表eden，这是年轻代用于分配新的对象的区域。</li><li>O，代表老年代，这是我们今天要重点讲的内容。</li><li>M，代表metaspace，这块内容以后再讲（也有可能永远不再讲了，看情况）</li><li>CCS，压缩使用比例。可以先不管这个。这个和使用压缩指针有关系。可以使用-XX:-UseCompressedOops关掉压缩的功能，这一项就不再打印了。</li><li>YGC，年轻代回收的次数。</li><li>YGCT，年轻代回收所使用的时间。由于年轻代的回收使用copy GC。会让所有Java线程都停顿下来，所以这一项就是指用于年轻代回收的时间。</li><li>FGC，这一项就比较复杂了。在不同的GC组合中代表不同的意义，后面会详细讲到。</li><li>FGCT，与上面的FGC一定样的，字面意思是full gc time，但在不同的GC选项下，意义有所不同。</li><li>GCT，一般来说，等于YGCT与FGCT之和。</li></ul><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><ul><li><p><strong>串行收集器（Serial）</strong><br>比较老的收集器，单线程。收集时，必须暂停应用的工作线程，直到收集结束。</p></li><li><p><strong>并行收集器（Parallel）</strong><br>多条垃圾收集线程并行工作，在多核CPU下效率更高，应用线程仍然处于等待状态。</p></li><li><p>CMS收集器（Concurrent Mark Sweep）</p><p>CMS收集器是缩短暂停应用时间为目标而设计的，是基于标记-清除算法实现，整个过程分为4个步骤，包括：</p><ul><li>初始标记（Initial Mark）</li><li>并发标记（Concurrent Mark）</li><li>重新标记（Remark）</li><li>并发清除（Concurrent Sweep）</li></ul><p>单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</p></li></ul><p>​        <strong>JDK1.8默认使用</strong>的垃圾回收器</p><ul><li>G1</li></ul><p>​           Garbage First</p><p>​            JDK 9以后默认使用，而且替代了CMS 收集器</p><p>​      G1的特点</p><ul><li>G1不再坚持固定大小以及固定数量的<br>分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的<br>Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的<br>旧对象都能获取很好的收集效果</li></ul><img src="https://tse1-mm.cn.bing.net/th/id/R-C.d6e8f8b74e546354d6cc594269f88487?rik=BezOq%2fgcDZHlWw&riu=http%3a%2f%2fupload-images.jianshu.io%2fupload_images%2f2184951-256a9ccb6e51be85.png&ehk=6aQFuTMvcG2m353MYMeVw4gN4PZ0p1xl%2bkzX5pUOPEk%3d&risl=&pid=ImgRaw&r=0" alt="查看源图像" style="zoom: 50%;"><p>G1：分为了四个执行步骤：</p><img src="/2021/10/03/jvm/image.2BEI70.png" style="zoom: 67%;"><ul><li>初始标记，</li><li>并发标记，</li><li>最终标记，</li><li>筛选回收</li></ul><p>初始标记，标记一下GC Roots能直接关联到的对象。并发标记从GC Root开始标记存活对象，这个阶段耗时比较长，但也可以与应用线程并发执行。而最终标记也是为了修正在并发标记期间因用户程序继续运作而导致标记产生变化的那一部分标记记录。最后在筛选回收阶段对各个Region回收价值和成本进行排序，根据用户所期望的GC暂停时间来执行回收。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-XX:+UseSerialGC</td><td align="left">串行收集器</td></tr><tr><td align="left">-XX:+UseParallelGC</td><td align="left">并行收集器</td></tr><tr><td align="left">-XX:+UseParallelGCThreads=8</td><td align="left">并行收集器线程数，同时有多少个线程进行垃圾回收，一般与CPU数量相等</td></tr><tr><td align="left">-XX:+UseParallelOldGC</td><td align="left">指定老年代为并行收集</td></tr><tr><td align="left">-XX:+UseConcMarkSweepGC</td><td align="left">CMS收集器（并发收集器）</td></tr><tr><td align="left">-XX:+UseCMSCompactAtFullCollection</td><td align="left">开启内存空间压缩和整理，防止过多内存碎片</td></tr><tr><td align="left">-XX:CMSFullGCsBeforeCompaction=0</td><td align="left">表示多少次Full GC后开始压缩和整理，0表示每次Full GC后立即执行压缩和整理</td></tr><tr><td align="left">-XX:CMSInitiatingOccupancyFraction=80%</td><td align="left">表示老年代内存空间使用80%时开始执行CMS收集，防止过多的Full GC</td></tr><tr><td align="left">-XX:+UseG1GC</td><td align="left">G1收集器</td></tr><tr><td align="left">-XX:MaxTenuringThreshold=0</td><td align="left">在年轻代经过几次GC后还存活，就进入老年代，0表示直接进入老年代</td></tr></tbody></table><ul><li>选择高效的GC算法，可有效减少停止应用线程时间。</li><li>频繁Full GC会增加暂停时间和CPU使用率，可以加大老年代空间大小降低Full GC，但会增加回收时间，根据业务适当取舍。</li></ul><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>类从被加载到虚拟机内存到被卸载，整个完整的生命周期包括：类加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证，准备，解析三个部分统称为连接。接下来我们可以详细了解下类加载的各个过程。</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3279460766e7484dbee19e086739d0f0~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.awebp" alt="img" style="zoom:33%;"><p>这里还是快进到看《深入理解Java虚拟机》把</p><p>虽然classloader的加载过程有复杂的5步，但事实上除了加载之外的四步，其它都是由JVM虚拟机控制的，我们除了适应它的规范进行开发外，能够干预的空间并不多。而加载则是我们控制classloader实现特殊目的最重要的手段了。</p><p>双亲委托机制</p><p>这个东西和事件分发有点相反，事件分发是先往下推，在往上推，而类加载机制是先往上推，没人推了，在执行</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e6b8ee8c76847ed85f25d2624c35985~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.awebp" alt="img" style="zoom: 33%;"><p>双亲委派模型能够保证同一个类最终会被特定的类加载器加载。</p><p>例如类java.lang.Object,它存放在rt.jart之中.无论哪一个类加载器都要加载这个类.最终都是双亲委派模型最顶端的Bootstrap类加载器去加载.因此Object类在程序的各种类加载器环境中都是同一个类.相反.如果没有使用双亲委派模型.由各个类加载器自行去加载的话.如果用户编写了一个称为“java.lang.Object”的类.并存放在程序的ClassPath中.那系统中将会出现多个不同的Object类.java类型体系中最基础的行为也就无法保证.应用程序也将会一片混乱.</p><p>类加载器：</p><ul><li><p>启动类加载器(Bootstrap Classloader)负责将<JAVA_HOME>/lib目录下并且被虚拟机识别的类库加载到虚拟机内存中。我们常用基础库，例如java.util.**，java.io.**，java.lang.**等等都是由根加载器加载。</JAVA_HOME></p><p>由C++写的,由JVM启动</p></li><li><p>扩展类加载器(Extention Classloader)负责加载JVM扩展类，比如swing系列、内置的js引擎、xml解析器等，这些类库以javax开头，它们的jar包位于<JAVA_HOME>/lib/ext目录中。</JAVA_HOME></p></li><li><p>应用程序加载器(Application Classloader)也叫系统类加载器，它负责加载用户路径(ClassPath)上所指定的类库。我们自己编写的代码以及使用的第三方的jar包都是由它来加载的。</p></li><li><p>自定义加载器(Custom Classloader)通常是我们为了某些特殊目的实现的自定义加载器，</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kotlin</title>
    <link href="/2021/10/03/kotlin/"/>
    <url>/2021/10/03/kotlin/</url>
    
    <content type="html"><![CDATA[<h1 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h1><h2 id="kotlin是什么？"><a href="#kotlin是什么？" class="headerlink" title="kotlin是什么？"></a>kotlin是什么？</h2><p>Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift（确实长的很像），由 JetBrains 设计开发并开源。</p><p>Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。</p><p>在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。</p><h2 id="Kotlin好处都有啥？"><a href="#Kotlin好处都有啥？" class="headerlink" title="Kotlin好处都有啥？"></a>Kotlin好处都有啥？</h2><p>作为现代语言，kotlin具有高效的特点，具有严格的“防空思想”，也是一门能让人甜到齁的语言，有接管java的意图，借助安卓走向全平台，spring走向后端，ksl用来操作gradle,基于jvm也使它具有很好的跨平台性，并且拥有很多其他语言的优越地方，比如协程等</p><h2 id="Kotlin的一些基础语法"><a href="#Kotlin的一些基础语法" class="headerlink" title="Kotlin的一些基础语法"></a>Kotlin的一些基础语法</h2><h3 id="基本数据类型及简单操作"><a href="#基本数据类型及简单操作" class="headerlink" title="基本数据类型及简单操作"></a>基本数据类型及简单操作</h3><table><thead><tr><th>类型</th><th>位宽度</th></tr></thead><tbody><tr><td>Double</td><td>64</td></tr><tr><td>Float</td><td>32</td></tr><tr><td>Long</td><td>64</td></tr><tr><td>Int</td><td>32</td></tr><tr><td>Short</td><td>16</td></tr><tr><td>Byte</td><td>8</td></tr></tbody></table><h4 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h4><p>eg:</p><table><thead><tr><th>十进制：123</th></tr></thead><tbody><tr><td>长整型以大写的 L 结尾：123L</td></tr><tr><td>16 进制以 0x 开头：0x0F</td></tr><tr><td>2 进制以 0b 开头：0b00001011</td></tr><tr><td>注意：8进制不支持</td></tr><tr><td>Doubles 默认写法: 123.5, 123.5e10</td></tr><tr><td>Floats 使用 f 或者 F 后缀：123.5f</td></tr></tbody></table><h4 id="通用类型转化"><a href="#通用类型转化" class="headerlink" title="通用类型转化"></a>通用类型转化</h4><table><thead><tr><th>toByte(): Byte</th></tr></thead><tbody><tr><td>toShort(): Short</td></tr><tr><td>toInt(): Int</td></tr><tr><td>toLong(): Long</td></tr><tr><td>toFloat(): Float</td></tr><tr><td>toDouble(): Double</td></tr><tr><td>toChar(): Char</td></tr></tbody></table><h4 id="位操作符（这个感觉用的少"><a href="#位操作符（这个感觉用的少" class="headerlink" title="位操作符（这个感觉用的少"></a>位操作符（这个感觉用的少</h4><table><thead><tr><th>shl(bits) – 左移位 (Java’s &lt;&lt;)</th></tr></thead><tbody><tr><td>shr(bits) – 右移位 (Java’s &gt;&gt;)</td></tr><tr><td>ushr(bits) – 无符号右移位 (Java’s &gt;&gt;&gt;)</td></tr><tr><td>and(bits) – 与</td></tr><tr><td>or(bits) – 或</td></tr><tr><td>xor(bits) – 异或</td></tr><tr><td>inv() – 反向</td></tr></tbody></table><h4 id="字符串，布尔，字符，数组"><a href="#字符串，布尔，字符，数组" class="headerlink" title="字符串，布尔，字符，数组"></a>字符串，布尔，字符，数组</h4><p>字符不可当作数字操作，</p><p>布尔操作与java相同（||,!,&amp;&amp;)，</p><p>数组通过内置的Array类实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a = arrayOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">val</span> b = Array(<span class="hljs-number">3</span>, &#123; i -&gt; (i * <span class="hljs-number">2</span>) &#125;)<br><span class="hljs-comment">//有点python列表表达式的感觉</span><br></code></pre></td></tr></table></figure><p>字符串可以通过trimMargin()来去掉多余空白</p><p>可以通过”$”来将变量整进字符串中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">val</span> s = <span class="hljs-string">&quot;1 = <span class="hljs-variable">$a</span>&quot;</span><br></code></pre></td></tr></table></figure><h2 id="包の导入"><a href="#包の导入" class="headerlink" title="包の导入"></a>包の导入</h2><h5 id="kotlin使用import-来导入包，导入方式与python相似"><a href="#kotlin使用import-来导入包，导入方式与python相似" class="headerlink" title="kotlin使用import 来导入包，导入方式与python相似"></a>kotlin使用import 来导入包，导入方式与python相似</h5><p>eg:</p><table><thead><tr><th>import org.example.Message                                                       // 现在 Message 可以不用限定符访问</th></tr></thead><tbody><tr><td>import org.example.* // “org.example”中的一切都可访问</td></tr><tr><td>import org.example.Message // Message 可访问<br>import org.test.Message as testMessage                                             // testMessage 代表“org.test.Message”</td></tr></tbody></table><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a>if 表达式</h3><p>在kotlin中 if表达式有返回值，因此与传统语言相比，带来了不少便捷</p><p>比如在java中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> max ;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> d = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">if</span> (b&gt;d) &#123;<br>    max  = b;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    max = d;<br>&#125;<br></code></pre></td></tr></table></figure><p>而在kotlin中，我们可以这样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> max = <span class="hljs-keyword">if</span>(a&gt;b) a <span class="hljs-keyword">else</span> b<br></code></pre></td></tr></table></figure><p>并且代码块的最后一个语句将作为返回值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> max = <span class="hljs-keyword">if</span> (a &gt; b) &#123;<br>    print(<span class="hljs-string">&quot;a&quot;</span>)<br>    a<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    print(<span class="hljs-string">&quot;b&quot;</span>)<br>    b<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="when表达式"><a href="#when表达式" class="headerlink" title="when表达式"></a>when表达式</h3><p>kotlin取消掉了switch case语法结构，使用了when来实现了相应功能</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">when</span> (x) &#123;<br>    <span class="hljs-number">1</span> -&gt; print(<span class="hljs-string">&quot;x == 1&quot;</span>)<br>    <span class="hljs-number">2</span> -&gt; print(<span class="hljs-string">&quot;x == 2&quot;</span>)<br>    <span class="hljs-keyword">else</span> -&gt; &#123; <span class="hljs-comment">// 注意这个块</span><br>        print(<span class="hljs-string">&quot;x is neither 1 nor 2&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>并且，可对多个目标进行匹配，如:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">when</span> (x) &#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span> -&gt; print(<span class="hljs-string">&quot;x == 0 or x == 1&quot;</span>)<br>    <span class="hljs-keyword">else</span> -&gt; print(<span class="hljs-string">&quot;otherwise&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>when语句将对 “()” 里面的内容进行匹配，此内容作为主语，在代码块中可对此进行匹配操作(不限制与常量)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">when</span> (x) &#123;<br>    <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span> -&gt; print(<span class="hljs-string">&quot;x is in the range&quot;</span>)<br>    <span class="hljs-keyword">is</span> String -&gt; print(<span class="hljs-string">&quot;x is String&quot;</span>)<span class="hljs-comment">//类型匹配</span><br>    <span class="hljs-keyword">else</span> -&gt; print(<span class="hljs-string">&quot;none of the above&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>当when未加主语时，可类似用做if else 语句</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">when</span> &#123;<br>    x.isOdd() -&gt; print(<span class="hljs-string">&quot;x is odd&quot;</span>)<br>    y.isEven() -&gt; print(<span class="hljs-string">&quot;y is even&quot;</span>)<br>    <span class="hljs-keyword">else</span> -&gt; print(<span class="hljs-string">&quot;x+y is odd.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>kotlin中for循环可以对任何提供迭代器（iterator）的对象进行遍历，例如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span> (item <span class="hljs-keyword">in</span> collection) print(item)<br></code></pre></td></tr></table></figure><p>循环体同样也适用于代码块</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span>(item :<span class="hljs-built_in">Int</span> <span class="hljs-keyword">in</span> collection)&#123;<br>    <span class="hljs-keyword">val</span> temp = <span class="hljs-number">1</span><br>    print(item+temp)<br>&#125;<br></code></pre></td></tr></table></figure><p>对数字区间的迭代</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>    println(i)<br>&#125;<br><span class="hljs-comment">//从1到3</span><br><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">6</span> downTo <span class="hljs-number">0</span> step <span class="hljs-number">2</span>) &#123;<br>    println(i)<br>&#125;<br><span class="hljs-comment">//从6到0以2为步长</span><br></code></pre></td></tr></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>kotlin的while循环与c等类似拥有while与do while</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>    x--<br>&#125;<br><span class="hljs-comment">//-----------</span><br><span class="hljs-keyword">var</span> x =<span class="hljs-number">10</span><br><span class="hljs-keyword">do</span> &#123;<br>  x--<br>&#125; <span class="hljs-keyword">while</span> (x !=<span class="hljs-number">0</span>) <br></code></pre></td></tr></table></figure><p>break与continue仍然适用</p><h3 id="返回与跳转"><a href="#返回与跳转" class="headerlink" title="返回与跳转"></a>返回与跳转</h3><h4 id="结构化跳转表达式及标签"><a href="#结构化跳转表达式及标签" class="headerlink" title="结构化跳转表达式及标签"></a>结构化跳转表达式及标签</h4><p>kotlin有三种结构化跳转表达式：</p><table><thead><tr><th>return。默认从最直接包围它的函数或者匿名函数返回。</th></tr></thead><tbody><tr><td>break。终止最直接包围它的循环</td></tr><tr><td>continue。继续下一次最直接包围它的循环。</td></tr></tbody></table><p>此外，这三种表达式都可以使用标签来进行标记，标签格式为<em>abc@</em></p><p>eg:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-symbol">loop@</span> <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.100</span>) &#123;<br>    <span class="hljs-keyword">for</span> (j <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.100</span>) &#123;<br>        <span class="hljs-keyword">if</span> (i+j==<span class="hljs-number">100</span>&amp;&amp;<span class="hljs-number">2</span>*i+3j==<span class="hljs-number">100</span>)&#123;<br>             <span class="hljs-keyword">break</span><span class="hljs-symbol">@loop</span><br>        &#125;       <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>标签限制的 break 跳转到刚好位于该标签指定的循环后面的执行点。 <em>continue</em> 继续标签指定的循环的下一次迭代。</strong></p><h4 id="标签的常用操作"><a href="#标签的常用操作" class="headerlink" title="标签的常用操作"></a>标签的常用操作</h4><p>由于kotlin函数可以嵌套，因此我们在处理一些跳转时，比如从匿名函数中退出</p><p>假如是这样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).forEach &#123;<br>        <span class="hljs-keyword">if</span> (it == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span><span class="hljs-comment">// 非局部直接返回到 foo() 的调用者</span><br>        print(it)<br>    &#125;<br>    print(<span class="hljs-string">&quot;end of all&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>由于return 将退出函数，因此它将会退出整个函数</p><p>所以我们可以使用匿名函数来解决这个问题</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).forEach(<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(it: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (it == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span><span class="hljs-comment">// 局部返回到匿名函数的调用者，即 forEach 循环</span><br>        print(it)<br>    &#125;)<br>    print(<span class="hljs-string">&quot;end of all&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>但也可以使用标签来处理</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).forEach <span class="hljs-symbol">lit@</span>&#123;<br>        <span class="hljs-keyword">if</span> (it == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span><span class="hljs-symbol">@lit</span> <span class="hljs-comment">// 局部返回到该 lambda 表达式的调用者，即 forEach 循环</span><br>        print(it)<br>    &#125;<br>    print(<span class="hljs-string">&quot;end of all&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>标签也可以返回值到指定位置</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">return</span><span class="hljs-symbol">@a</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>他将返回1到”@a”</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类的基本"><a href="#类的基本" class="headerlink" title="类的基本"></a>类的基本</h3><p>kotlin使用class来声明类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>()&#123;<br>    .....<br>&#125;<br><span class="hljs-comment">//若无实体还可以这样写</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br></code></pre></td></tr></table></figure><p>kotlin的类构造器分为主构造器和多个次构造器</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">constructor</span></span>(name:String)&#123;<br>    .....<br>&#125;<br></code></pre></td></tr></table></figure><p>若无需为添加注释或修饰符，可以省略</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>(name:String)&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>主构造函数不能包含任何的代码，初始化工作可以放在init的代码块中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>(name:String)&#123;<br>    <span class="hljs-keyword">var</span> nameUpper :String =<span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">init</span> &#123;<br>        nameUpper = name.uppercase()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>声明或初始化属性还可以这么写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">val</span> name:String)&#123;<br>    ....<br>&#125;<br></code></pre></td></tr></table></figure><p>类也可以声明前缀有constructor的次构造函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span></span>&#123;<br>    <span class="hljs-keyword">var</span> nameUpper :String =<span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">constructor</span>(name:String)&#123;<br>        nameUpper=name.uppercase()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>init代码块部分会成主构造函数的一部分，将在次构造函数前执行</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Constructors</span> </span>&#123;<br>    <span class="hljs-keyword">init</span> &#123;<br>        println(<span class="hljs-string">&quot;Init block&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">constructor</span>(i: <span class="hljs-built_in">Int</span>) &#123;<br>        println(<span class="hljs-string">&quot;Constructor&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>未声明构造函数时，他将隐式的生成且可见性是public因此我们可以把他private掉</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GirlFriend</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>()&#123;<br>    .....<br>&#125;<br></code></pre></td></tr></table></figure><p>主构造函数可以设置默认值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>(<span class="hljs-keyword">val</span> specices :String =<span class="hljs-string">&quot;human being&quot;</span>)<br></code></pre></td></tr></table></figure><p>kotlin中无<code>new</code>关键字</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>kotlin的所有类拥有一个共同的超类Any </p><p><code>Any</code> 有三个方法：<code>equals()</code>、 <code>hashCode()</code> 与 <code>toString()</code>。因此，为所有 Kotlin 类都定义了这些方法。</p><p>默认情况下kotlin的类是<code>final</code>的，因此不可被继承，若要使他能被继承，则需要添加<code>open</code>关键字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(name:String)<br></code></pre></td></tr></table></figure><p>若需要继承此类，则可这样表达</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chinese</span> </span>(name:String):Person(name)<br></code></pre></td></tr></table></figure><p>对于继承后的属性，以下面的这个例子来说</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>(name:String)&#123;<br>    <span class="hljs-keyword">open</span> <span class="hljs-keyword">var</span> nameUpper :String =<span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">open</span> <span class="hljs-keyword">var</span> age:<span class="hljs-built_in">Int</span>=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">init</span> &#123;<br>        nameUpper = name.uppercase()<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span>:<span class="hljs-type">Person&#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> nameUpper :String =<span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> age:<span class="hljs-built_in">Int</span>=<span class="hljs-number">2</span><br>    <span class="hljs-keyword">constructor</span>(name:String):<span class="hljs-keyword">super</span>(name)&#123;<br>        nameUpper=name.uppercase()<br>    &#125;<br>    <span class="hljs-comment">//次构造函数可以写多个继承不同属性</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于父类需要被覆盖属性，需要声明为<code>open</code>,然后在子类中添加<code>override</code>来进行标记，若此子类的属性不希望被覆盖掉，则可以添加<code>final</code>关键字，例如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> age:<span class="hljs-built_in">Int</span> = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>方法也是同样的</p><p>若我们希望子类调用父类的方法，则可以使用<code>super</code>关键字来进行调用，</p><p>[^使用super<T>来调用具体的属性或方法]: </T></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Fruit</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;this fruit is being ate&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Orange</span></span>&#123;<br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;this orange is being ate&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lemon</span>: <span class="hljs-type">Fruit</span>,<span class="hljs-type">Orange</span></span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>&lt;Fruit&gt;.eat()<br>        <span class="hljs-keyword">super</span>&lt;Orange&gt;.eat()<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="伴生对象companion-object"><a href="#伴生对象companion-object" class="headerlink" title="伴生对象companion object"></a>伴生对象companion object</h3><p><code>companion object</code> 修饰为伴生对象,伴生对象在类中只能存在一个，类似于java中的静态方法 Java 中使用类访问静态成员，静态方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> TAG = <span class="hljs-string">&quot;DemoManager&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span> &#123;<br>        Log.e(TAG,<span class="hljs-string">&quot;此时 companion objec t表示 伴生对象&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此<code>companion object</code>中调用不到外部成员变量（静态方法无法调用非静态成员变量）</p><h3 id="Kotlin中的各种类"><a href="#Kotlin中的各种类" class="headerlink" title="Kotlin中的各种类"></a>Kotlin中的各种类</h3><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类使用<code>abstract</code>来标记抽象类</p><p>类以及其中的某些成员可以声明为 <em>abstract</em>。 抽象成员在本类中可以不用实现</p><p>使用抽象类来覆盖一个非抽象的开放成员</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Polygon</span> </span>&#123;<br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> : <span class="hljs-type">Polygon</span></span>() &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h4><p>kotlin使用<code>data</code>来标记数据类，在java16(最新的jvav16中使用了<code>record</code>关键字来实现了此功能)前，我们实现数据类功能可能需要这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        Person person = (Person) o;<br>        <span class="hljs-keyword">return</span> age == person.age &amp;&amp;<br>                Objects.equals(name, person.name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">return</span> Objects.hash(name, age);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>而使用kotlin数据类，可以这样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">var</span> name :String, <span class="hljs-keyword">var</span> age :<span class="hljs-built_in">Int</span>)<br></code></pre></td></tr></table></figure><h5 id="数据类自带解构方法——componentN"><a href="#数据类自带解构方法——componentN" class="headerlink" title="数据类自带解构方法——componentN()"></a>数据类自带解构方法——componentN()</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> (name,age) = p  <span class="hljs-comment">//解构p</span><br>println(<span class="hljs-string">&quot;<span class="hljs-variable">$name</span> <span class="hljs-variable">$age</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h5 id="数据类的copy函数"><a href="#数据类的copy函数" class="headerlink" title="数据类的copy函数"></a>数据类的copy函数</h5><p>数据类使用copy函数来对数据类进行复制，并且可对其属性进行修改</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> jack = User(name = <span class="hljs-string">&quot;Jack&quot;</span>, age = <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">val</span> olderJack = jack.copy(age = <span class="hljs-number">2</span>)<br>    println(jack)<br>    println(olderJack)<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h4><p>kotlin中可以使用object来声明单例类</p><p>java中可以这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleSington</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SimpleSington INSTANCE;<br> <br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SimpleSington</span><span class="hljs-params">()</span> </span>&#123;<br>      INSTANCE = (SimpleSington)<span class="hljs-keyword">this</span>;<br>   &#125;<br> <br>   <span class="hljs-keyword">static</span> &#123;<br>      <span class="hljs-keyword">new</span> SimpleSington();<br>   &#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>在kotlin中可以这么写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> SimpleSington &#123;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>kotlin中使用<code>enum</code>关键字来标记一个枚举类</p><p>枚举类最基本的用法是实现一个类型安全的枚举。</p><p>枚举常量用逗号分隔,每个枚举常量都是一个对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span></span>&#123;<br>    RED,BLACK,BLUE,GREEN,WHITE<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举类可以进行初始化，默认值从0开始，需要指定值，则可以对其使用构造函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span></span>(value:<span class="hljs-built_in">Int</span>)&#123;<br>    ovel(<span class="hljs-number">100</span>),<br>    rectangle(<span class="hljs-number">200</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h4><p>kotlin中使用sealed来标记一个密封类</p><p>密封类用来表示受限的类继承结构：当一个值为有限几种的类型, 而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合 也是受限的，但每个枚举常量只存在一个实例，而密封类 的一个子类可以有可包含状态的多个实例。</p><p>声明一个密封类，使用 <strong>sealed</strong> 修饰类，密封类可以有子类，但是所有子类都必须在与密封类自身相同的文件中声明。（在 Kotlin 1.1 之前， 该规则更加严格：子类必须嵌套在密封类声明的内部）。</p><p>密封类的常用操作：</p><p>配合when来使用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Expr</span></span><br><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Const</span></span>(<span class="hljs-keyword">val</span> number: <span class="hljs-built_in">Double</span>) : Expr()<br><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sum</span></span>(<span class="hljs-keyword">val</span> e1: Expr, <span class="hljs-keyword">val</span> e2: Expr) : Expr()<br><span class="hljs-keyword">object</span> NotANumber : Expr()<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eval</span><span class="hljs-params">(expr: <span class="hljs-type">Expr</span>)</span></span>: <span class="hljs-built_in">Double</span> = <span class="hljs-keyword">when</span> (expr) &#123;<br>    <span class="hljs-keyword">is</span> Const -&gt; expr.number<br>    <span class="hljs-keyword">is</span> Sum -&gt; eval(expr.e1) + eval(expr.e2)<br>    NotANumber -&gt; <span class="hljs-built_in">Double</span>.NaN<br>&#125;<br></code></pre></td></tr></table></figure><p>更像是一种枚举类的扩展</p><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>kotlin中委托分为了属性委托和类委托两种</p><h4 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h4><p>属性委托指的是一个类的某个属性值不是在类中直接进行定义，而是将其托付给一个代理类，从而实现对该类的属性统一管理。</p><p>属性委托语法格式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span>/<span class="hljs-keyword">var</span> &lt;属性名&gt;: &lt;类型&gt; <span class="hljs-keyword">by</span> &lt;表达式&gt;<br></code></pre></td></tr></table></figure><table><thead><tr><th>var/val：属性类型(可变/只读)</th></tr></thead><tbody><tr><td>属性名：属性名称</td></tr><tr><td>类型：属性的数据类型</td></tr><tr><td>表达式：委托代理类</td></tr></tbody></table><p>by 关键字之后的表达式就是委托, 属性的 get() 方法(以及set() 方法)将被委托给这个对象的 getValue() 和 setValue() 方法。属性委托不必实现任何接口, 但必须提供 getValue() 函数(对于 var属性,还需要 setValue() 函数)。</p><p>eg:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> kotlin.reflect.KProperty<br><span class="hljs-comment">// 定义包含属性委托的类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> p: String <span class="hljs-keyword">by</span> Delegate()<br>&#125;<br><br><span class="hljs-comment">// 委托的类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Delegate</span> </span>&#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-variable">$thisRef</span>, 这里委托了 <span class="hljs-subst">$&#123;property.name&#125;</span> 属性&quot;</span><br>    &#125;<br><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">String</span>)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$thisRef</span> 的 <span class="hljs-subst">$&#123;property.name&#125;</span> 属性赋值为 <span class="hljs-variable">$value</span>&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> e = Example()<br>    println(e.p)     <span class="hljs-comment">// 访问该属性，调用 getValue() 函数</span><br><br>    e.p = <span class="hljs-string">&quot;Runoob&quot;</span>   <span class="hljs-comment">// 调用 setValue() 函数</span><br>    println(e.p)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h4><p>类的委托即一个类中定义的方法实际是调用另一个类的对象的方法来实现的。</p><p>以下实例中派生类 Derived 继承了接口 Base 所有方法，并且委托一个传入的 Base 类的对象来执行这些方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 创建接口</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Base</span> </span>&#123;   <br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-comment">// 实现此接口的被委托的类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseImpl</span></span>(<span class="hljs-keyword">val</span> x: <span class="hljs-built_in">Int</span>) : Base &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span> &#123; print(x) &#125;<br>&#125;<br><br><span class="hljs-comment">// 通过关键字 by 建立委托类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span></span>(b: Base) : Base <span class="hljs-keyword">by</span> b<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> b = BaseImpl(<span class="hljs-number">10</span>)<br>    Derived(b).print() <span class="hljs-comment">// 输出 10</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在某些场景下，假设我们需要在某个类对某个接口的一些方法进行重写，通过类委托来减少强制我们需要重写的方法</p><p>比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMap</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> realMap: HashMap&lt;<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>&gt;) : MutableMap&lt;<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>&gt; <span class="hljs-keyword">by</span> realMap &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> lastKey = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">put</span><span class="hljs-params">(key: <span class="hljs-type">Int</span>, value: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span>? &#123;<br>        lastKey = key<br>        <span class="hljs-keyword">return</span> realMap.put(key,value)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">recover</span><span class="hljs-params">()</span></span> &#123;<br>        realMap.remove(lastKey)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过将MutableMap委托给realMap使得realMap获得其所有方法，因此只需对我们所关心的方法进行重写</p><p><a href="%5B(28%E6%9D%A1%E6%B6%88%E6%81%AF">更多内容查看</a> “by” the way ——借ViewModel创建方式探索Kotlin的委托机制_Omnipotent’s Blog-CSDN博客](<a href="https://blog.csdn.net/weixin_43687181/article/details/115712877?spm=1001.2014.3001.5501">https://blog.csdn.net/weixin_43687181/article/details/115712877?spm=1001.2014.3001.5501</a>))</p><p>关于委托还有不少东西要说，鉴于篇幅，更多参考<a href="https://www.kotlincn.net/docs/reference/delegated-properties.html">官方文档</a></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型，即-“参数化类型”，将类型参数化，可以用在类，接口，方法上。"><a href="#泛型，即-“参数化类型”，将类型参数化，可以用在类，接口，方法上。" class="headerlink" title="泛型，即 “参数化类型”，将类型参数化，可以用在类，接口，方法上。"></a>泛型，即 “参数化类型”，将类型参数化，可以用在类，接口，方法上。</h3><p>与 Java 一样，Kotlin 也提供泛型，为类型安全提供保证，消除类型强转的烦恼。</p><p>声明一个泛型类:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-type">T</span>&gt;</span>(t: T) &#123;<br>    <span class="hljs-keyword">var</span> value = t<br>&#125;<br></code></pre></td></tr></table></figure><p>创建类的实例时我们需要指定类型参数:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> box: Box&lt;<span class="hljs-built_in">Int</span>&gt; = Box&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">1</span>)<br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">val</span> box = Box(<span class="hljs-number">1</span>) <span class="hljs-comment">// 编译器会进行类型推断，1 类型 Int，所以编译器知道我们说的是 Box&lt;Int&gt;。</span><br></code></pre></td></tr></table></figure><h3 id="泛型约束："><a href="#泛型约束：" class="headerlink" title="泛型约束："></a>泛型约束：</h3><p>我们可以使用泛型约束来设定一个给定参数允许使用的类型。</p><p>Kotlin 中使用 : 对泛型的类型上限进行约束。</p><p>最常见的约束是上界(upper bound)：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="hljs-title">sort</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>    <span class="hljs-comment">// ……</span><br>&#125;<br><span class="hljs-comment">//Comparable 的子类型可以替代 T。 例如:</span><br>sort(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">// OK。Int 是 Comparable&lt;Int&gt; 的子类型</span><br>sort(listOf(HashMap&lt;<span class="hljs-built_in">Int</span>, String&gt;())) <span class="hljs-comment">// 错误：HashMap&lt;Int, String&gt; 不是 Comparable&lt;HashMap&lt;Int, String&gt;&gt; 的子类型</span><br></code></pre></td></tr></table></figure><p>对于多个上界约束条件，可以用 where 子句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">copyWhenGreater</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt;, threshold: <span class="hljs-type">T</span>)</span></span>: List&lt;String&gt;<br>    <span class="hljs-keyword">where</span> T : CharSequence,<br>          T : Comparable&lt;T&gt; &#123;<br>    <span class="hljs-keyword">return</span> list.filter &#123; it &gt; threshold &#125;.map &#123; it.toString() &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>rust也是用的这玩意修饰的</p><h3 id="型变"><a href="#型变" class="headerlink" title="型变"></a>型变</h3><p>Kotlin 中没有通配符类型，它有两个其他的东西：声明处型变（declaration-site variance）与类型投影（type projections）</p><h4 id="声明处型变"><a href="#声明处型变" class="headerlink" title="声明处型变"></a>声明处型变</h4><p>声明处的类型变异使用协变注解修饰符：in、out，消费者 in, 生产者 out。</p><p>使用 out 使得一个类型参数协变，协变类型参数只能用作输出，可以作为返回值类型但是无法作为入参的类型：</p><p>in 使得一个类型参数逆变，逆变类型参数只能用作输入，可以作为入参的类型但是无法作为返回值的类型：</p><h3 id="星号投射"><a href="#星号投射" class="headerlink" title="星号投射"></a>星号投射</h3><p><a href="https://www.kotlincn.net/docs/reference/generics.html">看看官方的</a></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的基础操作"><a href="#函数的基础操作" class="headerlink" title="函数的基础操作"></a>函数的基础操作</h3><p>kotlin中使用<code>fun</code>来声明函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">double</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x<br>&#125;<br></code></pre></td></tr></table></figure><p>函数可以具有默认参数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">read</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    b: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">Byte</span>&gt;, </span></span><br><span class="hljs-params"><span class="hljs-function">    off: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">    len: <span class="hljs-type">Int</span> = b.size,</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123; <span class="hljs-comment">/*……*/</span> &#125;<br></code></pre></td></tr></table></figure><p>覆盖方法总是使用与基类型方法相同的默认参数值。 当覆盖一个带有默认参数值的方法时，必须从签名中省略默认参数值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(i: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span>)</span></span> &#123; <span class="hljs-comment">/*……*/</span> &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> : <span class="hljs-type">A</span></span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(i: <span class="hljs-type">Int</span>)</span></span> &#123; <span class="hljs-comment">/*……*/</span> &#125;  <span class="hljs-comment">// 不能有默认值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个默认参数在一个无默认值的参数之前，那么该默认值只能通过使用<a href="https://www.kotlincn.net/docs/reference/functions.html#%E5%85%B7%E5%90%8D%E5%8F%82%E6%95%B0">具名参数</a>调用该函数来使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    bar: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">    baz: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123; <span class="hljs-comment">/*……*/</span> &#125;<br><br>foo(baz = <span class="hljs-number">1</span>) <span class="hljs-comment">// 使用默认值 bar = 0</span><br></code></pre></td></tr></table></figure><p>如果在默认参数之后的最后一个参数是 lambda 表达式，那么它既可以作为具名参数在括号内传入，也可以在括号外传入：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    bar: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    baz: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    qux: () -&gt; <span class="hljs-type">Unit</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123; <span class="hljs-comment">/*……*/</span> &#125;<br><br>foo(<span class="hljs-number">1</span>) &#123; println(<span class="hljs-string">&quot;hello&quot;</span>) &#125;     <span class="hljs-comment">// 使用默认值 baz = 1</span><br>foo(qux = &#123; println(<span class="hljs-string">&quot;hello&quot;</span>) &#125;) <span class="hljs-comment">// 使用两个默认值 bar = 0 与 baz = 1</span><br>foo &#123; println(<span class="hljs-string">&quot;hello&quot;</span>) &#125;        <span class="hljs-comment">// 使用两个默认值 bar = 0 与 baz = 1</span><br></code></pre></td></tr></table></figure><h3 id="Kotlin中不同的函数"><a href="#Kotlin中不同的函数" class="headerlink" title="Kotlin中不同的函数"></a>Kotlin中不同的函数</h3><h4 id="使用suspend标记的协程挂起函数：协程部分讲"><a href="#使用suspend标记的协程挂起函数：协程部分讲" class="headerlink" title="使用suspend标记的协程挂起函数：协程部分讲"></a>使用<code>suspend</code>标记的协程挂起函数：协程部分讲</h4><h4 id="使用infix标记的中缀表示法（忽略该调用的点与圆括号）："><a href="#使用infix标记的中缀表示法（忽略该调用的点与圆括号）：" class="headerlink" title="使用infix标记的中缀表示法（忽略该调用的点与圆括号）："></a>使用<code>infix</code>标记的中缀表示法（忽略该调用的点与圆括号）：</h4><p>条件要求：</p><table><thead><tr><th>它们必须是成员函数或扩展函数；</th></tr></thead><tbody><tr><td>它们必须只有一个参数；</td></tr><tr><td>其参数不得接受可变数量的参数且不能有默认值</td></tr></tbody></table><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-built_in">Int</span>.<span class="hljs-title">shl</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123; …… &#125;<br><br><span class="hljs-comment">// 用中缀表示法调用该函数</span><br><span class="hljs-number">1</span> shl <span class="hljs-number">2</span><br><br><span class="hljs-comment">// 等同于这样</span><br><span class="hljs-number">1.</span>shl(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>感觉用的不是很多</p><h4 id="使用tailrec标记的尾递归函数："><a href="#使用tailrec标记的尾递归函数：" class="headerlink" title="使用tailrec标记的尾递归函数："></a>使用<code>tailrec</code>标记的尾递归函数：</h4><p>Kotlin 支持一种称为<a href="https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8">尾递归</a>的函数式编程风格。 这允许一些通常用循环写的算法改用递归函数来写，而无堆栈溢出的风险。 当一个函数用 <code>tailrec</code> 修饰符标记并满足所需的形式时，编译器会优化该递归，留下一个快速而高效的基于循环的版本：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> eps = <span class="hljs-number">1E-10</span> <span class="hljs-comment">// &quot;good enough&quot;, could be 10^-15</span><br><br><span class="hljs-keyword">tailrec</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findFixPoint</span><span class="hljs-params">(x: <span class="hljs-type">Double</span> = <span class="hljs-number">1.0</span>)</span></span>: <span class="hljs-built_in">Double</span><br>        = <span class="hljs-keyword">if</span> (Math.abs(x - Math.cos(x)) &lt; eps) x <span class="hljs-keyword">else</span> findFixPoint(Math.cos(x))<br></code></pre></td></tr></table></figure><p>要符合 <code>tailrec</code> 修饰符的条件的话，函数必须将其自身调用作为它执行的最后一个操作。在递归调用后有更多代码时，不能使用尾递归，并且不能用在 try/catch/finally 块中。目前在 Kotlin for JVM 与 Kotlin/Native 中支持尾递归。</p><h4 id="泛型函数："><a href="#泛型函数：" class="headerlink" title="泛型函数："></a>泛型函数：</h4><p>kotlin中泛型函数的声明与 Java 相同，类型参数要放在函数名的前面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">boxIn</span><span class="hljs-params">(value: <span class="hljs-type">T</span>)</span></span> = Box(value)<br></code></pre></td></tr></table></figure><h4 id="单表达函数："><a href="#单表达函数：" class="headerlink" title="单表达函数："></a>单表达函数：</h4><p>当函数返回单个表达式时，可以省略花括号并且在 <strong>=</strong> 符号之后指定代码体即可</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">double</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = x * <span class="hljs-number">2</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">double</span><span class="hljs-params">(x:<span class="hljs-type">Int</span>)</span></span>=x*<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="可变数量的参数（Varargs）"><a href="#可变数量的参数（Varargs）" class="headerlink" title="可变数量的参数（Varargs）:"></a>可变数量的参数（Varargs）:</h4><p>函数的参数（通常是最后一个）可以用 <code>vararg</code> 修饰符标记(类似与python中的*)：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">asList</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> ts: <span class="hljs-type">T</span>)</span></span>: List&lt;T&gt; &#123;<br>    <span class="hljs-keyword">val</span> result = ArrayList&lt;T&gt;()<br>    <span class="hljs-keyword">for</span> (t <span class="hljs-keyword">in</span> ts) <span class="hljs-comment">// ts is an Array</span><br>        result.add(t)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><span class="hljs-keyword">val</span> list = asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment">//------如果要传递数组也是可以的</span><br><span class="hljs-keyword">val</span> a  = arrayOf(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><span class="hljs-keyword">val</span> list = asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,*a)<br><span class="hljs-comment">//在数组前面加&quot;*&quot;</span><br></code></pre></td></tr></table></figure><h4 id="局部函数："><a href="#局部函数：" class="headerlink" title="局部函数："></a>局部函数：</h4><p>Kotlin 支持局部函数，即一个函数在另一个函数内部(确实很多高级语言都支持）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//官方给的dfs示例</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dfs</span><span class="hljs-params">(graph: <span class="hljs-type">Graph</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> visited = HashSet&lt;Vertex&gt;()<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dfs</span><span class="hljs-params">(current: <span class="hljs-type">Vertex</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (!visited.add(current)) <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">for</span> (v <span class="hljs-keyword">in</span> current.neighbors)<br>            dfs(v)<br>    &#125;<br><br>    dfs(graph.vertices[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p>并且这个是闭包的（支持局部函数的语言应该都通用）可以参考网络上大部分关于js的闭包</p><p>外部无法直接调用内部函数</p><h4 id="成员函数："><a href="#成员函数：" class="headerlink" title="成员函数："></a>成员函数：</h4><p>就是定义在类里面的函数（不就是方法吗</p><h4 id="内联函数："><a href="#内联函数：" class="headerlink" title="内联函数："></a>内联函数：</h4><p>被inline标记的函数就是内联函数,其原理就是:在编译时期,把调用这个函数的地方用这个函数的方法体进行替换</p><p>举个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">method</span><span class="hljs-params">( body: () -&gt; <span class="hljs-type">T</span>)</span></span>: T &#123;<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> body()<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>           <br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>对此方法在main中调用由kotlin字节码转java得到的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TetsKt</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>      method((Function0)<span class="hljs-keyword">null</span>.INSTANCE);<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>加了inline标记后是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TetsKt</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">boolean</span> var0 = <span class="hljs-keyword">false</span>;<br><br>      <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-keyword">int</span> var1 = <span class="hljs-keyword">false</span>;<br>         String var4 = <span class="hljs-string">&quot;我是body的方法体&quot;</span>;<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>         ;<br>      &#125;<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>可见inline使得函数整体被移动了过来</p><p>在编译时期就会把下面的内容替换到调用该方法的地方,这样就会减少方法压栈,出栈,进而减少资源消耗;</p><p>noline和crossline标记<a href="https://www.jianshu.com/p/4f29c9724b33">更多参考</a></p><h4 id="高阶函数："><a href="#高阶函数：" class="headerlink" title="高阶函数："></a>高阶函数：</h4><p>在<code>Kotlin</code>中，高阶函数即指：将函数用作一个函数的参数或者返回值的函数</p><p>可能类似于数学中的高次？</p><p>个人理解是在函数中传递一个函数（通常是lambda表达式）</p><p>例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">val</span> b = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">val</span> sum=&#123;<br>        d:<span class="hljs-built_in">Int</span>,e:<span class="hljs-built_in">Int</span>-&gt;d+e<br>    &#125;<br>    println(add(a,b,sum))<br>    <span class="hljs-comment">//传递一个lambda表达式</span><br>    println(add(a,b)&#123;<br>        a,b-&gt;a+b<br>    &#125;)<br>    <span class="hljs-comment">//由于lambda表达式是最后一个，所以可以直接&#123;&#125;</span><br>    println(add(a,b,::sumOf))<br>    <span class="hljs-comment">//：：创建函数类型对象的引用</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sumOf</span><span class="hljs-params">(a:<span class="hljs-type">Int</span>,b:<span class="hljs-type">Int</span>)</span></span>=a+b<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">(a:<span class="hljs-type">Int</span>,b:<span class="hljs-type">Int</span>,sum:(<span class="hljs-type">a</span>:<span class="hljs-type">Int</span>,<span class="hljs-type">b</span>:<span class="hljs-type">Int</span>)-&gt;<span class="hljs-type">Int</span>)</span></span>=sum(a,b)<br><br></code></pre></td></tr></table></figure><p><a href="https://rengwuxian.com/kotlin-lambda/">康康扔物线咋说的</a></p><h4 id="匿名函数："><a href="#匿名函数：" class="headerlink" title="匿名函数："></a>匿名函数：</h4><p>匿名函数顾名思义就是没有名字的函数，那这种没有名字的函数我们怎么调用呢？答案是无法直接调用。匿名函数可以赋值给一个变量，或者当作实参直接传递给一个函数类型的形参。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(appleBean: <span class="hljs-type">AppleBean</span>)</span></span>: <span class="hljs-built_in">Boolean</span> = appleBean.weight &gt; <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>就是没有名字（</p><p>此外，匿名函数还可以赋值给变量</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> filterWeightFunPredicate =<br>            <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(appleBean: <span class="hljs-type">AppleBean</span>)</span></span>: <span class="hljs-built_in">Boolean</span> = appleBean.weight<br></code></pre></td></tr></table></figure><p>差不多和lambda表达式用法一样</p><h4 id="作用域函数："><a href="#作用域函数：" class="headerlink" title="作用域函数："></a>作用域函数：</h4><p>Kotlin 的作用域函数有五种：<code>let</code>、<code>run</code>、<code>with</code>、<code>apply</code> 以及 <code>also</code>。</p><p>这些函数基本上做了同样的事情：在一个对象上执行一个代码块。</p><p>典型用法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> adam = Person(<span class="hljs-string">&quot;Adam&quot;</span>).apply &#123; <br>    age = <span class="hljs-number">20</span><br>    city = <span class="hljs-string">&quot;London&quot;</span><br>&#125;<br>println(adam)<br><span class="hljs-comment">//------不使用apply的话</span><br><span class="hljs-keyword">val</span> adam = Person(<span class="hljs-string">&quot;Adam&quot;</span>)<br>adam.age = <span class="hljs-number">20</span><br>adam.city = <span class="hljs-string">&quot;London&quot;</span><br>println(adam)<br></code></pre></td></tr></table></figure><p>这几种第一行代码第三版的讲的很清楚，这里只是简单提及一下</p><p><a href="https://www.kotlincn.net/docs/reference/scope-functions.html">也可以看看这个</a></p><h4 id="扩展函数："><a href="#扩展函数：" class="headerlink" title="扩展函数："></a>扩展函数：</h4><p>Kotlin的扩展函数可以让你作为一个类成员进行调用的函数，但是是定义在这个类的外部。这样可以很方便的扩展一个已经存在的类，为它添加额外的方法。</p><p>例子：</p><p>假如我们需要为String类型添加一个返回这个字符串最后一个字符的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">lastChar</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Char</span> = <span class="hljs-keyword">this</span>.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">this</span>.length - <span class="hljs-number">1</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    println(<span class="hljs-string">&quot;Kotlin&quot;</span>.lastChar())<br>&#125;<br></code></pre></td></tr></table></figure><p>扩展函数用于安卓中，可以对String类进行扩展使得我们打toast更方便一点</p><p>也可以对view进行扩展，比如添加一个动画函数等</p><p><a href="https://www.jianshu.com/p/7291c9a1ec1e">更多内容</a></p><h3 id="lambda表达式及函数式接口"><a href="#lambda表达式及函数式接口" class="headerlink" title="lambda表达式及函数式接口"></a>lambda表达式及函数式接口</h3><h4 id="函数式（SAM）接口"><a href="#函数式（SAM）接口" class="headerlink" title="函数式（SAM）接口"></a>函数式（SAM）接口</h4><p>只有一个抽象方法的接口称为<em>函数式接口</em>或 <em>SAM（单一抽象方法）</em>接口。函数式接口可以有多个非抽象成员，但只能有一个抽象成员。</p><p>可以用 <code>fun</code> 修饰符在 Kotlin 中声明一个函数式接口。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-keyword">interface</span> KRunnable &#123;</span><br>   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SAM转化"><a href="#SAM转化" class="headerlink" title="SAM转化"></a>SAM转化</h4><p>例如，假定存在函数式接口</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-keyword">interface</span> IntPredicate &#123;</span><br>   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">accept</span><span class="hljs-params">(i: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Boolean</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果不使用 SAM 转换，那么你需要像这样编写代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 创建一个类的实例</span><br><span class="hljs-keyword">val</span> isEven = <span class="hljs-keyword">object</span> : IntPredicate &#123;<br>   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">accept</span><span class="hljs-params">(i: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>       <span class="hljs-keyword">return</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用lambda转换后</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> isEven = IntPredicate &#123; it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#125;<br></code></pre></td></tr></table></figure><p>lambda匿名内部类实锤确信</p><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p>上文提及不少，此处不再提了，更多本文高阶函数部分</p><h2 id="Kotlin的空安全"><a href="#Kotlin的空安全" class="headerlink" title="Kotlin的空安全"></a>Kotlin的空安全</h2><h3 id><a href="#" class="headerlink" title="?"></a>?</h3><p>kotlin在默认情况下，我们创建的所有变量都是不允许为空的，必须给其指定一个值，如果给它赋值为 null，就会报错。如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NullTest</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> str: String = <span class="hljs-literal">null</span><span class="hljs-comment">//出错，默认情况下不能为空</span><br><br>    <span class="hljs-keyword">var</span> name:String =<span class="hljs-string">&quot;tandeneck&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">assignNull</span><span class="hljs-params">()</span></span>&#123;<br>        name = <span class="hljs-literal">null</span> <span class="hljs-comment">//出错，不能赋值为空</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然要想他为空加个”?”就可以了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> str:String ?=<span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title="?."></a>?.</h3><p>当我们要对一个对象调用方法时，需要对其进行判空处理，就可以这样干</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">textView?.textSize = <span class="hljs-number">20f</span><br></code></pre></td></tr></table></figure><p>这个写法同样会对变量做一次非空确认之后再调用方法</p><h3 id="-2"><a href="#-2" class="headerlink" title="!!"></a>!!</h3><p>这个叫做非空断言，差不多意思是我肯定他是非空的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">textView!!.textSize = <span class="hljs-number">20f</span><br></code></pre></td></tr></table></figure><h3 id="-3"><a href="#-3" class="headerlink" title="?:"></a>?:</h3><p>Elvis 操作符能够大大简化 if-else 表达式，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> length1: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) b.length <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">val</span> length2: <span class="hljs-built_in">Int</span> = b?.length ?: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="as"><a href="#as" class="headerlink" title="as?"></a>as?</h3><p>Kotlin 可以使用 as 关键字来进行类型转换，如果对象不是目标类型，那么类型转换可能会导致 ClassCastException。这时我们选择 as? ,如果尝试转换不成功则会返回 null：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;string&quot;</span><br>    <span class="hljs-keyword">val</span> num: <span class="hljs-built_in">Int</span>? = str <span class="hljs-keyword">as</span>? <span class="hljs-built_in">Int</span><br>    println(num)<br>    <span class="hljs-comment">//输出 null</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="let"><a href="#let" class="headerlink" title="?.let{}"></a>?.let{}</h3><p>let函数除了可用于在同一个作用域下操作变量外还可以用作做判null操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> str = <span class="hljs-string">&quot;&quot;</span><br>    str?.let &#123; println(it)&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不是绝对的空指针安全"><a href="#不是绝对的空指针安全" class="headerlink" title="不是绝对的空指针安全"></a>不是绝对的空指针安全</h3><p>Kotlin中并不是绝对的空指针安全，最常见的就是在Kotlin去调Java代码，比如下面这个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> static String getMsg() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//kotlin</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(Test.getMsg().length)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>会引发空指针</p><p>可通过加”?”来解决这个问题</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Test.getMsg()?.length<br></code></pre></td></tr></table></figure><p>涉及的一些原理可以看看这个-&gt;<a href="https://juejin.cn/post/6844904048987127822">更多查看</a></p><h2 id="集合和数组"><a href="#集合和数组" class="headerlink" title="集合和数组"></a>集合和数组</h2><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><p>数组在上文中简单的提及到了创建，和其他语言相同可以通过下标来进行访问，数组包含一下几种类型及创建方法</p><table><thead><tr><th>intArrayOf()整型</th></tr></thead><tbody><tr><td>longArrayOf()长整型</td></tr><tr><td>floatArrayOf()单精度</td></tr><tr><td>doubleArrayOf()双精度</td></tr><tr><td>booleanArrayOf()布尔型</td></tr></tbody></table><p>创建默认值为null的数组</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">arrayOfNulls&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>创建空数组</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">emptyArray&lt;<span class="hljs-built_in">Int</span>&gt;()<br></code></pre></td></tr></table></figure><p>三维数组（</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> arrB = Array(<span class="hljs-number">3</span>)&#123;Array(<span class="hljs-number">3</span>)&#123;IntArray(<span class="hljs-number">3</span>)&#125;&#125;<br></code></pre></td></tr></table></figure><p>可以通过下标或者set()函数来修改值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">intArr[index] = <span class="hljs-number">0</span> <span class="hljs-comment">//与java一样，可以这样修改数据</span><br>intArr.<span class="hljs-keyword">set</span>(index,<span class="hljs-number">1</span>) <span class="hljs-comment">//kotlin可以通过set函数进行修改数据</span><br></code></pre></td></tr></table></figure><h3 id="集合："><a href="#集合：" class="headerlink" title="集合："></a>集合：</h3><p>Kotlin的集合分类：</p><ul><li>可变集合类（Mutable）</li><li>不可变集合类（Immutable）。</li></ul><p>集合类存放的都是对象的引用，而非对象本身，我们通常说的集合中的对象指的是集合中对象的引用。集合类型主要有List(列表)，Set(集)，Map(映射)。</p><h4 id="Set："><a href="#Set：" class="headerlink" title="Set："></a>Set：</h4><table><thead><tr><th>特性：无序不重复，大小固定，元素类型不可变</th></tr></thead><tbody><tr><td>定义：Set&lt;泛型&gt;或setOf(元素1，元素2，…，元素n)</td></tr><tr><td>主要方法：交、差、并、补</td></tr></tbody></table><p>创建并输出集合内容</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> languages = setOf(<span class="hljs-string">&quot;Java&quot;</span>, <span class="hljs-string">&quot;Kotlin&quot;</span>, <span class="hljs-string">&quot;Python&quot;</span>)<br><span class="hljs-keyword">for</span> (language <span class="hljs-keyword">in</span> languages) &#123;<br>    println(language)<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用foreach来遍历</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">languages.forEach &#123; println(it) &#125;<br></code></pre></td></tr></table></figure><h4 id="Map"><a href="#Map" class="headerlink" title="Map:"></a>Map:</h4><p>只读Map。<br>可变的MutableMap(MutableMap、HashMap、LinkedHashMap)。</p><p>创建map并输出:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> map = mapOf(<span class="hljs-string">&quot;hello&quot;</span> to <span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-string">&quot;1&quot;</span> to <span class="hljs-string">&quot;2&quot;</span>)<br>    println(map)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list:"></a>list:</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">listOf&lt;T&gt;()<span class="hljs-comment">//创建固定元素个数的list</span><br>mutableListOf&lt;T&gt;()<span class="hljs-comment">//创建可读可修改的集合</span><br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">list.forEachIndexed &#123; index, value -&gt;<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$index</span> <span class="hljs-variable">$value</span>&quot;</span>)<br>    &#125;<br><span class="hljs-comment">//使用这种遍历带下标的</span><br><span class="hljs-comment">//也可以使用foreach</span><br></code></pre></td></tr></table></figure><p>增删查改更多<a href="http://www.kotlincn.net/docs/reference/collections-overview.html">参考官方文档</a></p><h2 id="协程与flow"><a href="#协程与flow" class="headerlink" title="协程与flow"></a>协程与flow</h2>]]></content>
    
    
    <categories>
      
      <category>kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kotlin语言基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习入门《2》神经网络</title>
    <link href="/2021/10/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A2%E3%80%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/10/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A2%E3%80%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="神经网络与感知机"><a href="#神经网络与感知机" class="headerlink" title="神经网络与感知机"></a>神经网络与感知机</h3><p>神经网络与感知机有很多的共同点，但是也存在着一些差异</p><ol><li>感知机虽然拥有即使是复杂函数也有表示他的可能性，理论支撑来着数字电路三门组合能表达出复杂的电路逻辑</li><li>但是，感知机设置权值的工作需要由人工来确定。</li><li>神经网络的一个特点就是，他可以通过自动地从数据中学习到合适的权重参数</li></ol><h3 id="神经网络示意图："><a href="#神经网络示意图：" class="headerlink" title="神经网络示意图："></a>神经网络示意图：</h3><p><img src="/2021/10/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A2%E3%80%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/8uynp06sti.png"></p><p>最左边称为输入层，中间称为中间层（有时也被称为隐藏层【隐藏层的神经元肉眼无法看见】），最右边称为输出层</p><ol><li>有的书描述会将其称为3层网络，理由是构成网络的层数</li><li>有的书会将其描述为2层网络，理由是拥有权重的层数（输入层，输出层，中间层数量-1）</li></ol><h3 id="激活函数登场"><a href="#激活函数登场" class="headerlink" title="激活函数登场"></a>激活函数登场</h3><p>在感知机的y = x函数基础上进行了使用激活函数h来进行简化表示这种分情况的动作，</p><p><img src="/2021/10/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A2%E3%80%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/v2-56822c1d68fc828df3f7a498ebbb4d8b_720w.jpg"></p><p>激活函数如同抽象化的生物学上的神经元之间传输使用的某种生化信号（涉及轴突树突之间信号的传递），这里表达的就是如同我们常识所知道的那样，当化学量达到一定浓度时，神经元之间信号传递才有效，所以这里的激活函数就起到了控制这种化学传递的一个阀</p><img src="/2021/10/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A2%E3%80%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/640.png" style="zoom:67%;"><h3 id="常用的激活函数"><a href="#常用的激活函数" class="headerlink" title="常用的激活函数"></a>常用的激活函数</h3><h4 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h4><p>Sigmoid函数是一个在<a href="https://baike.baidu.com/item/%E7%94%9F%E7%89%A9%E5%AD%A6/1358">生物学</a>中常见的<a href="https://baike.baidu.com/item/S%E5%9E%8B%E5%87%BD%E6%95%B0/19178062">S型函数</a>，也称为<a href="https://baike.baidu.com/item/S%E5%9E%8B%E7%94%9F%E9%95%BF%E6%9B%B2%E7%BA%BF/5581189">S型生长曲线</a>。 [1] 在信息科学中，由于其单增以及反函数单增等性质，Sigmoid函数常被用作<a href="https://baike.baidu.com/item/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/16600562">神经网络</a>的<a href="https://baike.baidu.com/item/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/2520792">激活函数</a>，将变量映射到0,1之间。</p><p><img src="/2021/10/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A2%E3%80%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/1285295-20180727154358729-854643533.png"></p><p><img src="/2021/10/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A2%E3%80%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/d009b3de9c82d158dfb4e7218a0a19d8bc3e426f.jpg"></p><p>使用python 描述：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sigmoid</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + np.exp(-x))<br></code></pre></td></tr></table></figure><h4 id="阶跃函数"><a href="#阶跃函数" class="headerlink" title="阶跃函数"></a>阶跃函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step_function</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">return</span> np.array(x &gt; <span class="hljs-number">0</span>, dtype=np.<span class="hljs-built_in">int</span>)<br></code></pre></td></tr></table></figure><p>图片绘制：</p><img src="/2021/10/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A2%E3%80%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/image-20211003110403947.png" alt="image-20211003110403947" style="zoom:67%;"><p>两者都是非线性函数</p><p>神经网络的激活函数必须是非线性函数，否则加深神经网络的层数将失去意义</p><h4 id="ReLU函数"><a href="#ReLU函数" class="headerlink" title="ReLU函数"></a>ReLU函数</h4><p>其在输入大于0的时候直接输出该值，在输入小于等于0时，输出0</p><p>使用python实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">relu</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">return</span> np.maximum(<span class="hljs-number">0</span>, x)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++求斐波拉西数列</title>
    <link href="/2021/10/02/c++%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/10/02/c++%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="使用c-模板元编程求斐波拉西数列"><a href="#使用c-模板元编程求斐波拉西数列" class="headerlink" title="使用c++模板元编程求斐波拉西数列"></a>使用c++模板元编程求斐波拉西数列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> num&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fib</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span>result=fib&lt;num<span class="hljs-number">-1</span>&gt;::result+fib&lt;num<span class="hljs-number">-2</span>&gt;::result&#125;;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fib</span>&lt;</span><span class="hljs-number">0</span>&gt;<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span>result=<span class="hljs-number">1</span>&#125;;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fib</span>&lt;</span><span class="hljs-number">1</span>&gt;<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">enum</span>&#123;</span> result=<span class="hljs-number">1</span>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="使用constexpr-关键字求"><a href="#使用constexpr-关键字求" class="headerlink" title="使用constexpr 关键字求"></a>使用constexpr 关键字求</h3><p>constexpr  允许编程者保证函数或对象的构造函数是编译时常量</p><p>在此处时都是允许在编译期对其进行求值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++11</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> <span class="hljs-title">factorial_Cpp11</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> n == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : n * <span class="hljs-built_in">factorial_Cpp11</span>(n - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// C++14</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> <span class="hljs-title">factorial_Cpp14</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        result *= i;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求素数</title>
    <link href="/2021/10/02/%E6%B1%82%E7%B4%A0%E6%95%B0/"/>
    <url>/2021/10/02/%E6%B1%82%E7%B4%A0%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="求素数："><a href="#求素数：" class="headerlink" title="求素数："></a>求素数：</h2><h3 id="朴素算法求素数："><a href="#朴素算法求素数：" class="headerlink" title="朴素算法求素数："></a>朴素算法求素数：</h3><p>算法描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-comment">//c++使用cmath c使用math.h</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br> <br><span class="hljs-keyword">int</span> i,sqr = <span class="hljs-built_in">sqrt</span>((<span class="hljs-keyword">double</span>)n);<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>; i&lt;=sqr; ++i)<br>&#123;<br><span class="hljs-keyword">if</span> ( (n%i) == <span class="hljs-number">0</span> )<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>调用方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">100</span>; i &lt; <span class="hljs-number">200</span>; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPrime</span>(i))<br>        cout&lt;&lt;i&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="埃式筛选法及求素数的基本原理："><a href="#埃式筛选法及求素数的基本原理：" class="headerlink" title="埃式筛选法及求素数的基本原理："></a>埃式筛选法及求素数的基本原理：</h3><p>筛法求素数的基本思想是：把从2到N的一组<a href="https://baike.baidu.com/item/%E6%AD%A3%E6%95%B4%E6%95%B0">正整数</a>从小到大按顺序排列。从中依次删除2的倍数、3的倍数、5的倍数，直到根号N的倍数为止，剩余的即为2~N之间的所有素数</p><h4 id="使用c-来描述这一操作："><a href="#使用c-来描述这一操作：" class="headerlink" title="使用c++来描述这一操作："></a>使用c++来描述这一操作：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> range 2000</span><br><span class="hljs-keyword">bool</span> IsPrime[range + <span class="hljs-number">1</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initPrime</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> IsPrime[])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= range; ++i)<br>        IsPrime[i] = <span class="hljs-literal">true</span>;<br>    IsPrime[<span class="hljs-number">0</span>] = IsPrime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= range; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (IsPrime[i]) &#123;<br>            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">2</span> * i; j &lt;= range; j += i)<br>                IsPrime[j]=<span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度为<em>O</em>(<em>N<strong>l</strong>o<strong>g</strong>l<strong>o</strong>g**N</em>)</p><h3 id="欧式素数筛及其原理："><a href="#欧式素数筛及其原理：" class="headerlink" title="欧式素数筛及其原理："></a>欧式素数筛及其原理：</h3><p>在埃式基础上增加操作：每一个被筛掉的数都必须是被它的最小质因子筛掉，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(i % prime[j] == <span class="hljs-number">0</span>)<span class="hljs-comment">//确保是最小质因数</span><br>&#123;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initPrime_ou</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> isPrime[])</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> prime[range];<br>    <span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= range; ++i)<br>        IsPrime[i] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= range; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (isPrime[i]) prime[h++] = i;<br>        <span class="hljs-keyword">for</span> (j  = <span class="hljs-number">0</span>; j &lt; h &amp;&amp; i*prime[j]&lt;=range; ++j) &#123;<br>            isPrime[i*prime[j]] =<span class="hljs-literal">false</span>; <span class="hljs-comment">//筛去i的倍数</span><br>            <span class="hljs-keyword">if</span> (i%prime[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//保证每个合数被他的最小质因数筛去（去重</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>求素数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习入门《1》感知机</title>
    <link href="/2021/10/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A1%E3%80%8B%E6%84%9F%E7%9F%A5%E6%9C%BA/"/>
    <url>/2021/10/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A1%E3%80%8B%E6%84%9F%E7%9F%A5%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="感知机是什么？"><a href="#感知机是什么？" class="headerlink" title="感知机是什么？"></a>感知机是什么？</h2><p>感知机(Perceptron)在1957年由Rosenblatt提出，是神经网络和支持向量机的基础。</p><p>感知机是一种二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别，+1代表正类，-1代表负类。感知机属于判别模型，它的目标是要将输入实例通过分离超平面将正负二类分离。</p><p>简单来说就是接受多个信号来输出一个信号</p><p><img src="/2021/10/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A1%E3%80%8B%E6%84%9F%E7%9F%A5%E6%9C%BA/20160920193516651.jpg"></p><h3 id="以下内容为单层感知机的部分："><a href="#以下内容为单层感知机的部分：" class="headerlink" title="以下内容为单层感知机的部分："></a>以下内容为单层感知机的部分：</h3><p>（因为单层感知机的局限性，他只支持 与门，或门，与非门,原因是它只能由一条直线分开，曲线是无法用感知机表示的</p><p>由直线分割的为线性空间，曲线分割的为非线性空间</p><h3 id="简单逻辑电路"><a href="#简单逻辑电路" class="headerlink" title="简单逻辑电路"></a>简单逻辑电路</h3><h4 id="与门"><a href="#与门" class="headerlink" title="与门"></a>与门</h4><p>与门如果用我们常用的c来描述的话应该是指的 &amp;&amp;</p><p>对应的真值表为</p><table><thead><tr><th>A</th><th>B</th><th>Y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>下文中仍然以 0为假，1为真</p><h5 id="使用感知机实现与门："><a href="#使用感知机实现与门：" class="headerlink" title="使用感知机实现与门："></a>使用感知机实现与门：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">AND</span>(<span class="hljs-params">a, b</span>):</span><br>    x = np.array([a, b])<br>    w = np.array([<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>])<br>    b = -<span class="hljs-number">0.7</span><br>    tmp = np.<span class="hljs-built_in">sum</span>(w * x) + b<br>    <span class="hljs-keyword">if</span> tmp &lt;= <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>其中b 为偏置，是调整神经元被激活的容易程度（输出信号为1的程度）</p><h4 id="与非门"><a href="#与非门" class="headerlink" title="与非门"></a>与非门</h4><p>简单来说就是与门的反面</p><p>对应的真值表为：</p><table><thead><tr><th>A</th><th>B</th><th>Y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><h5 id="使用感知机实现与非门："><a href="#使用感知机实现与非门：" class="headerlink" title="使用感知机实现与非门："></a>使用感知机实现与非门：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">NAND</span>(<span class="hljs-params">a, b</span>):</span><br>    x = np.array([a, b])<br>    w = np.array([-<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>])<br>    b = <span class="hljs-number">0.7</span><br>    tmp = np.<span class="hljs-built_in">sum</span>(w * x) + b<br>    <span class="hljs-keyword">if</span> tmp &lt;= <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h4 id="或门"><a href="#或门" class="headerlink" title="或门"></a>或门</h4><p>或门用通常的c描述就是 ||操作</p><p>对应的真值表：</p><table><thead><tr><th>A</th><th>B</th><th>Y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><h5 id="使用感知机实现或门："><a href="#使用感知机实现或门：" class="headerlink" title="使用感知机实现或门："></a>使用感知机实现或门：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">OR</span>(<span class="hljs-params">a, b</span>):</span><br>    x = np.array([a, b])<br>    w = np.array([<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>])<br>    b = -<span class="hljs-number">0.2</span><br>    tmp = np.<span class="hljs-built_in">sum</span>(w * x) + b<br>    <span class="hljs-keyword">if</span> tmp &lt;= <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="以下为多层感知机内容："><a href="#以下为多层感知机内容：" class="headerlink" title="以下为多层感知机内容："></a>以下为多层感知机内容：</h3><h4 id="异或门："><a href="#异或门：" class="headerlink" title="异或门："></a>异或门：</h4><p>又称逻辑异或电路，仅当a或b中的一方为1时，才会输出1（“异或”为拒绝其他的意思）</p><p>其真值表为：</p><table><thead><tr><th>A</th><th>B</th><th>Y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>可以通过组合与门，与非门，或门来实现异或门</p><p><img src="/2021/10/02/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A1%E3%80%8B%E6%84%9F%E7%9F%A5%E6%9C%BA/12472907-e997d8f579f7c831.webp"></p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th><th>Y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">XOR</span>(<span class="hljs-params">a, b</span>):</span><br>    s1 = NAND(a, b)<br>    s2 = OR(a, b)<br>    y = AND(s1, s2)<br>    <span class="hljs-keyword">return</span> y<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感知机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp简单特性学习笔记</title>
    <link href="/2021/10/01/cpp%E7%AE%80%E5%8D%95%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/10/01/cpp%E7%AE%80%E5%8D%95%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>标签测试</p>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
