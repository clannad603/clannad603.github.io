

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="HuangRui">
  <meta name="keywords" content="">
  <meta name="description" content="浅入理解Java虚拟机(雾什么是JVM？JVM 全称为Java Virtual  Machine ,JAVA程序的运行环境（JAVA二进制字节码的运行环境） JVM带来的好处 一次编写，到处运行(“Write once, run anywhere”)  自动内存管理  数组下标越界检查   常见的JVM  现在应该大多数的hotspot JVM JRE JDK的区别  Java代码是如何被执行的">
<meta property="og:type" content="article">
<meta property="og:title" content="jvm">
<meta property="og:url" content="https://clannad603.github.io/2021/10/03/jvm/index.html">
<meta property="og:site_name" content="普通重邮学生的blog">
<meta property="og:description" content="浅入理解Java虚拟机(雾什么是JVM？JVM 全称为Java Virtual  Machine ,JAVA程序的运行环境（JAVA二进制字节码的运行环境） JVM带来的好处 一次编写，到处运行(“Write once, run anywhere”)  自动内存管理  数组下标越界检查   常见的JVM  现在应该大多数的hotspot JVM JRE JDK的区别  Java代码是如何被执行的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://clannad603.github.io/2021/10/03/jvm/20200914100723848.png">
<meta property="og:image" content="https://clannad603.github.io/2021/10/03/jvm/525d84b7d526290a7c88900636ed1033.png">
<meta property="og:image" content="https://clannad603.github.io/2021/10/03/jvm/image-20210806170716879.png">
<meta property="og:image" content="https://clannad603.github.io/2021/10/03/jvm/image-20210805083235867.png">
<meta property="og:image" content="https://clannad603.github.io/2021/10/03/jvm/image-20210805083418893.png">
<meta property="og:image" content="https://clannad603.github.io/2021/10/03/jvm/8d1de13006ae9e0dd40d5e1db98a81c81603447597022.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1266638/201807/1266638-20180710225811662-425101318.png">
<meta property="og:image" content="https://clannad603.github.io/2021/10/03/jvm/image-20210802160632576.png">
<meta property="og:image" content="https://clannad603.github.io/2021/10/03/jvm/image-20210806161449743.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191208160358777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7557373-da64ffd6d1effaac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/295/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7557373-72912ea8e89c4007.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/313/format/webp">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200627192624320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5OTY1ODAw,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://clannad603.github.io/2021/10/03/jvm/image-20210804131002232.png">
<meta property="og:image" content="https://clannad603.github.io/2021/10/03/jvm/image-20210804102154659.png">
<meta property="og:image" content="https://clannad603.github.io/2021/10/03/jvm/image-20210804102300807.png">
<meta property="og:image" content="https://clannad603.github.io/2021/10/03/jvm/image-20210804103419141.png">
<meta property="og:image" content="https://clannad603.github.io/2021/10/03/jvm/image-20210804114409842.png">
<meta property="og:image" content="https://clannad603.github.io/2021/10/03/jvm/image-20210804114918627.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png">
<meta property="og:image" content="https://clannad603.github.io/2021/10/03/jvm/image-20210804143908786.png">
<meta property="og:image" content="https://clannad603.github.io/2021/10/03/jvm/image-20210804144414534.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png">
<meta property="og:image" content="https://clannad603.github.io/2021/10/03/jvm/image-20210805074443338.png">
<meta property="og:image" content="https://tse1-mm.cn.bing.net/th/id/R-C.d6e8f8b74e546354d6cc594269f88487?rik=BezOq%2fgcDZHlWw&riu=http%3a%2f%2fupload-images.jianshu.io%2fupload_images%2f2184951-256a9ccb6e51be85.png&ehk=6aQFuTMvcG2m353MYMeVw4gN4PZ0p1xl%2bkzX5pUOPEk%3d&risl=&pid=ImgRaw&r=0">
<meta property="og:image" content="https://clannad603.github.io/2021/10/03/jvm/image.2BEI70.png">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3279460766e7484dbee19e086739d0f0~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e6b8ee8c76847ed85f25d2624c35985~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.awebp">
<meta property="article:published_time" content="2021-10-03T05:50:48.000Z">
<meta property="article:modified_time" content="2021-10-04T11:27:45.860Z">
<meta property="article:author" content="HuangRui">
<meta property="article:tag" content="jvm基础">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://clannad603.github.io/2021/10/03/jvm/20200914100723848.png">
  
  <title>jvm - 普通重邮学生的blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"clannad603.github.io","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Hr&#39;blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/article.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="jvm">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-03 13:50" pubdate>
        2021年10月3日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      13k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      41 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">jvm</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021年10月4日 晚上
                
              </p>
            
            <div class="markdown-body">
              <h1 id="浅入理解Java虚拟机-雾"><a href="#浅入理解Java虚拟机-雾" class="headerlink" title="浅入理解Java虚拟机(雾"></a>浅入理解Java虚拟机(雾</h1><h2 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a>什么是JVM？</h2><p>JVM 全称为Java Virtual  Machine ,JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p>
<h2 id="JVM带来的好处"><a href="#JVM带来的好处" class="headerlink" title="JVM带来的好处"></a>JVM带来的好处</h2><ul>
<li><p>一次编写，到处运行(“Write once, run anywhere”)</p>
</li>
<li><p>自动内存管理</p>
</li>
<li><p>数组下标越界检查</p>
</li>
</ul>
<h2 id="常见的JVM"><a href="#常见的JVM" class="headerlink" title="常见的JVM"></a>常见的JVM</h2><img src="/2021/10/03/jvm/20200914100723848.png" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<p>现在应该大多数的hotspot</p>
<h2 id="JVM-JRE-JDK的区别"><a href="#JVM-JRE-JDK的区别" class="headerlink" title="JVM JRE JDK的区别"></a>JVM JRE JDK的区别</h2><img src="/2021/10/03/jvm/525d84b7d526290a7c88900636ed1033.png" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<h2 id="Java代码是如何被执行的"><a href="#Java代码是如何被执行的" class="headerlink" title="Java代码是如何被执行的"></a>Java代码是如何被执行的</h2><p><img src="/2021/10/03/jvm/image-20210806170716879.png" srcset="/img/loading.gif" lazyload alt="image-20210806170716879"></p>
<p><strong>一 编写java源程序</strong></p>
<p><strong>二、当java源程序编码结束后，就需要编译器编译。</strong></p>
<p>快进到javac编译为class</p>
<p>快进到看字节流</p>
<p><img src="/2021/10/03/jvm/image-20210805083235867.png" srcset="/img/loading.gif" lazyload></p>
<p>如果这里用cat直接看是乱码，但是在idea里面看的话，他会进行一些编写，然后成这样</p>
<p><img src="/2021/10/03/jvm/image-20210805083418893.png" srcset="/img/loading.gif" lazyload></p>
<p><code>cafe babe</code> 被称为“魔数”，是 JVM 识别 .class 文件的标志。文件格式的定制者可以自由选择魔数值（只要没用过），比如说 .png 文件的魔数是 <code>8950 4e47</code>。</p>
<h2 id="JVM-的结构"><a href="#JVM-的结构" class="headerlink" title="JVM 的结构"></a>JVM 的结构</h2><img src="/2021/10/03/jvm/8d1de13006ae9e0dd40d5e1db98a81c81603447597022.png" srcset="/img/loading.gif" lazyload style="zoom: 50%;">

<p>由此图可以得知：</p>
<p>JVM的结构分为以下内容：类加载器（ClassLoader）、执行引擎、内存区（运行时数据区）、本地方法接口。</p>
<p>其中内存区包括：虚拟机栈，本地方法栈，方法区，堆，程序计数器</p>
<h3 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h3><p>Program Counter Register</p>
<h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。（概念模型中：字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令）</p>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul>
<li><strong>线程私有</strong>：</li>
</ul>
<p>多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器</strong>，各条线程之间计数器互不影响，独立存储。</p>
<ul>
<li><strong>状态</strong>：</li>
</ul>
<p>①执行java方法，计数器记录虚拟机字节码指令的地址；②执行<strong>native方法，计数器为空（undefined）</strong></p>
<p>因为native方法是java通过JNI直接调用本地C/C++库，可以近似的认为native方法相当于C/C++暴露给java的一个接口，java通过调用这个接口从而调用到C/C++方法。由于该方法是通过C/C++而不是java进行实现。那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。</p>
<img src="https://images2018.cnblogs.com/blog/1266638/201807/1266638-20180710225811662-425101318.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:67%;">

<ul>
<li><strong>占用内存小，唯一不会OutOfMemoryError的区域</strong></li>
</ul>
<p>因为其本质上是寄存器来着</p>
<p><strong>接下来 简单演示一下如何查看字节码</strong></p>
<p>可以在 idea中安装插件jclasslib来进行查看</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>VM Stack</p>
<p>Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<ul>
<li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li>
<li>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存</li>
<li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></li>
</ul>
<p>典中典之常见虚拟机栈讲解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDemo</span> </span>&#123;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>            method1();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>            method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> c = a + b;<br>            <span class="hljs-keyword">return</span> c;<br>        &#125;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这里我打算进行演示</p>
<h4 id="常见虚拟机栈问题"><a href="#常见虚拟机栈问题" class="headerlink" title="常见虚拟机栈问题"></a>常见虚拟机栈问题</h4><p>垃圾回收是否涉及栈内存？</p>
<ul>
<li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li>
</ul>
<p>栈内存的分配越大越好吗？</p>
<ul>
<li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li>
</ul>
<p>设置参数方法：-Xss size 通常只有几百K</p>
<p>决定了函数调用的深度<br>每个线程都有独立的栈空间</p>
<p>局部变量、参数 分配在栈上</p>
<p>此处进入android studio调整vm 参数的地方</p>
<p>ps:idea64.exe.vmoptions针对的是 IDEA 环境，对通过 IDEA 运行的 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3c330074082b">Java 项目</a>不起作用。IDEA 本身就是一个 Java 应用，所以也必须运行于 JVM 之上。此处的idea64.exe.vmoptions文件就是用来配置 64 位的 IDEA 所使用的 JVM 参数。是 IDEA 运行时用的配置，并不是项目运行的配置</p>
<img src="/2021/10/03/jvm/image-20210802160632576.png" srcset="/img/loading.gif" lazyload style="zoom:67%;">

<p>运行单个项目时可以这样</p>
<img src="/2021/10/03/jvm/image-20210806161449743.png" srcset="/img/loading.gif" lazyload style="zoom:67%;">

<p>内存溢出:</p>
<p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p>
<p>发生原因：</p>
<ul>
<li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li>
<li>每个栈帧<strong>所占用过大</strong></li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈（Native Method Stacks）与 Java 虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的 Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java Heap</p>
<p>对于Java应用程序来说，Java堆是虚拟机所管理的内存的最大的一块。是被所有线程共享的一块内存区域（因为对象都是在堆里面创建的，而所有的线程都可以拿到对象的引用，所以在多线程并发过程中，对于一些对象，我们得加锁），这里稍微提一下并发和并行（下面几种垃圾回收器得用到）</p>
<p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p>
<p>堆里面包含了以下内容</p>
<img src="https://img-blog.csdnimg.cn/20191208160358777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述" style="zoom:67%;">

<p>在垃圾回收哪里讲讲</p>
<h4 id="并发-concurrency-："><a href="#并发-concurrency-：" class="headerlink" title="并发(concurrency)："></a>并发(concurrency)：</h4><p>指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7557373-da64ffd6d1effaac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/295/format/webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>简单点来说对与cpu处理并发任务就是宏观是并联的，微观是串联的</p>
<p>涉及时间片那些我就不说了（主要是忘记了</p>
<h4 id="并行-parallel-："><a href="#并行-parallel-：" class="headerlink" title="并行(parallel)："></a>并行(parallel)：</h4><p>指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7557373-72912ea8e89c4007.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/313/format/webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="出现在堆的常见异常："><a href="#出现在堆的常见异常：" class="headerlink" title="出现在堆的常见异常："></a>出现在堆的常见异常：</h4><p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p>
<img src="https://img-blog.csdnimg.cn/20200627192624320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5OTY1ODAw,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 67%;">

<p>典中典之内存不够了</p>
<img src="/2021/10/03/jvm/image-20210804131002232.png" srcset="/img/loading.gif" lazyload style="zoom:67%;">

<h4 id="堆内存诊断工具"><a href="#堆内存诊断工具" class="headerlink" title="堆内存诊断工具:"></a>堆内存诊断工具:</h4><h5 id="jps"><a href="#jps" class="headerlink" title="jps"></a><strong>jps</strong></h5><p><img src="/2021/10/03/jvm/image-20210804102154659.png" srcset="/img/loading.gif" lazyload></p>
<p>查看jvav运行的进程号</p>
<img src="/2021/10/03/jvm/image-20210804102300807.png" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<p><strong>-q</strong> 只显示pid，不显示class名称,jar文件名和传递给main方法的参数</p>
<p><strong>-m</strong> 输出传递给main方法的参数，在嵌入式jvm上可能是null</p>
<p><strong>-l</strong> 输出应用程序main class的完整package名或者应用程序的jar文件完整路径名</p>
<p><strong>-v</strong> 输出传递给JVM的参数</p>
<p><strong>-V</strong> 隐藏输出传递给JVM的参数</p>
<h5 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a><strong>jmap</strong></h5><img src="/2021/10/03/jvm/image-20210804103419141.png" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<p>   MinHeapFreeRatio     </p>
<ul>
<li><p>空闲堆空间的最小百分比，计算公式为：HeapFreeRatio =(CurrentFreeHeapSize/CurrentTotalHeapSize) * 100，值的区间为0到100，默认值为 40。如果HeapFreeRatio &lt; MinHeapFreeRatio，则需要进行堆扩容，扩容的时机应该在每次垃圾回收之后。</p>
<p> MaxHeapFreeRatio       </p>
</li>
<li><p>空闲堆空间的最大百分比，计算公式为：HeapFreeRatio =(CurrentFreeHeapSize/CurrentTotalHeapSize) * 100，值的区间为0到100，默认值为 70。如果HeapFreeRatio &gt; MaxHeapFreeRatio，则需要进行堆缩容，缩容的时机应该在每次垃圾回收之后。</p>
</li>
</ul>
<ol>
<li><p>   MaxHeapSize      JVM 堆空间允许的最大值。</p>
</li>
<li><p>   NewSize                  JVM 新生代堆空间的默认值。</p>
</li>
<li><p>   MaxNewSize              JVM 新生代堆空间允许的最大值。</p>
</li>
<li><p>   OldSize                  JVM 老年代堆空间的默认值。</p>
</li>
<li><p>   NewRatio                 新生代（2个Survivor区和Eden区 ）与老年代（不包括永久区）的堆空间比值</p>
</li>
<li><p>   SurvivorRatio            两个Survivor区和Eden区的堆空间比值为 他，表示 S0 ： S1 ：Eden = 1：1：？。</p>
</li>
<li><p>   MetaspaceSize           JVM 元空间的默认值。 </p>
</li>
<li><p>  MaxMetaspaceSize   JVM 元空间允许的最大值         </p>
</li>
<li><p>Compressed Class space 压缩类空间大小，Maximum size of class area in Metaspace when compressed class pointers are used（挺复杂的，而且大小不能超过32G，但是hotpot限制在了3g内，）</p>
</li>
<li><p>G1HeapRegionSize         在使用 G1 垃圾回收算法时，JVM 会将 Heap 空间分隔为若干个 Region，该参数用来指定每个 Region 空间的大小。</p>
</li>
</ol>
<p>Capacity = Regions * RegionSize 大小</p>
<p>这里先说一下这个命令遇到的一些坑</p>
<p>网上很多时候说使用jmap -heap pid来进行查看内存使用情况，但是这个命令对于jdk8之后的版本，不能再使用jmap -heap pid的命令了。<br>使用旧的命令会报错</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">Error: </span>-heap option used<br>Cannot connect to core dump or remote debug server. Use jhsdb jmap instead<br></code></pre></td></tr></table></figure>

<p>现场展示一下查看内存的步骤</p>
<p>jmap用法参考</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Usage:<br>    jmap [option] &lt;pid&gt;<br>        (<span class="hljs-keyword">to</span> connect <span class="hljs-keyword">to</span> running process)<br>    jmap [option] &lt;executable &lt;core&gt;<br>        (<span class="hljs-keyword">to</span> connect <span class="hljs-keyword">to</span> a core file)<br>    jmap [option] [server_id@]&lt;remote<span class="hljs-built_in"> server IP </span><span class="hljs-keyword">or</span> hostname&gt;<br>        (<span class="hljs-keyword">to</span> connect <span class="hljs-keyword">to</span> remote <span class="hljs-builtin-name">debug</span> server)<br><br>where &lt;option&gt; is one of:<br>    &lt;none&gt;               <span class="hljs-keyword">to</span> <span class="hljs-builtin-name">print</span> same <span class="hljs-builtin-name">info</span> as Solaris pmap<br>    -heap                <span class="hljs-keyword">to</span> <span class="hljs-builtin-name">print</span> java heap summary<br>    -histo[:live]        <span class="hljs-keyword">to</span> <span class="hljs-builtin-name">print</span> histogram of java object heap; <span class="hljs-keyword">if</span> the <span class="hljs-string">&quot;live&quot;</span><br>                         suboption is specified, only count live objects<br>    -permstat            <span class="hljs-keyword">to</span> <span class="hljs-builtin-name">print</span> permanent generation statistics<br>    -finalizerinfo       <span class="hljs-keyword">to</span> <span class="hljs-builtin-name">print</span> information on objects awaiting finalization<br>    -dump:&lt;dump-options&gt; <span class="hljs-keyword">to</span> dump java heap <span class="hljs-keyword">in</span> hprof binary format<br>                         dump-options:<br>                           live         dump only live objects; <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> specified,<br>                                        all objects <span class="hljs-keyword">in</span> the heap are dumped.<br>                           <span class="hljs-attribute">format</span>=b     binary format<br>                           <span class="hljs-attribute">file</span>=&lt;file&gt;  dump heap <span class="hljs-keyword">to</span> &lt;file&gt;<br>                         Example: jmap -dump:live,<span class="hljs-attribute">format</span>=b,file=heap.bin &lt;pid&gt;<br>    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; <span class="hljs-keyword">or</span> -histo<br>                         <span class="hljs-keyword">to</span> force a heap dump <span class="hljs-keyword">or</span> histogram when &lt;pid&gt; does <span class="hljs-keyword">not</span><br>                         respond. The <span class="hljs-string">&quot;live&quot;</span> suboption is <span class="hljs-keyword">not</span> supported<br>                         <span class="hljs-keyword">in</span> this mode.<br>    -h | -help           <span class="hljs-keyword">to</span> <span class="hljs-builtin-name">print</span> this help message<br>    -J&lt;flag&gt;             <span class="hljs-keyword">to</span> pass &lt;flag&gt; directly <span class="hljs-keyword">to</span> the runtime system<br></code></pre></td></tr></table></figure>

<p>此外需要注意一下如果一台设备上有多个jdk需要指定一下具体路径下的jvm工具（当然创建项目时使用环境中的jdk就不用</p>
<p>（怒 这个导致我查了好久的博客，网上讲这个错误的还比较稀少</p>
<h5 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a><strong>jconsole</strong></h5><p>理论上直接使用jconsole就能进入，但是可能会出一些bug</p>
<p>比如，我遇到的</p>
<img src="/2021/10/03/jvm/image-20210804114409842.png" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<p>但是有的进程又可以链接，</p>
<img src="/2021/10/03/jvm/image-20210804114918627.png" srcset="/img/loading.gif" lazyload style="zoom:50%;">

<p>这个还可以进行远程链接</p>
<p>此处将进行一些常见操作将进行演示</p>
<h5 id="jvirsalvm"><a href="#jvirsalvm" class="headerlink" title="jvirsalvm"></a><strong>jvirsalvm</strong></h5><p>这个不太会，jump了</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/baihuitestsoftware/articles/6405580.html">更多详情</a></p>
<h4 id="堆的一些参数配置"><a href="#堆的一些参数配置" class="headerlink" title="堆的一些参数配置"></a>堆的一些参数配置</h4><p>-XX:NewRatio:  设置Yong 和 Old的比例，比默认值为2，则Old Generation是 Yong Generation的2倍，即Yong Generation占据内存的1/3<br>-XX:NewSize : 设置Yong Generation的初始值大小<br>-XX:MaxNewSize：设置Yong Generation的最大值大小<br>-XX:SurviorRatio : 设置Eden和一个Suivior的比例，默认值为8，即Eden是To(S2)的比例是8，（From和To是一样大的），此时Eden占据Yong Generation的8/10<br>-XX:InitialTenuringThreshol : 设置晋升到老年代的对象年龄的最小值，默认为7<br>-XX:MaxTenuringThreshold : 设置晋升到老年代的对象年龄的最大值</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>结构：</p>
<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:67%;">

<p>由此图可以看见，在jvm 1.6和1.8有很大区别，首先是方法·区由jvm中转移到了本地内存中，StringTable也由常量池中转移到了堆里面，永久代变为了元空间（有一些报错也变了，但是鉴于我们现在使用的都是1.8以后的版本了，所以这里只会提到1.8的版本</p>
<p>copy一下元空间</p>
<h4 id="metaspace的组成"><a href="#metaspace的组成" class="headerlink" title="metaspace的组成"></a>metaspace的组成</h4><p>metaspace其实由两大部分组成</p>
<ul>
<li>Klass Metaspace</li>
<li>NoKlass Metaspace</li>
</ul>
<p>Klass Metaspace就是用来存klass的，klass是我们熟知的class文件在jvm里的运行时数据结构，不过有点要提的是我们看到的类似A.class其实是存在heap里的，是java.lang.Class的一个对象实例。这块内存是紧接着Heap的，和我们之前的perm一样，这块内存大小可通过<code>-XX:CompressedClassSpaceSize</code>参数来控制，这个参数前面提到了默认是1G，但是这块内存也可以没有，假如没有开启压缩指针就不会有这块内存，这种情况下klass都会存在NoKlass Metaspace里，另外如果我们把-Xmx设置大于32G的话，其实也是没有这块内存的，因为会这么大内存会关闭压缩指针开关。还有就是这块内存最多只会存在一块。</p>
<p>NoKlass Metaspace专门来存klass相关的其他的内容，比如method，constantPool等，这块内存是由多块内存组合起来的，所以可以认为是不连续的内存块组成的。这块内存是必须的，虽然叫做NoKlass Metaspace，但是也其实可以存klass的内容，上面已经提到了对应场景。</p>
<p>Klass Metaspace和NoKlass Mestaspace都是所有classloader共享的，所以类加载器们要分配内存，但是每个类加载器都有一个SpaceManager，来管理属于这个类加载的内存小块。如果Klass Metaspace用完了，那就会OOM了，不过一般情况下不会，NoKlass Mestaspace是由一块块内存慢慢组合起来的，在没有达到限制条件的情况下，会不断加长这条链，让它可以持续工作。</p>
<p>UseCompressedOops用来关闭类压缩</p>
<p>64bit的JVM出现后，OOPS的尺寸也变成了64bit，比之前的大了一倍。这会引入性能损耗——占的内存double了，并且同尺寸的CPU Cache要少存一倍的OOPS。</p>
<p>OOPS是指“ordinary object pointers“，就是原始指针。Java Runtime可以用这个指针直接访问指针对应的内存，做相应的操作（比如发起GC时做copy and sweep）。</p>
<p>从JDK6_u23开始UseCompressedOops被默认打开了。因此既能享受64bit带来的好处，又避免了64bit带来的性能损耗。当然，如果你有机会使用超过32G的堆内存，记得把这个选项关了。</p>
<h5 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h5><ul>
<li>1.8以前会导致<strong>永久代</strong>内存溢出</li>
<li>1.8以后会导致<strong>元空间</strong>内存溢出</li>
</ul>
<h2 id="垃圾回收-amp-amp-性能优化基础"><a href="#垃圾回收-amp-amp-性能优化基础" class="headerlink" title="垃圾回收&amp;&amp;性能优化基础"></a>垃圾回收&amp;&amp;性能优化基础</h2><h3 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收"></a>1、如何判断对象可以回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>在对象中添加一个引用计数器，每当有一个地方<br>引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可<br>能再被使用的。</p>
<p>引用计数算法（Reference Counting）虽然占用了一些额外的内存空间来进行计数，但<br>它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法</p>
<p>单纯的引用计数<br>就很难解决对象之间相互循环引用的问题。</p>
<p>来自深入理解Jvm虚拟机的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReferenceCountingGC</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Object instance = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _1MB = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] bigSize = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">2</span> * _1MB];<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGC</span><span class="hljs-params">()</span> </span>&#123;<br>        ReferenceCountingGC objA = <span class="hljs-keyword">new</span> ReferenceCountingGC();<br>        ReferenceCountingGC objB = <span class="hljs-keyword">new</span> ReferenceCountingGC();<br>        objA.instance = objB;<br>        objB.instance = objA;<br>        objA = <span class="hljs-keyword">null</span>;<br>        objB = <span class="hljs-keyword">null</span>;<br><span class="hljs-comment">// 假设在这行发生GC，objA和objB是否能被回收？</span><br>        System.gc();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        testGC();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>先来看看如何设置打印日志</p>
<p>此处得花一点时间</p>
<p>看看效果</p>
<p><img src="/2021/10/03/jvm/image-20210804143908786.png" srcset="/img/loading.gif" lazyload></p>
<p>此处的12M-&gt;2M意味着虚拟机并没有因为这两<br>个对象互相引用就放弃回收它们，这也从侧面说明了Java虚拟机并不是通过引用计数算法来判断对象<br>是否存活的。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+PrintGC</td>
<td>输出简单GC日志</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>输出详细GC日志，并且虚拟机退出前打印堆栈使用信息</td>
</tr>
<tr>
<td>-XX:+PrintHeapAtGC</td>
<td>在每次GC前后都打印堆栈信息</td>
</tr>
<tr>
<td>-XX:+PrintGCTimeStamps</td>
<td>输出GC的时间戳（以基准时间的形式）,JVM启动后的时间偏移量。</td>
</tr>
<tr>
<td>-XX:+PrintGCDateStamps</td>
<td>输出GC的时间戳（以日期的形式，如2020-04-02T10:09:01.045+0800）</td>
</tr>
<tr>
<td>-Xloggc:./gc.log    日志文件的输出路径</td>
<td>日志文件的输出路径</td>
</tr>
<tr>
<td>-XX:SurvivorRatio=8</td>
<td>定义了年轻代中Eden区与一个Survivor区的空间比例是8:1</td>
</tr>
<tr>
<td>-Xmx</td>
<td>设定程序运行期间最大可占用的内存大小</td>
</tr>
<tr>
<td>-Xms</td>
<td>设定程序启动时占用内存大小，大一点一般启动更快</td>
</tr>
<tr>
<td>-Xmn</td>
<td>设置年轻代占用内存大小</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold=N</td>
<td>对象年龄达到N后，下一次GC将进入老年代，可以为0</td>
</tr>
</tbody></table>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>come from 深入理解Java虚拟机</p>
<p>当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是<br>通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路就是通过<br>一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过<br>程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，<br>或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<img src="/2021/10/03/jvm/image-20210804144414534.png" srcset="/img/loading.gif" lazyload style="zoom:67%;">

<p><strong>可以作为GC Root的对象</strong></p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
<h3 id="2-五种引用"><a href="#2-五种引用" class="headerlink" title="2.五种引用"></a>2.五种引用</h3><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:67%;">



<h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p>
<ul>
<li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li>
</ul>
<h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p>
<ul>
<li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li>
</ul>
<p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p>
<p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p>
<p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p>
<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p>
<ul>
<li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li>
</ul>
<p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p>
<h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p>
<ul>
<li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li>
<li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li>
</ul>
<h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p>
<ul>
<li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li>
</ul>
<h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul>
<li>软引用和弱引用<strong>可以配合</strong>引用队列<ul>
<li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li>
</ul>
</li>
<li>虚引用和终结器引用<strong>必须配合</strong>引用队列<ul>
<li>虚引用和终结器引用在使用时会关联一个引用队列</li>
</ul>
</li>
</ul>
<h3 id="3-垃圾回收算法"><a href="#3-垃圾回收算法" class="headerlink" title="3.垃圾回收算法"></a>3.垃圾回收算法</h3><p><strong>标记-清除（Mark-Sweep）</strong><br>GC分为两个阶段，标记和清除。首先标记所有可回收的对象，在标记完成后统一回收所有被标记的对象。同时会产生不连续的内存碎片。碎片过多会导致以后程序运行时需要分配较大对象时，无法找到足够的连续内存，而不得已再次触发GC。</p>
<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:67%;">

<ul>
<li><strong>复制（Copy）</strong><br>将内存按容量划分为两块，每次只使用其中一块。当这一块内存用完了，就将存活的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。这样使得每次都是对半个内存区回收，也不用考虑内存碎片问题，简单高效。缺点需要两倍的内存空间。<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:67%;"></li>
</ul>
<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:67%;">

<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:67%;">

<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:67%;">

<ul>
<li><strong>标记-整理（Mark-Compact）</strong><br>也分为两个阶段，首先标记可回收的对象，再将存活的对象都向一端移动，然后清理掉边界以外的内存。此方法避免标记-清除算法的碎片问题，同时也避免了复制算法的空间问题。<br>一般年轻代中执行GC后，会有少量的对象存活，就会选用复制算法，只要付出少量的存活对象复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外过多内存空间分配，就需要使用标记-清理或者标记-整理算法来进行回收。</li>
</ul>
<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:67%;">

<h3 id="4-分代回收"><a href="#4-分代回收" class="headerlink" title="4.分代回收"></a>4.分代回收</h3><p>将堆内存分为两个部分，一部分名为新生代，一部分名为老年代</p>
<img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:67%;">

<p>其中新生代分为了伊甸园，幸存区from，幸存区to。</p>
<p>首先，new出来的对象在伊甸园进行创建</p>
<p>当伊甸园的内存不足是，就会进行垃圾回收，此时叫做minor GC,</p>
<ul>
<li>Minor GC会将伊甸园和幸存区FROM存活对象复制到幸存区TO中，使得其寿命加一(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)，在交换两个幸存区</li>
</ul>
<p>不管怎样，都会保证名为To的幸存区是空的，Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p>
<ul>
<li>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</li>
<li>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></li>
<li>再次创建对象，若新生代的伊甸园又满了，则会再次触发 Minor GC（会触发 stop the world， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，还会回收幸存区中的垃圾，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象寿命加1</li>
</ul>
<h4 id="有关新生代的JVM参数"><a href="#有关新生代的JVM参数" class="headerlink" title="有关新生代的JVM参数"></a><strong>有关新生代的JVM参数</strong></h4><p>1)-XX:NewSize和-XX:MaxNewSize</p>
<p>用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。</p>
<p>2)-XX:SurvivorRatio</p>
<p>用于设置Eden和其中一个Survivor的比值，这个值也比较重要。</p>
<p>3)-XX:+PrintTenuringDistribution</p>
<p>这个参数用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。</p>
<p>4).-XX:InitialTenuringThreshol和-XX:MaxTenuringThreshold</p>
<p>用于设置晋升到老年代的对象年龄的最小值和最大值，每个对象在坚持过一次Minor GC之后，年龄就加1。</p>
<p>康康jstart输出</p>
<p><img src="/2021/10/03/jvm/image-20210805074443338.png" srcset="/img/loading.gif" lazyload></p>
<p>其中各参数代表</p>
<ul>
<li>S0，S1，两个survivor区域，可以看到它们的使用率为0</li>
<li>E，代表eden，这是年轻代用于分配新的对象的区域。</li>
<li>O，代表老年代，这是我们今天要重点讲的内容。</li>
<li>M，代表metaspace，这块内容以后再讲（也有可能永远不再讲了，看情况）</li>
<li>CCS，压缩使用比例。可以先不管这个。这个和使用压缩指针有关系。可以使用-XX:-UseCompressedOops关掉压缩的功能，这一项就不再打印了。</li>
<li>YGC，年轻代回收的次数。</li>
<li>YGCT，年轻代回收所使用的时间。由于年轻代的回收使用copy GC。会让所有Java线程都停顿下来，所以这一项就是指用于年轻代回收的时间。</li>
<li>FGC，这一项就比较复杂了。在不同的GC组合中代表不同的意义，后面会详细讲到。</li>
<li>FGCT，与上面的FGC一定样的，字面意思是full gc time，但在不同的GC选项下，意义有所不同。</li>
<li>GCT，一般来说，等于YGCT与FGCT之和。</li>
</ul>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><ul>
<li><p><strong>串行收集器（Serial）</strong><br>比较老的收集器，单线程。收集时，必须暂停应用的工作线程，直到收集结束。</p>
</li>
<li><p><strong>并行收集器（Parallel）</strong><br>多条垃圾收集线程并行工作，在多核CPU下效率更高，应用线程仍然处于等待状态。</p>
</li>
<li><p>CMS收集器（Concurrent Mark Sweep）</p>
<p>CMS收集器是缩短暂停应用时间为目标而设计的，是基于标记-清除算法实现，整个过程分为4个步骤，包括：</p>
<ul>
<li>初始标记（Initial Mark）</li>
<li>并发标记（Concurrent Mark）</li>
<li>重新标记（Remark）</li>
<li>并发清除（Concurrent Sweep）</li>
</ul>
<p>单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</p>
</li>
</ul>
<p>​        <strong>JDK1.8默认使用</strong>的垃圾回收器</p>
<ul>
<li>G1</li>
</ul>
<p>​           Garbage First</p>
<p>​            JDK 9以后默认使用，而且替代了CMS 收集器</p>
<p>​      G1的特点</p>
<ul>
<li>G1不再坚持固定大小以及固定数量的<br>分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的<br>Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的<br>旧对象都能获取很好的收集效果</li>
</ul>
<img src="https://tse1-mm.cn.bing.net/th/id/R-C.d6e8f8b74e546354d6cc594269f88487?rik=BezOq%2fgcDZHlWw&riu=http%3a%2f%2fupload-images.jianshu.io%2fupload_images%2f2184951-256a9ccb6e51be85.png&ehk=6aQFuTMvcG2m353MYMeVw4gN4PZ0p1xl%2bkzX5pUOPEk%3d&risl=&pid=ImgRaw&r=0" srcset="/img/loading.gif" lazyload alt="查看源图像" style="zoom: 50%;">

<p>G1：分为了四个执行步骤：</p>
<img src="/2021/10/03/jvm/image.2BEI70.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;">

<ul>
<li>初始标记，</li>
<li>并发标记，</li>
<li>最终标记，</li>
<li>筛选回收</li>
</ul>
<p>初始标记，标记一下GC Roots能直接关联到的对象。并发标记从GC Root开始标记存活对象，这个阶段耗时比较长，但也可以与应用线程并发执行。而最终标记也是为了修正在并发标记期间因用户程序继续运作而导致标记产生变化的那一部分标记记录。最后在筛选回收阶段对各个Region回收价值和成本进行排序，根据用户所期望的GC暂停时间来执行回收。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-XX:+UseSerialGC</td>
<td align="left">串行收集器</td>
</tr>
<tr>
<td align="left">-XX:+UseParallelGC</td>
<td align="left">并行收集器</td>
</tr>
<tr>
<td align="left">-XX:+UseParallelGCThreads=8</td>
<td align="left">并行收集器线程数，同时有多少个线程进行垃圾回收，一般与CPU数量相等</td>
</tr>
<tr>
<td align="left">-XX:+UseParallelOldGC</td>
<td align="left">指定老年代为并行收集</td>
</tr>
<tr>
<td align="left">-XX:+UseConcMarkSweepGC</td>
<td align="left">CMS收集器（并发收集器）</td>
</tr>
<tr>
<td align="left">-XX:+UseCMSCompactAtFullCollection</td>
<td align="left">开启内存空间压缩和整理，防止过多内存碎片</td>
</tr>
<tr>
<td align="left">-XX:CMSFullGCsBeforeCompaction=0</td>
<td align="left">表示多少次Full GC后开始压缩和整理，0表示每次Full GC后立即执行压缩和整理</td>
</tr>
<tr>
<td align="left">-XX:CMSInitiatingOccupancyFraction=80%</td>
<td align="left">表示老年代内存空间使用80%时开始执行CMS收集，防止过多的Full GC</td>
</tr>
<tr>
<td align="left">-XX:+UseG1GC</td>
<td align="left">G1收集器</td>
</tr>
<tr>
<td align="left">-XX:MaxTenuringThreshold=0</td>
<td align="left">在年轻代经过几次GC后还存活，就进入老年代，0表示直接进入老年代</td>
</tr>
</tbody></table>
<ul>
<li>选择高效的GC算法，可有效减少停止应用线程时间。</li>
<li>频繁Full GC会增加暂停时间和CPU使用率，可以加大老年代空间大小降低Full GC，但会增加回收时间，根据业务适当取舍。</li>
</ul>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>类从被加载到虚拟机内存到被卸载，整个完整的生命周期包括：类加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证，准备，解析三个部分统称为连接。接下来我们可以详细了解下类加载的各个过程。</p>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3279460766e7484dbee19e086739d0f0~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.awebp" srcset="/img/loading.gif" lazyload alt="img" style="zoom:33%;">

<p>这里还是快进到看《深入理解Java虚拟机》把</p>
<p>虽然classloader的加载过程有复杂的5步，但事实上除了加载之外的四步，其它都是由JVM虚拟机控制的，我们除了适应它的规范进行开发外，能够干预的空间并不多。而加载则是我们控制classloader实现特殊目的最重要的手段了。</p>
<p>双亲委托机制</p>
<p>这个东西和事件分发有点相反，事件分发是先往下推，在往上推，而类加载机制是先往上推，没人推了，在执行</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e6b8ee8c76847ed85f25d2624c35985~tplv-k3u1fbpfcp-no-mark:1280:960:0:0.awebp" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 33%;">

<p>双亲委派模型能够保证同一个类最终会被特定的类加载器加载。</p>
<p>例如类java.lang.Object,它存放在rt.jart之中.无论哪一个类加载器都要加载这个类.最终都是双亲委派模型最顶端的Bootstrap类加载器去加载.因此Object类在程序的各种类加载器环境中都是同一个类.相反.如果没有使用双亲委派模型.由各个类加载器自行去加载的话.如果用户编写了一个称为“java.lang.Object”的类.并存放在程序的ClassPath中.那系统中将会出现多个不同的Object类.java类型体系中最基础的行为也就无法保证.应用程序也将会一片混乱.</p>
<p>类加载器：</p>
<ul>
<li><p>启动类加载器(Bootstrap Classloader)负责将<JAVA_HOME>/lib目录下并且被虚拟机识别的类库加载到虚拟机内存中。我们常用基础库，例如java.util.**，java.io.**，java.lang.**等等都是由根加载器加载。</JAVA_HOME></p>
<p>由C++写的,由JVM启动</p>
</li>
<li><p>扩展类加载器(Extention Classloader)负责加载JVM扩展类，比如swing系列、内置的js引擎、xml解析器等，这些类库以javax开头，它们的jar包位于<JAVA_HOME>/lib/ext目录中。</JAVA_HOME></p>
</li>
<li><p>应用程序加载器(Application Classloader)也叫系统类加载器，它负责加载用户路径(ClassPath)上所指定的类库。我们自己编写的代码以及使用的第三方的jar包都是由它来加载的。</p>
</li>
<li><p>自定义加载器(Custom Classloader)通常是我们为了某些特殊目的实现的自定义加载器，</p>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/jvm/">jvm</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/jvm%E5%9F%BA%E7%A1%80/">jvm基础</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/10/03/rust%E8%BE%93%E5%85%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">rust输入的几种方式</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/10/03/kotlin/">
                        <span class="hidden-mobile">kotlin</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"e086c91aae8335308d3b","clientSecret":"83104ef0c9423fc74a3350da23fa29464dc09f20","repo":"clannad603.github.io","owner":"clannad603","adminUser":"['clannad603']","language":"zh-CN","perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token"},
          {
            id: '6a3d98217fa9f1989999633da8c8ea6b'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
