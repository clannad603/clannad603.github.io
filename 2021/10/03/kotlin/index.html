<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"clannad603.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="Kotlinkotlin是什么？Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift（确实长的很像），由 JetBrains 设计开发并开源。 Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。 在Google I&#x2F;O 2017中，Google 宣布 Kotlin 成为 Androi">
<meta property="og:type" content="article">
<meta property="og:title" content="kotlin">
<meta property="og:url" content="https://clannad603.github.io/2021/10/03/kotlin/index.html">
<meta property="og:site_name" content="普通重邮学生的blog">
<meta property="og:description" content="Kotlinkotlin是什么？Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift（确实长的很像），由 JetBrains 设计开发并开源。 Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。 在Google I&#x2F;O 2017中，Google 宣布 Kotlin 成为 Androi">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-10-03T05:44:58.000Z">
<meta property="article:modified_time" content="2021-10-03T05:49:42.912Z">
<meta property="article:author" content="HuangRui">
<meta property="article:tag" content="kotlin语言基础">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://clannad603.github.io/2021/10/03/kotlin/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://clannad603.github.io/2021/10/03/kotlin/","path":"2021/10/03/kotlin/","title":"kotlin"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>kotlin | 普通重邮学生的blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">普通重邮学生的blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Kotlin"><span class="nav-number">1.</span> <span class="nav-text">Kotlin</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#kotlin%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">kotlin是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kotlin%E5%A5%BD%E5%A4%84%E9%83%BD%E6%9C%89%E5%95%A5%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">Kotlin好处都有啥？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kotlin%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">Kotlin的一些基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.1.</span> <span class="nav-text">基本数据类型及简单操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">字符常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">通用类型转化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E8%BF%99%E4%B8%AA%E6%84%9F%E8%A7%89%E7%94%A8%E7%9A%84%E5%B0%91"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">位操作符（这个感觉用的少</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%B8%83%E5%B0%94%EF%BC%8C%E5%AD%97%E7%AC%A6%EF%BC%8C%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">字符串，布尔，字符，数组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E3%81%AE%E5%AF%BC%E5%85%A5"><span class="nav-number">1.4.</span> <span class="nav-text">包の导入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#kotlin%E4%BD%BF%E7%94%A8import-%E6%9D%A5%E5%AF%BC%E5%85%A5%E5%8C%85%EF%BC%8C%E5%AF%BC%E5%85%A5%E6%96%B9%E5%BC%8F%E4%B8%8Epython%E7%9B%B8%E4%BC%BC"><span class="nav-number">1.4.0.0.1.</span> <span class="nav-text">kotlin使用import 来导入包，导入方式与python相似</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-number">1.5.</span> <span class="nav-text">控制流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#if-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.5.1.</span> <span class="nav-text">if 表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#when%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.5.2.</span> <span class="nav-text">when表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.5.3.</span> <span class="nav-text">for循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.5.4.</span> <span class="nav-text">while循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E4%B8%8E%E8%B7%B3%E8%BD%AC"><span class="nav-number">1.5.5.</span> <span class="nav-text">返回与跳转</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E8%B7%B3%E8%BD%AC%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E6%A0%87%E7%AD%BE"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">结构化跳转表达式及标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E7%AD%BE%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="nav-number">1.5.5.2.</span> <span class="nav-text">标签的常用操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">1.6.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC"><span class="nav-number">1.6.1.</span> <span class="nav-text">类的基本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.6.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1companion-object"><span class="nav-number">1.6.3.</span> <span class="nav-text">伴生对象companion object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kotlin%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">1.6.4.</span> <span class="nav-text">Kotlin中的各种类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB"><span class="nav-number">1.6.4.2.</span> <span class="nav-text">数据类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E8%87%AA%E5%B8%A6%E8%A7%A3%E6%9E%84%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94componentN"><span class="nav-number">1.6.4.2.1.</span> <span class="nav-text">数据类自带解构方法——componentN()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E7%9A%84copy%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.4.2.2.</span> <span class="nav-text">数据类的copy函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E7%B1%BB"><span class="nav-number">1.6.4.3.</span> <span class="nav-text">单例类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">1.6.4.4.</span> <span class="nav-text">枚举类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%86%E5%B0%81%E7%B1%BB"><span class="nav-number">1.6.4.5.</span> <span class="nav-text">密封类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A7%94%E6%89%98"><span class="nav-number">1.6.5.</span> <span class="nav-text">委托</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%A7%94%E6%89%98"><span class="nav-number">1.6.5.1.</span> <span class="nav-text">属性委托</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%A7%94%E6%89%98"><span class="nav-number">1.6.5.2.</span> <span class="nav-text">类委托</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.7.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%EF%BC%8C%E5%8D%B3-%E2%80%9C%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B%E2%80%9D%EF%BC%8C%E5%B0%86%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%8C%96%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%9C%A8%E7%B1%BB%EF%BC%8C%E6%8E%A5%E5%8F%A3%EF%BC%8C%E6%96%B9%E6%B3%95%E4%B8%8A%E3%80%82"><span class="nav-number">1.7.1.</span> <span class="nav-text">泛型，即 “参数化类型”，将类型参数化，可以用在类，接口，方法上。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F%EF%BC%9A"><span class="nav-number">1.7.2.</span> <span class="nav-text">泛型约束：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%8B%E5%8F%98"><span class="nav-number">1.7.3.</span> <span class="nav-text">型变</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%A4%84%E5%9E%8B%E5%8F%98"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">声明处型变</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%9F%E5%8F%B7%E6%8A%95%E5%B0%84"><span class="nav-number">1.7.4.</span> <span class="nav-text">星号投射</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">1.8.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="nav-number">1.8.1.</span> <span class="nav-text">函数的基础操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kotlin%E4%B8%AD%E4%B8%8D%E5%90%8C%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.8.2.</span> <span class="nav-text">Kotlin中不同的函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8suspend%E6%A0%87%E8%AE%B0%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0%EF%BC%9A%E5%8D%8F%E7%A8%8B%E9%83%A8%E5%88%86%E8%AE%B2"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">使用suspend标记的协程挂起函数：协程部分讲</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8infix%E6%A0%87%E8%AE%B0%E7%9A%84%E4%B8%AD%E7%BC%80%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E5%BF%BD%E7%95%A5%E8%AF%A5%E8%B0%83%E7%94%A8%E7%9A%84%E7%82%B9%E4%B8%8E%E5%9C%86%E6%8B%AC%E5%8F%B7%EF%BC%89%EF%BC%9A"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">使用infix标记的中缀表示法（忽略该调用的点与圆括号）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8tailrec%E6%A0%87%E8%AE%B0%E7%9A%84%E5%B0%BE%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">使用tailrec标记的尾递归函数：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">1.8.2.4.</span> <span class="nav-text">泛型函数：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E8%A1%A8%E8%BE%BE%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">1.8.2.5.</span> <span class="nav-text">单表达函数：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E6%95%B0%E9%87%8F%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%88Varargs%EF%BC%89"><span class="nav-number">1.8.2.6.</span> <span class="nav-text">可变数量的参数（Varargs）:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">1.8.2.7.</span> <span class="nav-text">局部函数：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">1.8.2.8.</span> <span class="nav-text">成员函数：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">1.8.2.9.</span> <span class="nav-text">内联函数：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">1.8.2.10.</span> <span class="nav-text">高阶函数：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">1.8.2.11.</span> <span class="nav-text">匿名函数：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">1.8.2.12.</span> <span class="nav-text">作用域函数：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">1.8.2.13.</span> <span class="nav-text">扩展函数：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.8.3.</span> <span class="nav-text">lambda表达式及函数式接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%EF%BC%88SAM%EF%BC%89%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">函数式（SAM）接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SAM%E8%BD%AC%E5%8C%96"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">SAM转化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.8.3.3.</span> <span class="nav-text">Lambda表达式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kotlin%E7%9A%84%E7%A9%BA%E5%AE%89%E5%85%A8"><span class="nav-number">1.9.</span> <span class="nav-text">Kotlin的空安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.9.1.</span> <span class="nav-text">?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-1"><span class="nav-number">1.9.2.</span> <span class="nav-text">?.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-2"><span class="nav-number">1.9.3.</span> <span class="nav-text">!!</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#-3"><span class="nav-number">1.9.4.</span> <span class="nav-text">?:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#as"><span class="nav-number">1.9.5.</span> <span class="nav-text">as?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#let"><span class="nav-number">1.9.6.</span> <span class="nav-text">?.let{}</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E6%98%AF%E7%BB%9D%E5%AF%B9%E7%9A%84%E7%A9%BA%E6%8C%87%E9%92%88%E5%AE%89%E5%85%A8"><span class="nav-number">1.9.7.</span> <span class="nav-text">不是绝对的空指针安全</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="nav-number">1.10.</span> <span class="nav-text">集合和数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%EF%BC%9A"><span class="nav-number">1.10.1.</span> <span class="nav-text">数组：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%EF%BC%9A"><span class="nav-number">1.10.2.</span> <span class="nav-text">集合：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Set%EF%BC%9A"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">Set：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map"><span class="nav-number">1.10.2.2.</span> <span class="nav-text">Map:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list"><span class="nav-number">1.10.2.3.</span> <span class="nav-text">list:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E4%B8%8Eflow"><span class="nav-number">1.11.</span> <span class="nav-text">协程与flow</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">HuangRui</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://clannad603.github.io/2021/10/03/kotlin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HuangRui">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="普通重邮学生的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          kotlin
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-03 13:44:58 / 修改时间：13:49:42" itemprop="dateCreated datePublished" datetime="2021-10-03T13:44:58+08:00">2021-10-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/kotlin/" itemprop="url" rel="index"><span itemprop="name">kotlin</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h1><h2 id="kotlin是什么？"><a href="#kotlin是什么？" class="headerlink" title="kotlin是什么？"></a>kotlin是什么？</h2><p>Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift（确实长的很像），由 JetBrains 设计开发并开源。</p>
<p>Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。</p>
<p>在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言。</p>
<h2 id="Kotlin好处都有啥？"><a href="#Kotlin好处都有啥？" class="headerlink" title="Kotlin好处都有啥？"></a>Kotlin好处都有啥？</h2><p>作为现代语言，kotlin具有高效的特点，具有严格的“防空思想”，也是一门能让人甜到齁的语言，有接管java的意图，借助安卓走向全平台，spring走向后端，ksl用来操作gradle,基于jvm也使它具有很好的跨平台性，并且拥有很多其他语言的优越地方，比如协程等</p>
<h2 id="Kotlin的一些基础语法"><a href="#Kotlin的一些基础语法" class="headerlink" title="Kotlin的一些基础语法"></a>Kotlin的一些基础语法</h2><h3 id="基本数据类型及简单操作"><a href="#基本数据类型及简单操作" class="headerlink" title="基本数据类型及简单操作"></a>基本数据类型及简单操作</h3><table>
<thead>
<tr>
<th>类型</th>
<th>位宽度</th>
</tr>
</thead>
<tbody><tr>
<td>Double</td>
<td>64</td>
</tr>
<tr>
<td>Float</td>
<td>32</td>
</tr>
<tr>
<td>Long</td>
<td>64</td>
</tr>
<tr>
<td>Int</td>
<td>32</td>
</tr>
<tr>
<td>Short</td>
<td>16</td>
</tr>
<tr>
<td>Byte</td>
<td>8</td>
</tr>
</tbody></table>
<h4 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h4><p>eg:</p>
<table>
<thead>
<tr>
<th>十进制：123</th>
</tr>
</thead>
<tbody><tr>
<td>长整型以大写的 L 结尾：123L</td>
</tr>
<tr>
<td>16 进制以 0x 开头：0x0F</td>
</tr>
<tr>
<td>2 进制以 0b 开头：0b00001011</td>
</tr>
<tr>
<td>注意：8进制不支持</td>
</tr>
<tr>
<td>Doubles 默认写法: 123.5, 123.5e10</td>
</tr>
<tr>
<td>Floats 使用 f 或者 F 后缀：123.5f</td>
</tr>
</tbody></table>
<h4 id="通用类型转化"><a href="#通用类型转化" class="headerlink" title="通用类型转化"></a>通用类型转化</h4><table>
<thead>
<tr>
<th>toByte(): Byte</th>
</tr>
</thead>
<tbody><tr>
<td>toShort(): Short</td>
</tr>
<tr>
<td>toInt(): Int</td>
</tr>
<tr>
<td>toLong(): Long</td>
</tr>
<tr>
<td>toFloat(): Float</td>
</tr>
<tr>
<td>toDouble(): Double</td>
</tr>
<tr>
<td>toChar(): Char</td>
</tr>
</tbody></table>
<h4 id="位操作符（这个感觉用的少"><a href="#位操作符（这个感觉用的少" class="headerlink" title="位操作符（这个感觉用的少"></a>位操作符（这个感觉用的少</h4><table>
<thead>
<tr>
<th>shl(bits) – 左移位 (Java’s &lt;&lt;)</th>
</tr>
</thead>
<tbody><tr>
<td>shr(bits) – 右移位 (Java’s &gt;&gt;)</td>
</tr>
<tr>
<td>ushr(bits) – 无符号右移位 (Java’s &gt;&gt;&gt;)</td>
</tr>
<tr>
<td>and(bits) – 与</td>
</tr>
<tr>
<td>or(bits) – 或</td>
</tr>
<tr>
<td>xor(bits) – 异或</td>
</tr>
<tr>
<td>inv() – 反向</td>
</tr>
</tbody></table>
<h4 id="字符串，布尔，字符，数组"><a href="#字符串，布尔，字符，数组" class="headerlink" title="字符串，布尔，字符，数组"></a>字符串，布尔，字符，数组</h4><p>字符不可当作数字操作，</p>
<p>布尔操作与java相同（||,!,&amp;&amp;)，</p>
<p>数组通过内置的Array类实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> b = Array(<span class="number">3</span>, &#123; i -&gt; (i * <span class="number">2</span>) &#125;)</span><br><span class="line"><span class="comment">//有点python列表表达式的感觉</span></span><br></pre></td></tr></table></figure>

<p>字符串可以通过trimMargin()来去掉多余空白</p>
<p>可以通过”$”来将变量整进字符串中</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> s = <span class="string">&quot;1 = <span class="variable">$a</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="包の导入"><a href="#包の导入" class="headerlink" title="包の导入"></a>包の导入</h2><h5 id="kotlin使用import-来导入包，导入方式与python相似"><a href="#kotlin使用import-来导入包，导入方式与python相似" class="headerlink" title="kotlin使用import 来导入包，导入方式与python相似"></a>kotlin使用import 来导入包，导入方式与python相似</h5><p>eg:</p>
<table>
<thead>
<tr>
<th>import org.example.Message                                                       // 现在 Message 可以不用限定符访问</th>
</tr>
</thead>
<tbody><tr>
<td>import org.example.* // “org.example”中的一切都可访问</td>
</tr>
<tr>
<td>import org.example.Message // Message 可访问<br>import org.test.Message as testMessage                                             // testMessage 代表“org.test.Message”</td>
</tr>
</tbody></table>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a>if 表达式</h3><p>在kotlin中 if表达式有返回值，因此与传统语言相比，带来了不少便捷</p>
<p>比如在java中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max ;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> d = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">if</span> (b&gt;d) &#123;</span><br><span class="line">    max  = b;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    max = d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在kotlin中，我们可以这样</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span>(a&gt;b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure>

<p>并且代码块的最后一个语句将作为返回值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    print(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="when表达式"><a href="#when表达式" class="headerlink" title="when表达式"></a>when表达式</h3><p>kotlin取消掉了switch case语法结构，使用了when来实现了相应功能</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; print(<span class="string">&quot;x == 1&quot;</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; print(<span class="string">&quot;x == 2&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123; <span class="comment">// 注意这个块</span></span><br><span class="line">        print(<span class="string">&quot;x is neither 1 nor 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且，可对多个目标进行匹配，如:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span> -&gt; print(<span class="string">&quot;x == 0 or x == 1&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">&quot;otherwise&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>when语句将对 “()” 里面的内容进行匹配，此内容作为主语，在代码块中可对此进行匹配操作(不限制与常量)</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> -&gt; print(<span class="string">&quot;x is in the range&quot;</span>)</span><br><span class="line">    <span class="keyword">is</span> String -&gt; print(<span class="string">&quot;x is String&quot;</span>)<span class="comment">//类型匹配</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">&quot;none of the above&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当when未加主语时，可类似用做if else 语句</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">    x.isOdd() -&gt; print(<span class="string">&quot;x is odd&quot;</span>)</span><br><span class="line">    y.isEven() -&gt; print(<span class="string">&quot;y is even&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">&quot;x+y is odd.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>kotlin中for循环可以对任何提供迭代器（iterator）的对象进行遍历，例如</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection) print(item)</span><br></pre></td></tr></table></figure>

<p>循环体同样也适用于代码块</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(item :<span class="built_in">Int</span> <span class="keyword">in</span> collection)&#123;</span><br><span class="line">    <span class="keyword">val</span> temp = <span class="number">1</span></span><br><span class="line">    print(item+temp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对数字区间的迭代</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从1到3</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">6</span> downTo <span class="number">0</span> step <span class="number">2</span>) &#123;</span><br><span class="line">    println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从6到0以2为步长</span></span><br></pre></td></tr></table></figure>

<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>kotlin的while循环与c等类似拥有while与do while</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    x--</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------</span></span><br><span class="line"><span class="keyword">var</span> x =<span class="number">10</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  x--</span><br><span class="line">&#125; <span class="keyword">while</span> (x !=<span class="number">0</span>) </span><br></pre></td></tr></table></figure>

<p>break与continue仍然适用</p>
<h3 id="返回与跳转"><a href="#返回与跳转" class="headerlink" title="返回与跳转"></a>返回与跳转</h3><h4 id="结构化跳转表达式及标签"><a href="#结构化跳转表达式及标签" class="headerlink" title="结构化跳转表达式及标签"></a>结构化跳转表达式及标签</h4><p>kotlin有三种结构化跳转表达式：</p>
<table>
<thead>
<tr>
<th>return。默认从最直接包围它的函数或者匿名函数返回。</th>
</tr>
</thead>
<tbody><tr>
<td>break。终止最直接包围它的循环</td>
</tr>
<tr>
<td>continue。继续下一次最直接包围它的循环。</td>
</tr>
</tbody></table>
<p>此外，这三种表达式都可以使用标签来进行标记，标签格式为<em>abc@</em></p>
<p>eg:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">loop@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i+j==<span class="number">100</span>&amp;&amp;<span class="number">2</span>*i+3j==<span class="number">100</span>)&#123;</span><br><span class="line">             <span class="keyword">break</span><span class="symbol">@loop</span></span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>标签限制的 break 跳转到刚好位于该标签指定的循环后面的执行点。 <em>continue</em> 继续标签指定的循环的下一次迭代。</strong></p>
<h4 id="标签的常用操作"><a href="#标签的常用操作" class="headerlink" title="标签的常用操作"></a>标签的常用操作</h4><p>由于kotlin函数可以嵌套，因此我们在处理一些跳转时，比如从匿名函数中退出</p>
<p>假如是这样</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">3</span>) <span class="keyword">return</span><span class="comment">// 非局部直接返回到 foo() 的调用者</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;end of all&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于return 将退出函数，因此它将会退出整个函数</p>
<p>所以我们可以使用匿名函数来解决这个问题</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach(<span class="function"><span class="title">fun</span><span class="params">(it: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">3</span>) <span class="keyword">return</span><span class="comment">// 局部返回到匿名函数的调用者，即 forEach 循环</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;)</span><br><span class="line">    print(<span class="string">&quot;end of all&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但也可以使用标签来处理</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach <span class="symbol">lit@</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@lit</span> <span class="comment">// 局部返回到该 lambda 表达式的调用者，即 forEach 循环</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;end of all&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标签也可以返回值到指定位置</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span><span class="symbol">@a</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>他将返回1到”@a”</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类的基本"><a href="#类的基本" class="headerlink" title="类的基本"></a>类的基本</h3><p>kotlin使用class来声明类</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>()&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若无实体还可以这样写</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br></pre></td></tr></table></figure>

<p>kotlin的类构造器分为主构造器和多个次构造器</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">constructor</span></span>(name:String)&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若无需为添加注释或修饰符，可以省略</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>(name:String)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主构造函数不能包含任何的代码，初始化工作可以放在init的代码块中</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>(name:String)&#123;</span><br><span class="line">    <span class="keyword">var</span> nameUpper :String =<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        nameUpper = name.uppercase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明或初始化属性还可以这么写</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name:String)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类也可以声明前缀有constructor的次构造函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nameUpper :String =<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">constructor</span>(name:String)&#123;</span><br><span class="line">        nameUpper=name.uppercase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init代码块部分会成主构造函数的一部分，将在次构造函数前执行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Constructors</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Init block&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(i: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;Constructor&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未声明构造函数时，他将隐式的生成且可见性是public因此我们可以把他private掉</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GirlFriend</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>()&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主构造函数可以设置默认值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>(<span class="keyword">val</span> specices :String =<span class="string">&quot;human being&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>kotlin中无<code>new</code>关键字</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>kotlin的所有类拥有一个共同的超类Any </p>
<p><code>Any</code> 有三个方法：<code>equals()</code>、 <code>hashCode()</code> 与 <code>toString()</code>。因此，为所有 Kotlin 类都定义了这些方法。</p>
<p>默认情况下kotlin的类是<code>final</code>的，因此不可被继承，若要使他能被继承，则需要添加<code>open</code>关键字</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(name:String)</span><br></pre></td></tr></table></figure>

<p>若需要继承此类，则可这样表达</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> </span>(name:String):Person(name)</span><br></pre></td></tr></table></figure>

<p>对于继承后的属性，以下面的这个例子来说</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>(name:String)&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> nameUpper :String =<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> age:<span class="built_in">Int</span>=<span class="number">1</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        nameUpper = name.uppercase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:<span class="type">Person&#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> nameUpper :String =<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> age:<span class="built_in">Int</span>=<span class="number">2</span></span><br><span class="line">    <span class="keyword">constructor</span>(name:String):<span class="keyword">super</span>(name)&#123;</span><br><span class="line">        nameUpper=name.uppercase()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//次构造函数可以写多个继承不同属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于父类需要被覆盖属性，需要声明为<code>open</code>,然后在子类中添加<code>override</code>来进行标记，若此子类的属性不希望被覆盖掉，则可以添加<code>final</code>关键字，例如</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">override</span> <span class="keyword">var</span> age:<span class="built_in">Int</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>方法也是同样的</p>
<p>若我们希望子类调用父类的方法，则可以使用<code>super</code>关键字来进行调用，</p>
<p>[^使用super<T>来调用具体的属性或方法]: </T></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;this fruit is being ate&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Orange</span></span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;this orange is being ate&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lemon</span>: <span class="type">Fruit</span>,<span class="type">Orange</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;Fruit&gt;.eat()</span><br><span class="line">        <span class="keyword">super</span>&lt;Orange&gt;.eat()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="伴生对象companion-object"><a href="#伴生对象companion-object" class="headerlink" title="伴生对象companion object"></a>伴生对象companion object</h3><p><code>companion object</code> 修饰为伴生对象,伴生对象在类中只能存在一个，类似于java中的静态方法 Java 中使用类访问静态成员，静态方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = <span class="string">&quot;DemoManager&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">        Log.e(TAG,<span class="string">&quot;此时 companion objec t表示 伴生对象&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此<code>companion object</code>中调用不到外部成员变量（静态方法无法调用非静态成员变量）</p>
<h3 id="Kotlin中的各种类"><a href="#Kotlin中的各种类" class="headerlink" title="Kotlin中的各种类"></a>Kotlin中的各种类</h3><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类使用<code>abstract</code>来标记抽象类</p>
<p>类以及其中的某些成员可以声明为 <em>abstract</em>。 抽象成员在本类中可以不用实现</p>
<p>使用抽象类来覆盖一个非抽象的开放成员</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> : <span class="type">Polygon</span></span>() &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h4><p>kotlin使用<code>data</code>来标记数据类，在java16(最新的jvav16中使用了<code>record</code>关键字来实现了此功能)前，我们实现数据类功能可能需要这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而使用kotlin数据类，可以这样</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name :String, <span class="keyword">var</span> age :<span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>

<h5 id="数据类自带解构方法——componentN"><a href="#数据类自带解构方法——componentN" class="headerlink" title="数据类自带解构方法——componentN()"></a>数据类自带解构方法——componentN()</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (name,age) = p  <span class="comment">//解构p</span></span><br><span class="line">println(<span class="string">&quot;<span class="variable">$name</span> <span class="variable">$age</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="数据类的copy函数"><a href="#数据类的copy函数" class="headerlink" title="数据类的copy函数"></a>数据类的copy函数</h5><p>数据类使用copy函数来对数据类进行复制，并且可对其属性进行修改</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> jack = User(name = <span class="string">&quot;Jack&quot;</span>, age = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> olderJack = jack.copy(age = <span class="number">2</span>)</span><br><span class="line">    println(jack)</span><br><span class="line">    println(olderJack)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h4><p>kotlin中可以使用object来声明单例类</p>
<p>java中可以这么写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSington</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleSington INSTANCE;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">SimpleSington</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      INSTANCE = (SimpleSington)<span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> SimpleSington();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>在kotlin中可以这么写</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> SimpleSington &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>kotlin中使用<code>enum</code>关键字来标记一个枚举类</p>
<p>枚举类最基本的用法是实现一个类型安全的枚举。</p>
<p>枚举常量用逗号分隔,每个枚举常量都是一个对象。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">    RED,BLACK,BLUE,GREEN,WHITE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类可以进行初始化，默认值从0开始，需要指定值，则可以对其使用构造函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>(value:<span class="built_in">Int</span>)&#123;</span><br><span class="line">    ovel(<span class="number">100</span>),</span><br><span class="line">    rectangle(<span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h4><p>kotlin中使用sealed来标记一个密封类</p>
<p>密封类用来表示受限的类继承结构：当一个值为有限几种的类型, 而不能有任何其他类型时。在某种意义上，他们是枚举类的扩展：枚举类型的值集合 也是受限的，但每个枚举常量只存在一个实例，而密封类 的一个子类可以有可包含状态的多个实例。</p>
<p>声明一个密封类，使用 <strong>sealed</strong> 修饰类，密封类可以有子类，但是所有子类都必须在与密封类自身相同的文件中声明。（在 Kotlin 1.1 之前， 该规则更加严格：子类必须嵌套在密封类声明的内部）。</p>
<p>密封类的常用操作：</p>
<p>配合when来使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Const</span></span>(<span class="keyword">val</span> number: <span class="built_in">Double</span>) : Expr()</span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>(<span class="keyword">val</span> e1: Expr, <span class="keyword">val</span> e2: Expr) : Expr()</span><br><span class="line"><span class="keyword">object</span> NotANumber : Expr()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(expr: <span class="type">Expr</span>)</span></span>: <span class="built_in">Double</span> = <span class="keyword">when</span> (expr) &#123;</span><br><span class="line">    <span class="keyword">is</span> Const -&gt; expr.number</span><br><span class="line">    <span class="keyword">is</span> Sum -&gt; eval(expr.e1) + eval(expr.e2)</span><br><span class="line">    NotANumber -&gt; <span class="built_in">Double</span>.NaN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更像是一种枚举类的扩展</p>
<h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>kotlin中委托分为了属性委托和类委托两种</p>
<h4 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h4><p>属性委托指的是一个类的某个属性值不是在类中直接进行定义，而是将其托付给一个代理类，从而实现对该类的属性统一管理。</p>
<p>属性委托语法格式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>/<span class="keyword">var</span> &lt;属性名&gt;: &lt;类型&gt; <span class="keyword">by</span> &lt;表达式&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>var/val：属性类型(可变/只读)</th>
</tr>
</thead>
<tbody><tr>
<td>属性名：属性名称</td>
</tr>
<tr>
<td>类型：属性的数据类型</td>
</tr>
<tr>
<td>表达式：委托代理类</td>
</tr>
</tbody></table>
<p>by 关键字之后的表达式就是委托, 属性的 get() 方法(以及set() 方法)将被委托给这个对象的 getValue() 和 setValue() 方法。属性委托不必实现任何接口, 但必须提供 getValue() 函数(对于 var属性,还需要 setValue() 函数)。</p>
<p>eg:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.reflect.KProperty</span><br><span class="line"><span class="comment">// 定义包含属性委托的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p: String <span class="keyword">by</span> Delegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 委托的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$thisRef</span>, 这里委托了 <span class="subst">$&#123;property.name&#125;</span> 属性&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$thisRef</span> 的 <span class="subst">$&#123;property.name&#125;</span> 属性赋值为 <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> e = Example()</span><br><span class="line">    println(e.p)     <span class="comment">// 访问该属性，调用 getValue() 函数</span></span><br><span class="line"></span><br><span class="line">    e.p = <span class="string">&quot;Runoob&quot;</span>   <span class="comment">// 调用 setValue() 函数</span></span><br><span class="line">    println(e.p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h4><p>类的委托即一个类中定义的方法实际是调用另一个类的对象的方法来实现的。</p>
<p>以下实例中派生类 Derived 继承了接口 Base 所有方法，并且委托一个传入的 Base 类的对象来执行这些方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Base</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现此接口的被委托的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseImpl</span></span>(<span class="keyword">val</span> x: <span class="built_in">Int</span>) : Base &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123; print(x) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过关键字 by 建立委托类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span>(b: Base) : Base <span class="keyword">by</span> b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> b = BaseImpl(<span class="number">10</span>)</span><br><span class="line">    Derived(b).print() <span class="comment">// 输出 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在某些场景下，假设我们需要在某个类对某个接口的一些方法进行重写，通过类委托来减少强制我们需要重写的方法</p>
<p>比如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMap</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> realMap: HashMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt;) : MutableMap&lt;<span class="built_in">Int</span>, <span class="built_in">Int</span>&gt; <span class="keyword">by</span> realMap &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> lastKey = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">put</span><span class="params">(key: <span class="type">Int</span>, value: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">        lastKey = key</span><br><span class="line">        <span class="keyword">return</span> realMap.put(key,value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">recover</span><span class="params">()</span></span> &#123;</span><br><span class="line">        realMap.remove(lastKey)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过将MutableMap委托给realMap使得realMap获得其所有方法，因此只需对我们所关心的方法进行重写</p>
<p><a href="%5B(28%E6%9D%A1%E6%B6%88%E6%81%AF">更多内容查看</a> “by” the way ——借ViewModel创建方式探索Kotlin的委托机制_Omnipotent’s Blog-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43687181/article/details/115712877?spm=1001.2014.3001.5501">https://blog.csdn.net/weixin_43687181/article/details/115712877?spm=1001.2014.3001.5501</a>))</p>
<p>关于委托还有不少东西要说，鉴于篇幅，更多参考<a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/delegated-properties.html">官方文档</a></p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型，即-“参数化类型”，将类型参数化，可以用在类，接口，方法上。"><a href="#泛型，即-“参数化类型”，将类型参数化，可以用在类，接口，方法上。" class="headerlink" title="泛型，即 “参数化类型”，将类型参数化，可以用在类，接口，方法上。"></a>泛型，即 “参数化类型”，将类型参数化，可以用在类，接口，方法上。</h3><p>与 Java 一样，Kotlin 也提供泛型，为类型安全提供保证，消除类型强转的烦恼。</p>
<p>声明一个泛型类:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="type">T</span>&gt;</span>(t: T) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建类的实例时我们需要指定类型参数:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> box: Box&lt;<span class="built_in">Int</span>&gt; = Box&lt;<span class="built_in">Int</span>&gt;(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">val</span> box = Box(<span class="number">1</span>) <span class="comment">// 编译器会进行类型推断，1 类型 Int，所以编译器知道我们说的是 Box&lt;Int&gt;。</span></span><br></pre></td></tr></table></figure>

<h3 id="泛型约束："><a href="#泛型约束：" class="headerlink" title="泛型约束："></a>泛型约束：</h3><p>我们可以使用泛型约束来设定一个给定参数允许使用的类型。</p>
<p>Kotlin 中使用 : 对泛型的类型上限进行约束。</p>
<p>最常见的约束是上界(upper bound)：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="title">sort</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Comparable 的子类型可以替代 T。 例如:</span></span><br><span class="line">sort(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// OK。Int 是 Comparable&lt;Int&gt; 的子类型</span></span><br><span class="line">sort(listOf(HashMap&lt;<span class="built_in">Int</span>, String&gt;())) <span class="comment">// 错误：HashMap&lt;Int, String&gt; 不是 Comparable&lt;HashMap&lt;Int, String&gt;&gt; 的子类型</span></span><br></pre></td></tr></table></figure>

<p>对于多个上界约束条件，可以用 where 子句：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyWhenGreater</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;, threshold: <span class="type">T</span>)</span></span>: List&lt;String&gt;</span><br><span class="line">    <span class="keyword">where</span> T : CharSequence,</span><br><span class="line">          T : Comparable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> list.filter &#123; it &gt; threshold &#125;.map &#123; it.toString() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rust也是用的这玩意修饰的</p>
<h3 id="型变"><a href="#型变" class="headerlink" title="型变"></a>型变</h3><p>Kotlin 中没有通配符类型，它有两个其他的东西：声明处型变（declaration-site variance）与类型投影（type projections）</p>
<h4 id="声明处型变"><a href="#声明处型变" class="headerlink" title="声明处型变"></a>声明处型变</h4><p>声明处的类型变异使用协变注解修饰符：in、out，消费者 in, 生产者 out。</p>
<p>使用 out 使得一个类型参数协变，协变类型参数只能用作输出，可以作为返回值类型但是无法作为入参的类型：</p>
<p>in 使得一个类型参数逆变，逆变类型参数只能用作输入，可以作为入参的类型但是无法作为返回值的类型：</p>
<h3 id="星号投射"><a href="#星号投射" class="headerlink" title="星号投射"></a>星号投射</h3><p><a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/generics.html">看看官方的</a></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的基础操作"><a href="#函数的基础操作" class="headerlink" title="函数的基础操作"></a>函数的基础操作</h3><p>kotlin中使用<code>fun</code>来声明函数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">double</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数可以具有默认参数</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">read</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    b: <span class="type">Array</span>&lt;<span class="type">Byte</span>&gt;, </span></span></span><br><span class="line"><span class="params"><span class="function">    off: <span class="type">Int</span> = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    len: <span class="type">Int</span> = b.size,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123; <span class="comment">/*……*/</span> &#125;</span><br></pre></td></tr></table></figure>

<p>覆盖方法总是使用与基类型方法相同的默认参数值。 当覆盖一个带有默认参数值的方法时，必须从签名中省略默认参数值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(i: <span class="type">Int</span> = <span class="number">10</span>)</span></span> &#123; <span class="comment">/*……*/</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> : <span class="type">A</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(i: <span class="type">Int</span>)</span></span> &#123; <span class="comment">/*……*/</span> &#125;  <span class="comment">// 不能有默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个默认参数在一个无默认值的参数之前，那么该默认值只能通过使用<a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/functions.html#%E5%85%B7%E5%90%8D%E5%8F%82%E6%95%B0">具名参数</a>调用该函数来使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    bar: <span class="type">Int</span> = <span class="number">0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">    baz: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123; <span class="comment">/*……*/</span> &#125;</span><br><span class="line"></span><br><span class="line">foo(baz = <span class="number">1</span>) <span class="comment">// 使用默认值 bar = 0</span></span><br></pre></td></tr></table></figure>

<p>如果在默认参数之后的最后一个参数是 lambda 表达式，那么它既可以作为具名参数在括号内传入，也可以在括号外传入：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    bar: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    baz: <span class="type">Int</span> = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    qux: () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123; <span class="comment">/*……*/</span> &#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>) &#123; println(<span class="string">&quot;hello&quot;</span>) &#125;     <span class="comment">// 使用默认值 baz = 1</span></span><br><span class="line">foo(qux = &#123; println(<span class="string">&quot;hello&quot;</span>) &#125;) <span class="comment">// 使用两个默认值 bar = 0 与 baz = 1</span></span><br><span class="line">foo &#123; println(<span class="string">&quot;hello&quot;</span>) &#125;        <span class="comment">// 使用两个默认值 bar = 0 与 baz = 1</span></span><br></pre></td></tr></table></figure>

<h3 id="Kotlin中不同的函数"><a href="#Kotlin中不同的函数" class="headerlink" title="Kotlin中不同的函数"></a>Kotlin中不同的函数</h3><h4 id="使用suspend标记的协程挂起函数：协程部分讲"><a href="#使用suspend标记的协程挂起函数：协程部分讲" class="headerlink" title="使用suspend标记的协程挂起函数：协程部分讲"></a>使用<code>suspend</code>标记的协程挂起函数：协程部分讲</h4><h4 id="使用infix标记的中缀表示法（忽略该调用的点与圆括号）："><a href="#使用infix标记的中缀表示法（忽略该调用的点与圆括号）：" class="headerlink" title="使用infix标记的中缀表示法（忽略该调用的点与圆括号）："></a>使用<code>infix</code>标记的中缀表示法（忽略该调用的点与圆括号）：</h4><p>条件要求：</p>
<table>
<thead>
<tr>
<th>它们必须是成员函数或扩展函数；</th>
</tr>
</thead>
<tbody><tr>
<td>它们必须只有一个参数；</td>
</tr>
<tr>
<td>其参数不得接受可变数量的参数且不能有默认值</td>
</tr>
</tbody></table>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="built_in">Int</span>.<span class="title">shl</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123; …… &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用中缀表示法调用该函数</span></span><br><span class="line"><span class="number">1</span> shl <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于这样</span></span><br><span class="line"><span class="number">1.</span>shl(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>感觉用的不是很多</p>
<h4 id="使用tailrec标记的尾递归函数："><a href="#使用tailrec标记的尾递归函数：" class="headerlink" title="使用tailrec标记的尾递归函数："></a>使用<code>tailrec</code>标记的尾递归函数：</h4><p>Kotlin 支持一种称为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8">尾递归</a>的函数式编程风格。 这允许一些通常用循环写的算法改用递归函数来写，而无堆栈溢出的风险。 当一个函数用 <code>tailrec</code> 修饰符标记并满足所需的形式时，编译器会优化该递归，留下一个快速而高效的基于循环的版本：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> eps = <span class="number">1E-10</span> <span class="comment">// &quot;good enough&quot;, could be 10^-15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">findFixPoint</span><span class="params">(x: <span class="type">Double</span> = <span class="number">1.0</span>)</span></span>: <span class="built_in">Double</span></span><br><span class="line">        = <span class="keyword">if</span> (Math.abs(x - Math.cos(x)) &lt; eps) x <span class="keyword">else</span> findFixPoint(Math.cos(x))</span><br></pre></td></tr></table></figure>

<p>要符合 <code>tailrec</code> 修饰符的条件的话，函数必须将其自身调用作为它执行的最后一个操作。在递归调用后有更多代码时，不能使用尾递归，并且不能用在 try/catch/finally 块中。目前在 Kotlin for JVM 与 Kotlin/Native 中支持尾递归。</p>
<h4 id="泛型函数："><a href="#泛型函数：" class="headerlink" title="泛型函数："></a>泛型函数：</h4><p>kotlin中泛型函数的声明与 Java 相同，类型参数要放在函数名的前面：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">boxIn</span><span class="params">(value: <span class="type">T</span>)</span></span> = Box(value)</span><br></pre></td></tr></table></figure>



<h4 id="单表达函数："><a href="#单表达函数：" class="headerlink" title="单表达函数："></a>单表达函数：</h4><p>当函数返回单个表达式时，可以省略花括号并且在 <strong>=</strong> 符号之后指定代码体即可</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">double</span><span class="params">(x: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = x * <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">double</span><span class="params">(x:<span class="type">Int</span>)</span></span>=x*<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="可变数量的参数（Varargs）"><a href="#可变数量的参数（Varargs）" class="headerlink" title="可变数量的参数（Varargs）:"></a>可变数量的参数（Varargs）:</h4><p>函数的参数（通常是最后一个）可以用 <code>vararg</code> 修饰符标记(类似与python中的*)：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">asList</span><span class="params">(<span class="keyword">vararg</span> ts: <span class="type">T</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> result = ArrayList&lt;T&gt;()</span><br><span class="line">    <span class="keyword">for</span> (t <span class="keyword">in</span> ts) <span class="comment">// ts is an Array</span></span><br><span class="line">        result.add(t)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> list = asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">//------如果要传递数组也是可以的</span></span><br><span class="line"><span class="keyword">val</span> a  = arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> list = asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,*a)</span><br><span class="line"><span class="comment">//在数组前面加&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="局部函数："><a href="#局部函数：" class="headerlink" title="局部函数："></a>局部函数：</h4><p>Kotlin 支持局部函数，即一个函数在另一个函数内部(确实很多高级语言都支持）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//官方给的dfs示例</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(graph: <span class="type">Graph</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> visited = HashSet&lt;Vertex&gt;()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dfs</span><span class="params">(current: <span class="type">Vertex</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited.add(current)) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> (v <span class="keyword">in</span> current.neighbors)</span><br><span class="line">            dfs(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(graph.vertices[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且这个是闭包的（支持局部函数的语言应该都通用）可以参考网络上大部分关于js的闭包</p>
<p>外部无法直接调用内部函数</p>
<h4 id="成员函数："><a href="#成员函数：" class="headerlink" title="成员函数："></a>成员函数：</h4><p>就是定义在类里面的函数（不就是方法吗</p>
<h4 id="内联函数："><a href="#内联函数：" class="headerlink" title="内联函数："></a>内联函数：</h4><p>被inline标记的函数就是内联函数,其原理就是:在编译时期,把调用这个函数的地方用这个函数的方法体进行替换</p>
<p>举个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">method</span><span class="params">( body: () -&gt; <span class="type">T</span>)</span></span>: T &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> body()</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对此方法在main中调用由kotlin字节码转java得到的是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TetsKt</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      method((Function0)<span class="keyword">null</span>.INSTANCE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>加了inline标记后是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TetsKt</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> var0 = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">int</span> var1 = <span class="keyword">false</span>;</span><br><span class="line">         String var4 = <span class="string">&quot;我是body的方法体&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         ;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可见inline使得函数整体被移动了过来</p>
<p>在编译时期就会把下面的内容替换到调用该方法的地方,这样就会减少方法压栈,出栈,进而减少资源消耗;</p>
<p>noline和crossline标记<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4f29c9724b33">更多参考</a></p>
<h4 id="高阶函数："><a href="#高阶函数：" class="headerlink" title="高阶函数："></a>高阶函数：</h4><p>在<code>Kotlin</code>中，高阶函数即指：将函数用作一个函数的参数或者返回值的函数</p>
<p>可能类似于数学中的高次？</p>
<p>个人理解是在函数中传递一个函数（通常是lambda表达式）</p>
<p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">val</span> sum=&#123;</span><br><span class="line">        d:<span class="built_in">Int</span>,e:<span class="built_in">Int</span>-&gt;d+e</span><br><span class="line">    &#125;</span><br><span class="line">    println(add(a,b,sum))</span><br><span class="line">    <span class="comment">//传递一个lambda表达式</span></span><br><span class="line">    println(add(a,b)&#123;</span><br><span class="line">        a,b-&gt;a+b</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//由于lambda表达式是最后一个，所以可以直接&#123;&#125;</span></span><br><span class="line">    println(add(a,b,::sumOf))</span><br><span class="line">    <span class="comment">//：：创建函数类型对象的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sumOf</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span>=a+b</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>,sum:(<span class="type">a</span>:<span class="type">Int</span>,<span class="type">b</span>:<span class="type">Int</span>)-&gt;<span class="type">Int</span>)</span></span>=sum(a,b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://rengwuxian.com/kotlin-lambda/">康康扔物线咋说的</a></p>
<h4 id="匿名函数："><a href="#匿名函数：" class="headerlink" title="匿名函数："></a>匿名函数：</h4><p>匿名函数顾名思义就是没有名字的函数，那这种没有名字的函数我们怎么调用呢？答案是无法直接调用。匿名函数可以赋值给一个变量，或者当作实参直接传递给一个函数类型的形参。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fun</span><span class="params">(appleBean: <span class="type">AppleBean</span>)</span></span>: <span class="built_in">Boolean</span> = appleBean.weight &gt; <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>就是没有名字（</p>
<p>此外，匿名函数还可以赋值给变量</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> filterWeightFunPredicate =</span><br><span class="line">            <span class="function"><span class="title">fun</span><span class="params">(appleBean: <span class="type">AppleBean</span>)</span></span>: <span class="built_in">Boolean</span> = appleBean.weight</span><br></pre></td></tr></table></figure>

<p>差不多和lambda表达式用法一样</p>
<h4 id="作用域函数："><a href="#作用域函数：" class="headerlink" title="作用域函数："></a>作用域函数：</h4><p>Kotlin 的作用域函数有五种：<code>let</code>、<code>run</code>、<code>with</code>、<code>apply</code> 以及 <code>also</code>。</p>
<p>这些函数基本上做了同样的事情：在一个对象上执行一个代码块。</p>
<p>典型用法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> adam = Person(<span class="string">&quot;Adam&quot;</span>).apply &#123; </span><br><span class="line">    age = <span class="number">20</span></span><br><span class="line">    city = <span class="string">&quot;London&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">println(adam)</span><br><span class="line"><span class="comment">//------不使用apply的话</span></span><br><span class="line"><span class="keyword">val</span> adam = Person(<span class="string">&quot;Adam&quot;</span>)</span><br><span class="line">adam.age = <span class="number">20</span></span><br><span class="line">adam.city = <span class="string">&quot;London&quot;</span></span><br><span class="line">println(adam)</span><br></pre></td></tr></table></figure>

<p>这几种第一行代码第三版的讲的很清楚，这里只是简单提及一下</p>
<p><a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/scope-functions.html">也可以看看这个</a></p>
<h4 id="扩展函数："><a href="#扩展函数：" class="headerlink" title="扩展函数："></a>扩展函数：</h4><p>Kotlin的扩展函数可以让你作为一个类成员进行调用的函数，但是是定义在这个类的外部。这样可以很方便的扩展一个已经存在的类，为它添加额外的方法。</p>
<p>例子：</p>
<p>假如我们需要为String类型添加一个返回这个字符串最后一个字符的方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastChar</span><span class="params">()</span></span>: <span class="built_in">Char</span> = <span class="keyword">this</span>.<span class="keyword">get</span>(<span class="keyword">this</span>.length - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Kotlin&quot;</span>.lastChar())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展函数用于安卓中，可以对String类进行扩展使得我们打toast更方便一点</p>
<p>也可以对view进行扩展，比如添加一个动画函数等</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7291c9a1ec1e">更多内容</a></p>
<h3 id="lambda表达式及函数式接口"><a href="#lambda表达式及函数式接口" class="headerlink" title="lambda表达式及函数式接口"></a>lambda表达式及函数式接口</h3><h4 id="函数式（SAM）接口"><a href="#函数式（SAM）接口" class="headerlink" title="函数式（SAM）接口"></a>函数式（SAM）接口</h4><p>只有一个抽象方法的接口称为<em>函数式接口</em>或 <em>SAM（单一抽象方法）</em>接口。函数式接口可以有多个非抽象成员，但只能有一个抽象成员。</p>
<p>可以用 <code>fun</code> 修饰符在 Kotlin 中声明一个函数式接口。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> KRunnable &#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SAM转化"><a href="#SAM转化" class="headerlink" title="SAM转化"></a>SAM转化</h4><p>例如，假定存在函数式接口</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> IntPredicate &#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">accept</span><span class="params">(i: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不使用 SAM 转换，那么你需要像这样编写代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个类的实例</span></span><br><span class="line"><span class="keyword">val</span> isEven = <span class="keyword">object</span> : IntPredicate &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">accept</span><span class="params">(i: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用lambda转换后</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isEven = IntPredicate &#123; it % <span class="number">2</span> == <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>

<p>lambda匿名内部类实锤确信</p>
<h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p>上文提及不少，此处不再提了，更多本文高阶函数部分</p>
<h2 id="Kotlin的空安全"><a href="#Kotlin的空安全" class="headerlink" title="Kotlin的空安全"></a>Kotlin的空安全</h2><h3 id><a href="#" class="headerlink" title="?"></a>?</h3><p>kotlin在默认情况下，我们创建的所有变量都是不允许为空的，必须给其指定一个值，如果给它赋值为 null，就会报错。如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str: String = <span class="literal">null</span><span class="comment">//出错，默认情况下不能为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name:String =<span class="string">&quot;tandeneck&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">assignNull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        name = <span class="literal">null</span> <span class="comment">//出错，不能赋值为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然要想他为空加个”?”就可以了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str:String ?=<span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title="?."></a>?.</h3><p>当我们要对一个对象调用方法时，需要对其进行判空处理，就可以这样干</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textView?.textSize = <span class="number">20f</span></span><br></pre></td></tr></table></figure>

<p>这个写法同样会对变量做一次非空确认之后再调用方法</p>
<h3 id="-2"><a href="#-2" class="headerlink" title="!!"></a>!!</h3><p>这个叫做非空断言，差不多意思是我肯定他是非空的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textView!!.textSize = <span class="number">20f</span></span><br></pre></td></tr></table></figure>

<h3 id="-3"><a href="#-3" class="headerlink" title="?:"></a>?:</h3><p>Elvis 操作符能够大大简化 if-else 表达式，如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> length1: <span class="built_in">Int</span> = <span class="keyword">if</span> (b != <span class="literal">null</span>) b.length <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> length2: <span class="built_in">Int</span> = b?.length ?: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="as"><a href="#as" class="headerlink" title="as?"></a>as?</h3><p>Kotlin 可以使用 as 关键字来进行类型转换，如果对象不是目标类型，那么类型转换可能会导致 ClassCastException。这时我们选择 as? ,如果尝试转换不成功则会返回 null：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">&quot;string&quot;</span></span><br><span class="line">    <span class="keyword">val</span> num: <span class="built_in">Int</span>? = str <span class="keyword">as</span>? <span class="built_in">Int</span></span><br><span class="line">    println(num)</span><br><span class="line">    <span class="comment">//输出 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="let"><a href="#let" class="headerlink" title="?.let{}"></a>?.let{}</h3><p>let函数除了可用于在同一个作用域下操作变量外还可以用作做判null操作：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;&quot;</span></span><br><span class="line">    str?.let &#123; println(it)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不是绝对的空指针安全"><a href="#不是绝对的空指针安全" class="headerlink" title="不是绝对的空指针安全"></a>不是绝对的空指针安全</h3><p>Kotlin中并不是绝对的空指针安全，最常见的就是在Kotlin去调Java代码，比如下面这个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> static String getMsg() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//kotlin</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(Test.getMsg().length)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>会引发空指针</p>
<p>可通过加”?”来解决这个问题</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test.getMsg()?.length</span><br></pre></td></tr></table></figure>

<p>涉及的一些原理可以看看这个-&gt;<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904048987127822">更多查看</a></p>
<h2 id="集合和数组"><a href="#集合和数组" class="headerlink" title="集合和数组"></a>集合和数组</h2><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><p>数组在上文中简单的提及到了创建，和其他语言相同可以通过下标来进行访问，数组包含一下几种类型及创建方法</p>
<table>
<thead>
<tr>
<th>intArrayOf()整型</th>
</tr>
</thead>
<tbody><tr>
<td>longArrayOf()长整型</td>
</tr>
<tr>
<td>floatArrayOf()单精度</td>
</tr>
<tr>
<td>doubleArrayOf()双精度</td>
</tr>
<tr>
<td>booleanArrayOf()布尔型</td>
</tr>
</tbody></table>
<p>创建默认值为null的数组</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayOfNulls&lt;<span class="built_in">Int</span>&gt;(<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>创建空数组</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emptyArray&lt;<span class="built_in">Int</span>&gt;()</span><br></pre></td></tr></table></figure>

<p>三维数组（</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arrB = Array(<span class="number">3</span>)&#123;Array(<span class="number">3</span>)&#123;IntArray(<span class="number">3</span>)&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过下标或者set()函数来修改值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intArr[index] = <span class="number">0</span> <span class="comment">//与java一样，可以这样修改数据</span></span><br><span class="line">intArr.<span class="keyword">set</span>(index,<span class="number">1</span>) <span class="comment">//kotlin可以通过set函数进行修改数据</span></span><br></pre></td></tr></table></figure>

<h3 id="集合："><a href="#集合：" class="headerlink" title="集合："></a>集合：</h3><p>Kotlin的集合分类：</p>
<ul>
<li>可变集合类（Mutable）</li>
<li>不可变集合类（Immutable）。</li>
</ul>
<p>集合类存放的都是对象的引用，而非对象本身，我们通常说的集合中的对象指的是集合中对象的引用。集合类型主要有List(列表)，Set(集)，Map(映射)。</p>
<h4 id="Set："><a href="#Set：" class="headerlink" title="Set："></a>Set：</h4><table>
<thead>
<tr>
<th>特性：无序不重复，大小固定，元素类型不可变</th>
</tr>
</thead>
<tbody><tr>
<td>定义：Set&lt;泛型&gt;或setOf(元素1，元素2，…，元素n)</td>
</tr>
<tr>
<td>主要方法：交、差、并、补</td>
</tr>
</tbody></table>
<p>创建并输出集合内容</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> languages = setOf(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;Python&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (language <span class="keyword">in</span> languages) &#123;</span><br><span class="line">    println(language)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用foreach来遍历</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">languages.forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Map"><a href="#Map" class="headerlink" title="Map:"></a>Map:</h4><p>只读Map。<br>可变的MutableMap(MutableMap、HashMap、LinkedHashMap)。</p>
<p>创建map并输出:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> map = mapOf(<span class="string">&quot;hello&quot;</span> to <span class="string">&quot;world&quot;</span>,<span class="string">&quot;1&quot;</span> to <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    println(map)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="list"><a href="#list" class="headerlink" title="list:"></a>list:</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listOf&lt;T&gt;()<span class="comment">//创建固定元素个数的list</span></span><br><span class="line">mutableListOf&lt;T&gt;()<span class="comment">//创建可读可修改的集合</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.forEachIndexed &#123; index, value -&gt;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$index</span> <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//使用这种遍历带下标的</span></span><br><span class="line"><span class="comment">//也可以使用foreach</span></span><br></pre></td></tr></table></figure>

<p>增删查改更多<a target="_blank" rel="noopener" href="http://www.kotlincn.net/docs/reference/collections-overview.html">参考官方文档</a></p>
<h2 id="协程与flow"><a href="#协程与flow" class="headerlink" title="协程与flow"></a>协程与flow</h2>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/kotlin%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" rel="tag"># kotlin语言基础</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/10/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E3%80%8A2%E3%80%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" rel="prev" title="深度学习入门《2》神经网络">
                  <i class="fa fa-chevron-left"></i> 深度学习入门《2》神经网络
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/10/03/jvm/" rel="next" title="jvm">
                  jvm <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HuangRui</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">61k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">56 分钟</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
